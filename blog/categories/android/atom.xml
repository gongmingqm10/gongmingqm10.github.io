<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: android | gongmingqm10]]></title>
  <link href="http://www.gongmingqm10.net/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://www.gongmingqm10.net/"/>
  <updated>2015-01-22T01:07:33+08:00</updated>
  <id>http://www.gongmingqm10.net/</id>
  <author>
    <name><![CDATA[Gong Ming]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android布局封装控件]]></title>
    <link href="http://www.gongmingqm10.net/blog/2014/11/13/androidbu-ju-feng-zhuang-kong-jian/"/>
    <updated>2014-11-13T16:10:37+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2014/11/13/androidbu-ju-feng-zhuang-kong-jian</id>
    <content type="html"><![CDATA[<p>近期时间略紧，许久没有更新博客了。今天做项目过程中，学习了Android关于封装控件的一些简单知识，特纪录下来并和大家交流。</p>

<p><a href="http://trickyandroid.com/protip-inflating-layout-for-your-custom-view/">http://trickyandroid.com/protip-inflating-layout-for-your-custom-view/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android电话监听]]></title>
    <link href="http://www.gongmingqm10.net/blog/2014/10/29/androiddian-hua-jian-ting/"/>
    <updated>2014-10-29T11:11:48+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2014/10/29/androiddian-hua-jian-ting</id>
    <content type="html"><![CDATA[<p>看题名，本篇博文似乎是关于怎么监听别人的电话。其实不然，这里我主要做的是监听自己的电话。监听自己电话的场景来源如下：<br/>
我最近在换手机，当然也在换号。于是面对两个号码两部手机，特别是一些捆绑了银行卡活着以前的快递等情况下，我必须得带两部手机出门，防止旧手机上重要的电话漏接。最开始是想直接进行通过转接，但是面对电信和移动间的通话转移，我放弃了这个想法。于是开始想着用软件提醒。<br/>
在老手机上安装APP，这个APP的作用是监听来电，来电挂断之后会自动给你设定的新手机上发送短信，告诉你谁给你打来了一个未接电话，这样你在新手机上看到短信来电提醒，于是可以直接在新手机上进行回复了。虽然不能直接解决通话的问题，但是确解决了我的问题。考虑到老手机上每个月的短信套餐，发现其实成本也几乎为零。</p>

<p>实现部分主要注册一个CallReceiver，并给我们的Receiver监听电话，发送短信，开机重启等权限。编译通过后便可以安装在手机上使用了。贴出主要代码：</p>

<p>```
package net.gongmingqm10.callwatcher;</p>

<p>import android.app.Service;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.telephony.SmsManager;
import android.telephony.TelephonyManager;
import android.util.Log;</p>

<p>public class CallReceiver extends BroadcastReceiver {</p>

<pre><code>private final static String NUMBER = "Your Phone number"; //我的新手机号
@Override
public void onReceive(Context context, Intent intent) {
    if (intent.getAction().equals(Intent.ACTION_NEW_OUTGOING_CALL)) return;
    TelephonyManager tm = (TelephonyManager) context.getSystemService(Service.TELEPHONY_SERVICE);
    SmsManager sms = SmsManager.getDefault();
    Log.i("state", "state = " + tm.getCallState());
    if (tm.getCallState() == TelephonyManager.CALL_STATE_IDLE) {
        String incomingNumber = intent.getStringExtra("incoming_number");
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        sms.sendTextMessage(NUMBER, "", "主人，有人给你附属机打电话了：" + incomingNumber, null, null);
    }
}
</code></pre>

<p>}</p>

<p>```</p>

<p>```
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;utf-8&rdquo;?>
&lt;manifest xmlns:android=&ldquo;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&rdquo;</p>

<pre><code>package="net.gongmingqm10.callwatcher" &gt;

&lt;uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"/&gt;
&lt;uses-permission android:name="android.permission.READ_PHONE_STATE"/&gt;
&lt;uses-permission android:name="android.permission.PROCESS_OUTGOING_CALLS"/&gt;
&lt;uses-permission android:name="android.permission.SEND_SMS"/&gt;

&lt;application
    android:allowBackup="true"
    android:icon="@drawable/ic_launcher"
    android:label="@string/app_name"
    android:theme="@style/AppTheme" &gt;
    &lt;activity
        android:name=".MainActivity"
        android:label="@string/app_name" &gt;
        &lt;intent-filter&gt;
            &lt;action android:name="android.intent.action.MAIN" /&gt;

            &lt;category android:name="android.intent.category.LAUNCHER" /&gt;
        &lt;/intent-filter&gt;
    &lt;/activity&gt;
    &lt;receiver android:name=".CallReceiver"&gt;
        &lt;intent-filter&gt;
            &lt;action android:name="android.intent.action.BOOT_COMPLETED"/&gt;
            &lt;action android:name="android.intent.action.PHONE_STATE"/&gt;
            &lt;action android:name="android.intent.action.NEW_OUTGOING_CALL"/&gt;
        &lt;/intent-filter&gt;
    &lt;/receiver&gt;
&lt;/application&gt;
</code></pre>

<p></manifest></p>

<p>```</p>

<p>主界面几乎没任何交互。主要实现功能，想更多交互的话可以继续～</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Data Cache]]></title>
    <link href="http://www.gongmingqm10.net/blog/2014/10/28/android-data-cache/"/>
    <updated>2014-10-28T17:11:26+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2014/10/28/android-data-cache</id>
    <content type="html"><![CDATA[<p>Android APP开发过程中，我们通常会加入缓存模块。缓存即在本地保存APP的一些数据，大部分是将网络请求的数据进行本地保存，这样在缓存数据有效期内就可以直接使用缓存数据，降低了APP和服务器的压力，也极大提升了用户体验。Android数据缓存既可以以数据表的形式进行保存，也可以以文件的形式进行缓存。这里我主要通过缓存文件存储数据，并在APP下一次启动时读取。</p>

<h3>Usage</h3>

<p>整个Cache模块的设计思想很简单，每个缓存数据都对应一个key，每个缓存数据又会被存到以此key命名的文件中，需要时直接读取。关键类分别为<code>CacheData</code>, <code>CacheManager</code>, <code>CacheUtils</code>。</p>

<ul>
<li>CacheData：数据封装类，所有欲缓存的数据都通过CacheData封装，CacheData中能够定义缓存有效期，并可以通过getData()直接获取真实的缓存数据。</li>
<li>CacheManager: 缓存管理类，单例模式设计，负责缓存的存储和读取。</li>
<li>CacheUtils: 缓存常用类，所有的缓存Key都应该在这个类中定义，此类还定义了一些时间常量，缓存有效期中可以使用。</li>
</ul>


<p>使用方法如下：</p>

<ul>
<li>step1: <code>CacheManager.init(Context context)</code>, 在APP加载时就应该对CacheManager初始化。</li>
<li>step2: 自定义的Model需要实现序列化，使用CacheData进行包装，然后使用CacheManager进行存储和读取。</li>
</ul>


<h3>Code Download</h3>

<p>项目代码托管在<a href="https://github.com/gongmingqm10/AndroidUikit/tree/master/library/src/main/java/org/gongming/common/cache">Github Repo</a>中，欢迎star和fork。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hack 京东Lebook]]></title>
    <link href="http://www.gongmingqm10.net/blog/2014/10/26/hack-jing-dong-lebook/"/>
    <updated>2014-10-26T22:46:18+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2014/10/26/hack-jing-dong-lebook</id>
    <content type="html"><![CDATA[<p>adb devices : 列出所有的设备</p>

<p>adb -s XXXX shell: 进入指定的shell</p>

<p>adb shell: 进入唯一的shell</p>

<p>在terminal中直接： adb pull /data/data/com.jingdong.app.reader/files/epub/3690098/534543.jeb <br/>
~/Desktop/test.epub。可以直接拿到epub文件</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Openfire - Android IM 框架使用]]></title>
    <link href="http://www.gongmingqm10.net/blog/2014/10/21/openfire-android-im-kuang-jia-shi-yong/"/>
    <updated>2014-10-21T10:02:58+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2014/10/21/openfire-android-im-kuang-jia-shi-yong</id>
    <content type="html"><![CDATA[<p>IM(Instant Messaging)在Android中可谓运用广泛。QQ，Wechat，陌陌等应用都可以看作IM实时通讯APP，实时通讯在社交类APP中运用范围较广，其功能看起来也是比较cool的。今天我们将研究一下android IM软件是如何实现的。像IM这种实施通讯软件，除非公司有比较大的实力和精力，才会自己去整这么一套框架。对于广大中小软件开发者来说，想到比较多的就是开源框架。Opensource对于开发者来说简直就是福音，对于整个软件行业也起到了不小的推动性的作用。<br/>
Openfire在这种环境下应运而生，而且作为实时通讯类开源框架迅速走红，下面我们就一起来学习这样一款拯救宇宙的开源框架，文章的最后会运用Openfire做出一个可以实时通讯的AndroidAPP，如果结合上地理位置再多点UI和交互上的设计提升，这不就是陌陌吗？YY了一会，觉得挺有趣，那么 <code>Just do it</code>。</p>

<p>Openfire概念性介绍请点击：<a href="http://blog.csdn.net/ithomer/article/details/7192257">http://blog.csdn.net/ithomer/article/details/7192257</a><br/>
Openfire官网：<a href="http://www.igniterealtime.org/">http://www.igniterealtime.org/</a><br/>
Openfire安装文档：<a href="http://www.igniterealtime.org/builds/openfire/docs/latest/documentation/install-guide.html">http://www.igniterealtime.org/builds/openfire/docs/latest/documentation/install-guide.html</a></p>

<h3>1. 选择服务器</h3>

<p>对于实时通讯软件，除了我们的客户端，服务器端更是关键。因为服务器是连接两个会话的桥梁。根据安装文档中，Openfire提供了多个平台的安装版本。Windows, Linux/Unix。所以支持还是很丰富的。至于服务器的选择我们可以选择自己的ECS，本地PC，或者Linux虚拟机。选择本机安装的请略过此步骤。<br/>
为了更加符合真实的安装环境，我选择本地的Linux虚拟机作为服务器环境。方便以后部署到真实的服务器环境中。  <br/>
在进行下一步之前请先在server上安装mysql和java。</p>

<h3>2. Install openfire</h3>

<p>从官网上下载对应的版本，我这里选择<a href="http://www.igniterealtime.org/downloads/index.jsp">Openfire_3.9.3 Linux版本</a>，登陆服务器后直接使用wget下载</p>

<p>```
wget <a href="http://www.igniterealtime.org/downloadServlet?filename=openfire/openfire-3.9.3-1.i386.rpm">http://www.igniterealtime.org/downloadServlet?filename=openfire/openfire-3.9.3-1.i386.rpm</a></p>

<p>//下载完成后使用rpm进行安装</p>

<p>rpm -ivh openfire-3.9.3-1.i386.rpm</p>

<p>```
Openfire安装完成后会在/opt目录下生成openfire/目录。
安装完成后就需要进行数据库的配置，按照官方文档：</p>

<p>```
Make sure that you are using MySQL 4.1.18 or later (5.x recommended) ¹.
Create a database for the Openfire tables:
mysqladmin create [databaseName]
(note: &ldquo;databaseName&rdquo; can be something like &lsquo;openfire&rsquo;)
Import the schema file from the resources/database directory of the installation folder:
Unix/Linux: cat openfire_mysql.sql | mysql [databaseName];
Windows: type openfire_mysql.sql | mysql [databaseName];
Start the Openfire setup tool, and use the appropriate JDBC connection settings.</p>

<p>```</p>

<p>首先使用<code>mysqladmin create openfire</code>创建名为openfire的数据库, <code>cd /opt/openfire/resources/database</code>进入openfire的数据库资源目录，使用<code>cat openfire_mysql.sql | mysql openfire</code>导入openfire的schema数据库文件。</p>

<h3>3. 启动Openfire服务</h3>

<p>使用rpm安装完成后的openfire会在/etc/init.d/中自动生成openfire 文件，可以直接在这里打开服务.</p>

<p>```
Usage /etc/init.d/openfire {start|stop|restart|status|condrestart|reload}</p>

<p>```</p>

<p>运行openfire服务：<code>/etc/init.d/openfire start</code>，运行<code>/etc/init.d/openfire status</code>显示没有成功运行。<br/>
查看log <code>cat /opt/openfire/logs</code>，显示<code>nohup: cannot run command /opt/openfire/jre/bin/java: No such file or directory</code>，看来openfire找不到java，所以不能成功启动，但是我们的系统的确已经安装了java，所以可以通过软链解决：</p>

<p>```
cd /opt/openfire/jre/bin
cp java java.bak
rm java
ln -s /usr/bin/java java
service openfire start</p>

<p>```</p>

<p>软链完成之后，再次开启openfire服务：</p>

<p>```
[root@iZ23572i0rtZ bin]# /etc/init.d/openfire status
openfire is not running
[root@iZ23572i0rtZ bin]# /etc/init.d/openfire start
Starting openfire:
[root@iZ23572i0rtZ bin]# /etc/init.d/openfire status
openfire is running</p>

<p>```
status显示openfire已经成功启动。通过虚拟机ip访问9090端口，这时会跳转到setup界面，只需要通过setup便可以完成相关配置。</p>

<p>配置完成之后即可以登录自己的管理控制台。</p>

<h3>4. Integrate to Android</h3>

<p>既然服务器安装完成，那我们可以着手我们的APP。与Openfire关联的客户端XMPP协议库是smack。摸索一番之后发现，要在Android中使用Smack必须使用ASmack库。<a href="http://asmack.freakempire.de/">ASmack下载地址</a>。<br/>
以实例为主，通过smack实现两个客户端之间的即时通信。<a href="https://github.com/gongmingqm10/SmackDemo">下载地址</a></p>

<h4>Attention</h4>

<ul>
<li>在AndroidManifest中必须添加Internet permission,否则连接失败。<code>&lt;uses-permission android:name="android.permission.INTERNET"/&gt;</code>.</li>
<li>客户端对客户端创建聊天时，SID为 username@XXXX, XXXX表示的是服务器名字，我这里是ECS主机名。</li>
</ul>


<h3>5. Github Repository</h3>

<p><a href="https://github.com/gongmingqm10/SmackDemo">https://github.com/gongmingqm10/SmackDemo</a></p>
]]></content>
  </entry>
  
</feed>
