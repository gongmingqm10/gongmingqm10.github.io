<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: android | gongmingqm10]]></title>
  <link href="http://www.gongmingqm10.net//blog/categories/android/atom.xml" rel="self"/>
  <link href="http://www.gongmingqm10.net//"/>
  <updated>2014-10-22T16:46:12+08:00</updated>
  <id>http://www.gongmingqm10.net//</id>
  <author>
    <name><![CDATA[Gong Ming]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Openfire - Android IM 框架使用]]></title>
    <link href="http://www.gongmingqm10.net//blog/2014/10/21/openfire-android-im-kuang-jia-shi-yong/"/>
    <updated>2014-10-21T10:02:58+08:00</updated>
    <id>http://www.gongmingqm10.net//blog/2014/10/21/openfire-android-im-kuang-jia-shi-yong</id>
    <content type="html"><![CDATA[<p>IM(Instant Messaging)在Android中可谓运用广泛。QQ，Wechat，陌陌等应用都可以看作IM实时通讯APP，实时通讯在社交类APP中运用范围较广，其功能看起来也是比较cool的。今天我们将研究一下android IM软件是如何实现的。像IM这种实施通讯软件，除非公司有比较大的实力和精力，才会自己去整这么一套框架。对于广大中小软件开发者来说，想到比较多的就是开源框架。Opensource对于开发者来说简直就是福音，对于整个软件行业也起到了不小的推动性的作用。<br/>
Openfire在这种环境下应运而生，而且作为实时通讯类开源框架迅速走红，下面我们就一起来学习这样一款拯救宇宙的开源框架，文章的最后会运用Openfire做出一个可以实时通讯的AndroidAPP，如果结合上地理位置再多点UI和交互上的设计提升，这不就是陌陌吗？YY了一会，觉得挺有趣，那么 <code>Just do it</code>。</p>

<p>Openfire概念性介绍请点击：<a href="http://blog.csdn.net/ithomer/article/details/7192257">http://blog.csdn.net/ithomer/article/details/7192257</a><br/>
Openfire官网：<a href="http://www.igniterealtime.org/">http://www.igniterealtime.org/</a><br/>
Openfire安装文档：<a href="http://www.igniterealtime.org/builds/openfire/docs/latest/documentation/install-guide.html">http://www.igniterealtime.org/builds/openfire/docs/latest/documentation/install-guide.html</a></p>

<h3>1. 选择服务器</h3>

<p>对于实时通讯软件，除了我们的客户端，服务器端更是关键。因为服务器是连接两个会话的桥梁。根据安装文档中，Openfire提供了多个平台的安装版本。Windows, Linux/Unix。所以支持还是很丰富的。至于服务器的选择我们可以选择自己的ECS，本地PC，或者Linux虚拟机。选择本机安装的请略过此步骤。<br/>
为了更加符合真实的安装环境，我选择本地的Linux虚拟机作为服务器环境。方便以后部署到真实的服务器环境中。  <br/>
在进行下一步之前请先在server上安装mysql和java。</p>

<h3>2. Install openfire</h3>

<p>从官网上下载对应的版本，我这里选择<a href="http://www.igniterealtime.org/downloads/index.jsp">Openfire_3.9.3 Linux版本</a>，登陆服务器后直接使用wget下载</p>

<p>```
wget <a href="http://www.igniterealtime.org/downloadServlet?filename=openfire/openfire-3.9.3-1.i386.rpm">http://www.igniterealtime.org/downloadServlet?filename=openfire/openfire-3.9.3-1.i386.rpm</a></p>

<p>//下载完成后使用rpm进行安装</p>

<p>rpm -ivh openfire-3.9.3-1.i386.rpm</p>

<p>```
Openfire安装完成后会在/opt目录下生成openfire/目录。
安装完成后就需要进行数据库的配置，按照官方文档：</p>

<p>```
Make sure that you are using MySQL 4.1.18 or later (5.x recommended) ¹.
Create a database for the Openfire tables:
mysqladmin create [databaseName]
(note: &ldquo;databaseName&rdquo; can be something like &lsquo;openfire&rsquo;)
Import the schema file from the resources/database directory of the installation folder:
Unix/Linux: cat openfire_mysql.sql | mysql [databaseName];
Windows: type openfire_mysql.sql | mysql [databaseName];
Start the Openfire setup tool, and use the appropriate JDBC connection settings.</p>

<p>```</p>

<p>首先使用<code>mysqladmin create openfire</code>创建名为openfire的数据库, <code>cd /opt/openfire/resources/database</code>进入openfire的数据库资源目录，使用<code>cat openfire_mysql.sql | mysql openfire</code>导入openfire的schema数据库文件。</p>

<h3>3. 启动Openfire服务</h3>

<p>使用rpm安装完成后的openfire会在/etc/init.d/中自动生成openfire 文件，可以直接在这里打开服务.</p>

<p>```
Usage /etc/init.d/openfire {start|stop|restart|status|condrestart|reload}</p>

<p>```</p>

<p>运行openfire服务：<code>/etc/init.d/openfire start</code>，运行<code>/etc/init.d/openfire status</code>显示没有成功运行。<br/>
查看log <code>cat /opt/openfire/logs</code>，显示<code>nohup: cannot run command /opt/openfire/jre/bin/java: No such file or directory</code>，看来openfire找不到java，所以不能成功启动，但是我们的系统的确已经安装了java，所以可以通过软链解决：</p>

<p>```
cd /opt/openfire/jre/bin
cp java java.bak
rm java
ln -s /usr/bin/java java
service openfire start</p>

<p>```</p>

<p>软链完成之后，再次开启openfire服务：</p>

<p>```
[root@iZ23572i0rtZ bin]# /etc/init.d/openfire status
openfire is not running
[root@iZ23572i0rtZ bin]# /etc/init.d/openfire start
Starting openfire:
[root@iZ23572i0rtZ bin]# /etc/init.d/openfire status
openfire is running</p>

<p>```
status显示openfire已经成功启动。通过虚拟机ip访问9090端口，这时会跳转到setup界面，只需要通过setup便可以完成相关配置。</p>

<p>配置完成之后即可以登录自己的管理控制台。</p>

<h3>4. Integrate to Android</h3>

<p>既然服务器安装完成，那我们可以着手我们的APP。与Openfire关联的客户端XMPP协议库是smack。摸索一番之后发现，要在Android中使用Smack必须使用ASmack库。<a href="http://asmack.freakempire.de/">ASmack下载地址</a>。<br/>
以实例为主，通过smack实现两个客户端之间的即时通信。<a href="https://github.com/gongmingqm10/SmackDemo">下载地址</a></p>

<h4>Attention</h4>

<ul>
<li>在AndroidManifest中必须添加Internet permission,否则连接失败。<code>&lt;uses-permission android:name="android.permission.INTERNET"/&gt;</code>.</li>
<li>客户端对客户端创建聊天时，SID为 username@XXXX, XXXX表示的是服务器名字，我这里是ECS主机名。</li>
</ul>


<h3>5. Github Repository</h3>

<p><a href="https://github.com/gongmingqm10/SmackDemo">https://github.com/gongmingqm10/SmackDemo</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android deploy your app]]></title>
    <link href="http://www.gongmingqm10.net//blog/2014/10/17/android-deploy-your-app/"/>
    <updated>2014-10-17T12:56:13+08:00</updated>
    <id>http://www.gongmingqm10.net//blog/2014/10/17/android-deploy-your-app</id>
    <content type="html"><![CDATA[<p>发布Android APP说通俗点就是“打包”，大部分情况下我们可以直接通过IDE进行签名打包，打包好的apk文件就可以上传到各大应用市场啦。今天项目开发过程中突然遇到需要更换debug.keystore的问题了，于是突然想好好研究一下Android打包的全过程，以及各个文件的作用。说做就做，how to publish your app?</p>

<h3>Proguard－代码混淆</h3>

<p>我们经常在js库中看到各种代码混淆，代码混淆主要是对你的代码的类名，方法名以及字段名进行命名，并删除一些无用的换行空格等。让你的代码变得难以读懂，这样能够防止别人反编译你的代码后窃取你的内容。<br/>
android中代码混淆主要使用IDE自动生成的文件，并通过一些简单的配置就可以实现。中间的混淆步骤则不需要我们关系，android编译过程中自身会处理这些内部的逻辑。我们只需要配置文件就可以。<br/>
通过官网提供的资料，<a href="http://developer.android.com/tools/help/proguard.html">http://developer.android.com/tools/help/proguard.html</a>，以及网上的大部分资料都是过时的，目前的AndroidStudio0.89中生成project时候只会生成proguard.cfg文件，要想启用proguard代码混淆，我们只需要在app的build.gradle中添加下述配置：</p>

<p>```
android {</p>

<pre><code>buildTypes {
    release {
        runProguard true
        proguardFile getDefaultProguardFile('proguard-android.txt')
    }
}
</code></pre>

<p>}</p>

<p>```</p>

<p>而这个proguard-android.txt则在<code>{sdk.dir}/tools/proguard/proguard-android.txt</code>中，这时proguard混淆时默认的文件，不过我们的sdk目录下却没有。Google君终于帮我们找到了：<a href="https://android.googlesource.com/platform/sdk/+/master/files/proguard-android.txt">https://android.googlesource.com/platform/sdk/+/master/files/proguard-android.txt</a>。于是简单粗暴的在tools/目录下新建proguard/proguard-android.txt文件。这时候android就可以使用默认文件进行混淆啦。</p>

<h3>Signing your application</h3>

<p>Android需要所有的应用在安装之前被数字签名，Android通过签名凭证识别应用的作者信息等。在App的Debug模式活着Release模式中都可以进行应用签名，在调试模式中一般是android自动生成凭证给App签名，而在Release发布模式中则需要开发者自己生成凭证来给用户签名。<br/>
我们主要关注在Release中怎么给自己的应用签名，签名之后的应用才可以发布到各市场中，在Release时给App签名：</p>

<ol>
<li>Create a keystore. Keystore是一个包含一些private key的二进制文件，你必须把这个文件放在一个安全独立的地方。</li>
<li>Create a private key. Private key 代表App作者的信息，例如一个开发者或者公司。</li>
<li>Build a project. 编译你的工程，这时会生成一个未签名的APP。</li>
<li>Sign your app. 用你的private key来生成你签名版本的APK。</li>
</ol>


<p>这样的APK就能够发布到市场中供用户更新下载。</p>

<p>签名既可以通过IDE直接操作，也可以通过android提供的工具在命令行中进行签名。在IDE中能够简单的生成一个keystore（需要说明的是不同的IDE生成的keystore文件格式是不一样的，主要有.jks, .keystore, 无后缀）。这些keystore在首次创建后下次就可以直接使用了。keystore包含的是一些软件作者的一些信息，也是你更新软件等的重要凭据。通过IDE签名的APK文件都经过了<code>jarsigner, zipalign</code>等操作，所以我们也不需要做额外的事情。<br/>
如果通过命令行来进行签名，这样的好处是使用命令来自动部署，开发者可以把所有的步骤写在一个shell文件中，部署时只要简单的run这个命令就可以实现了，如果需要编译很多个针对不同市场的版本，通过命令的模式就能够大大节约发布APP的时间。</p>

<p>更多详细信息请参考<a href="http://developer.android.com/tools/publishing/app-signing.html">http://developer.android.com/tools/publishing/app-signing.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android SIP 网络通话]]></title>
    <link href="http://www.gongmingqm10.net//blog/2014/10/17/android-sip-wang-luo-tong-hua/"/>
    <updated>2014-10-17T09:49:35+08:00</updated>
    <id>http://www.gongmingqm10.net//blog/2014/10/17/android-sip-wang-luo-tong-hua</id>
    <content type="html"><![CDATA[<p>突发奇想，想研究一下Android的网络通话怎么实现，于是从Google搜到了相关的资料。原来Android下集成了SIP（Session Initiation Protocol）。SIP的账号可以通过SIP提供商免费申请，申请后即可以通过用户名实现网络通话。于是也找了网上的一些资料，写了个AndroidSIP的小demo，demo实现后大家可以实现互拨，目前界面很简单，但是通话的功能应该是可以实现的。请各位看官试用之。<br/>
整体效果看起来还是蛮酷的，这里我们申请了两个免费的账号，在设备上安装之后就可以进行Network Call了。</p>

<p>免费SIP账号申请：<a href="http://www.linphone.org/free-sip-service.html">http://www.linphone.org/free-sip-service.html</a></p>

<p>官方参考文档：<a href="http://developer.android.com/guide/topics/connectivity/sip.html">http://developer.android.com/guide/topics/connectivity/sip.html</a></p>

<p>项目代码下载：<a href="https://github.com/gongmingqm10/AndroidSIP">https://github.com/gongmingqm10/AndroidSIP</a></p>

<p>任何问题，欢迎大家fork，发pull/request。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android quiz questions]]></title>
    <link href="http://www.gongmingqm10.net//blog/2014/10/13/android-quiz-questions/"/>
    <updated>2014-10-13T17:19:22+08:00</updated>
    <id>http://www.gongmingqm10.net//blog/2014/10/13/android-quiz-questions</id>
    <content type="html"><![CDATA[<p>关于Android的几个常见的问题，记录如下，小问题看到本质也可以了解很多原理性的东西。</p>

<hr />

<p><strong>Q: Android中Activity的生命周期？</strong></p>

<p>A: onCreate() &ndash;> onStart() &ndash;> onResume() &ndash;> onPause() &ndash;> onStop() &ndash;>onDestroy().</p>

<hr />

<p><strong>Q：Activity的onCreate()等函数必须Override吗？如果没有onCreate()，Activity能否运行？</strong></p>

<p>A: 答案显然是Override不是必须的，没有onCreate()的Activity还是可以运行的，那么究竟会运行成什么样子呢。<br/>
实例中试一试，从MainActivity中打开没有Override任何Method的Activity，发现界面上会出现一个白底界面的Activity，说明我们的Activity最终还是运行了的。只不过界面上没有任何元素，因为我们没有指定contentView。</p>

<hr />

<p><strong>Q: onStop()等在生命周期中是否一定会被调用?</strong></p>

<p>A: onStart(), onResume(), onPause(), onStop()都可以不被调用。因为一旦在onCreate()中我们直接手动调用finish()，相当于告诉Activity结束，于是系统会直接调用onDestroy()来销毁当前的Activity。</p>

<hr />

<p><strong>Q: onCreate()中的参数savedInstanceState意义是什么，会在什么情况下用到？</strong></p>

<p>A：按照官方的解释：</p>

<blockquote><pre><code> * @param savedInstanceState If the activity is being re-initialized after
 *     previously being shut down then this Bundle contains the data it most
 *     recently supplied in {@link #onSaveInstanceState}.  &lt;b&gt;&lt;i&gt;Note: Otherwise it is null.&lt;/i&gt;&lt;/b&gt;
 * 
</code></pre></blockquote>

<p>savedInstanceState表示当Activity在前一个关闭再度初始化的时候会保存的信息。举例来讲，在我们的APP运行时，如果系统内存不足，系统会把Activity栈中一些比较古老的Activity给终结掉，此时系统会调用<code>onSaveInstanceState()</code>方法，此方法默认保存此Intent的一些信息，当这个Activity再次被调用时，这些保存的信息会传递到onCreate的savedInstanceState中。我们如果需要自定义的保存某些很重要的信息，可以复写<code>onSaveInstanceState()</code>方法把某些重要信息放到bundle中，也可以把那些信息写到本地文件中或者数据库中进行保存。方便下次进入时能够获取到。</p>

<hr />

<p><strong>Q: Activity与Fragment的区别</strong></p>

<p>A: Activity相信大家都不陌生，其实可以简单的看着一个页面，跳转到另外一个页面一般就进入新的Activity。那么Android从API11开始使用Fragment的原因呢？其实主要是为了适配Android的多屏（特别是手机与平板）问题。一般情况下，如果按照普通的设计思路，我们会同时维护两份代码，并且UI上会有比较大的区别。对于快速升级的互联网产品而言，简直就是一个灾难。这时Google想了一个好的办法，在代码中引入Fragment，Fragment相当于一个module，我们所有的UI可以以模块的形式放到Fragment中。这时候的Fragment能够被多个Activity复用，我们的Activity此时做的事情就是组装这些Fragment。在平板中，我可以在ActivityA中放入FragmentA和FragmentB；在手机中，我则会在ActivityA中放入FragmentA，而在ActivityB中放入FragmentB。所以平板和手机的适配问题变成了简单的组装。从而我们的View不需要进行各种大的变动。这能够为开发者节省很多时间。<br/>
具体参考：<a href="http://developer.android.com/guide/components/fragments.html">Android Fragment Component</a></p>

<hr />

<p><strong>Q: UI线程你知道多少？</strong></p>

<p>A：UI线程就是我们常说的主线程，UI线程负责着与用户的交互操作，会处理用户的触摸滑动点击等事件，并把这些事件分发给相应的组件来处理。如果我们尝试在UI线程中进行一个耗时的操作，那么我们的APP会出现ANR（Application not responsing）异常。在UI线程中直接进行耗时操作就会造成主线程阻塞，阻塞到达一定时间则会产生ANR。<br/>
为了防止这种UI错误，我们进行的处理是将耗时操作放到另外一个线程中处理，耗时操作完成后，我们不能在非UI线程中进行UI的操作，这样是不安全的。因为我们可以借助Handler把更新的消息发给主线程，然后在主线程中更新UI操作。下面是几种耗时操作后更新UI线程的方法：</p>

<ul>
<li>View.post(Runnable runnable)</li>
<li>Activity.runOnUiThread(Runnable runnable)</li>
<li>AsyncTask</li>
<li>Hanlder + Thread</li>
</ul>


<p>事实上前面三种都是使用java封装好的其他线程中操作UI线程的方法，这些方法都是为了方便开发人员而进行的一些处理。具体用法，大家可以Google之。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android onTouch() 初探]]></title>
    <link href="http://www.gongmingqm10.net//blog/2014/09/30/android-ontouch-chu-tan/"/>
    <updated>2014-09-30T17:28:56+08:00</updated>
    <id>http://www.gongmingqm10.net//blog/2014/09/30/android-ontouch-chu-tan</id>
    <content type="html"><![CDATA[<p>Android的touch对于我来说是个既熟悉又陌生的话题，熟悉之处在于onTouch太常用了，从系统的自定义的ListView的滑动到我们自定义的可以滑动的View，onTouch直接与用户进行相关的Interation，所以onTouch无处不再。想像下如果Android某一天不能相应我们的touch事件，那我们现在的触屏手机基本废了，那我们的手机还得还原到以前的字母键手机的状态。学习总是得自己逼迫自己，没有博客的驱动我是怎样也不会来从头开始研究onTouch的作用机制的，博客当作一个自我学习的过程，坚持再坚持。</p>

<p>废话不说，步入正题，从用户开始，触屏事件被屏幕传感器截获，截获后会将该触摸数据传到我们的View上面，然后View再进行相应的处理。从用户触摸到数据被View感知都是有Android底层完成的，我们这里关心的只是Android的view会如何响应这些触摸行为呢？了解了触摸行为相关的原理才可以更好的利用这些特性从而实现我们自定义的各种交互生动的组件。</p>

<p>下面我们会循序渐进，逐步研究一些与Touch相关的特性，最后我们会通过几个小demo来展示怎么通过重写onTouch()自定义一些实用的组件。</p>

<h3>1. boolean onTouch() 返回值的意义</h3>

<p>直接贴出View.OnTouchListener的源码：</p>

<p>```</p>

<pre><code>public interface OnTouchListener {
    /**
     * Called when a touch event is dispatched to a view. This allows listeners to
     * get a chance to respond before the target view.
     *
     * @param v The view the touch event has been dispatched to.
     * @param event The MotionEvent object containing full information about
     *        the event.
     * @return True if the listener has consumed the event, false otherwise.
     */
    boolean onTouch(View v, MotionEvent event);
}
</code></pre>

<p><code>``
这是官方给出的定义，对于return返回值的意义，解释是</code>return True if the listener has consumed the event, false otherwise<code>，如果返回True，表示View消费了这次事件，否则的话，表示View并没有消费本次Touch事件。  
&lt;img src="http://www.gongmingqm10.net//images/touch-simple.png" alt="main_activity_layout.xml"/&gt;  
在XML中，我们声明了A，B，C 三个Layout，其中C包含B，而B包含A，对于ABC三个View，我们都为其指定相应的触摸事件，然后再观察触摸事件是如何被响应并传递的。  
MainActivty中定义如下：    
&lt;img src="http://www.gongmingqm10.net//images/touch-simple-main.png" alt="MainActivity.java"/&gt;    
在onTouch()方法中，我们</code>return false<code>，说明当前的View并没有消化触摸事件，它会将触摸事件继续</code>向上<code>传递，所谓</code>向上`指的是View会向它的父元素传递，父元素又会根据其定义的onTouch事件继续将事件传递。触摸A元素，产生的Log如下：</p>

<p><code>
10-01 16:20:44.640    1471-1471/org.gongming.uikit I/gongmingqm10﹕ --onTouch()--son
10-01 16:20:44.640    1471-1471/org.gongming.uikit I/gongmingqm10﹕ --onTouch()--parent
10-01 16:20:44.640    1471-1471/org.gongming.uikit I/gongmingqm10﹕ --onTouch()--grantParent
</code>
此时是<code>onTouch() return false</code> 的情况，触摸A的时候，首先触摸事件会有A处理，A处理完之后，<code>return false</code>导致触摸事件向A的父容器B传递，同时B又会继续向C传递，直至结束。<br/>
当我们把<code>onTouch()</code>返回结果改为<code>return true</code>时，再次触摸A，这时的Log如下：</p>

<p><code>
10-01 16:32:29.008    1612-1612/org.gongming.uikit I/gongmingqm10﹕ --onTouch()--son
10-01 16:32:29.016    1612-1612/org.gongming.uikit I/gongmingqm10﹕ --onTouch()--son
</code>
这时的<code>return true</code>表示A自己消化了触摸事件，所以触摸事件不会向上传播。通过<code>onTouch</code>中的MotionEvent可以得到当前触摸的x和y坐标，借此实现一些复杂的功能。<br/>
MotionEvent除了提供触摸的坐标外，还通过<code>MotionEvent.getEventAction()</code>判断当前触摸的类型，主要分为<code>ACTION_POINTER_DOWN</code> <code>ACTION_POINTER_UP</code> <code>ACTION_DOWN</code> <code>ACTION_MOVE</code> <code>ACTION_UP</code> <code>ACTION-CANCEL</code>，以下是MotionEvent中对这些Action的定义说明：</p>

<p>```</p>

<pre><code>/**
 * Constant for {@link #getActionMasked}: A pressed gesture has started, the
 * motion contains the initial starting location.
 * &lt;p&gt;
 * This is also a good time to check the button state to distinguish
 * secondary and tertiary button clicks and handle them appropriately.
 * Use {@link #getButtonState} to retrieve the button state.
 * &lt;/p&gt;
 */
public static final int ACTION_DOWN             = 0;

/**
 * Constant for {@link #getActionMasked}: A pressed gesture has finished, the
 * motion contains the final release location as well as any intermediate
 * points since the last down or move event.
 */
public static final int ACTION_UP               = 1;

/**
 * Constant for {@link #getActionMasked}: A change has happened during a
 * press gesture (between {@link #ACTION_DOWN} and {@link #ACTION_UP}).
 * The motion contains the most recent point, as well as any intermediate
 * points since the last down or move event.
 */
public static final int ACTION_MOVE             = 2;

/**
 * Constant for {@link #getActionMasked}: The current gesture has been aborted.
 * You will not receive any more points in it.  You should treat this as
 * an up event, but not perform any action that you normally would.
 */
public static final int ACTION_CANCEL           = 3;

/**
 * Constant for {@link #getActionMasked}: A movement has happened outside of the
 * normal bounds of the UI element.  This does not provide a full gesture,
 * but only the initial location of the movement/touch.
 */
public static final int ACTION_OUTSIDE          = 4;

/**
 * Constant for {@link #getActionMasked}: A non-primary pointer has gone down.
 * &lt;p&gt;
 * Use {@link #getActionIndex} to retrieve the index of the pointer that changed.
 * &lt;/p&gt;&lt;p&gt;
 * The index is encoded in the {@link #ACTION_POINTER_INDEX_MASK} bits of the
 * unmasked action returned by {@link #getAction}.
 * &lt;/p&gt;
 */
public static final int ACTION_POINTER_DOWN     = 5;

/**
 * Constant for {@link #getActionMasked}: A non-primary pointer has gone up.
 * &lt;p&gt;
 * Use {@link #getActionIndex} to retrieve the index of the pointer that changed.
 * &lt;/p&gt;&lt;p&gt;
 * The index is encoded in the {@link #ACTION_POINTER_INDEX_MASK} bits of the
 * unmasked action returned by {@link #getAction}.
 * &lt;/p&gt;
 */
public static final int ACTION_POINTER_UP       = 6;

/**
 * Constant for {@link #getActionMasked}: A change happened but the pointer
 * is not down (unlike {@link #ACTION_MOVE}).  The motion contains the most
 * recent point, as well as any intermediate points since the last
 * hover move event.
 * &lt;p&gt;
 * This action is always delivered to the window or view under the pointer.
 * &lt;/p&gt;&lt;p&gt;
 * This action is not a touch event so it is delivered to
 * {@link View#onGenericMotionEvent(MotionEvent)} rather than
 * {@link View#onTouchEvent(MotionEvent)}.
 * &lt;/p&gt;
 */
public static final int ACTION_HOVER_MOVE       = 7;

/**
 * Constant for {@link #getActionMasked}: The motion event contains relative
 * vertical and/or horizontal scroll offsets.  Use {@link #getAxisValue(int)}
 * to retrieve the information from {@link #AXIS_VSCROLL} and {@link #AXIS_HSCROLL}.
 * The pointer may or may not be down when this event is dispatched.
 * &lt;p&gt;
 * This action is always delivered to the window or view under the pointer, which
 * may not be the window or view currently touched.
 * &lt;/p&gt;&lt;p&gt;
 * This action is not a touch event so it is delivered to
 * {@link View#onGenericMotionEvent(MotionEvent)} rather than
 * {@link View#onTouchEvent(MotionEvent)}.
 * &lt;/p&gt;
 */
public static final int ACTION_SCROLL           = 8;
</code></pre>

<p>```
通过以下语句，可以可以判断当前触摸处于何种状态，进而进行相关的操作：</p>

<p>```
switch (event.getActionMasked()) {</p>

<pre><code>case MotionEvent.ACTION_DOWN:
    ...
    break;
case MotionEvent.ACTION_MOVE:
    ...
    break;
...
</code></pre>

<p>}</p>

<p>```</p>

<p>但是实际上事情到这里远没有终止，<code>onTouch</code>中我们可以通过<code>getAction</code>获取响应的触摸行为。但是当我们运行demo的时候发现，默认情况下只有ACTION_DOWN事件会响应，<code>ACTION_MOVE</code>竟然不响应，原来是onTouch()默认条件下<code>return false</code>，意味着View本身调用一次<code>ACTION_DOWN</code>函数后，就将触摸事件继续向其父类View继续传递，所以<code>ACTION_MOVE</code>不能响应。如果要获得响应，那我们需要告诉系统由<code>我</code>来处理触摸事件，<code>return true</code>就是View对外界释放的信号，此时事件就可以被View继续处理。</p>

<h3>2. boolean onInterceptTouchEvent(MotionEvent ev)</h3>

<p>除了onTouch外，开发中我们还可以经常遇到onInterceptTouchEvent，从字面意思来看是拦截触摸事件的作用，为了更权威，摘录官方解释如下：</p>

<p>```
For as long as you return false from this function, each following</p>

<pre><code> * event (up to and including the final up) will be delivered first here
 * and then to the target's onTouchEvent().
 *  If you return true from here, you will not receive any
 * following events: the target view will receive the same event but
 * with the action {@link MotionEvent#ACTION_CANCEL}, and all further
 * events will be delivered to your onTouchEvent() method and no longer
 * appear here.
</code></pre>

<p>```
查看源代码可以看到，这个方法被定义在ViewGroup中，我们可以猜到这个方法可能会和View的子View有关系。结合官方解释，如果onInterceptTouchEvent()返回为true，那么触摸事件不会被分发到子类中。</p>

<h3>3. View.dispatchTouchEvent()</h3>

<p>dispatchTouchEvent()是View类中的方法，用于将当前View接收到的触摸事件进行分发或者进行自身的相应处理。触摸事件从用户点击屏幕时就开始被封装为TouchEvent开始了自己的旅程：</p>

<ol>
<li><p>Activity.dispatchTouchEvent(), Activity通过系统本身的传感器接收到封装为MotionEvent的触摸事件，开始通过dispatchTouchEvent()把事件向下分发给Root ViewGroup。</p></li>
<li><p>ViewGroup.dispatchTouchEvent(), ViewGroup从Activity中拿到MotionEvent后，首先通过自己的dispatchTouchEvent再次向自己的子View分发。在dispatchTouchEvent函数中，ViewGroup会调用自己的onInterceptTouchEvent，如果intercept返回true，那么ViewGroup就停止对子View进行事件分发，一旦有些子View还有一些处理中的触摸事件，ViewGroup会发送ACTION_CANCEL事件给子View，然后ViewGroup判断自己是否有onTouchListener, 有的话就执行之，没有的话就会执行自身的onTouchEvent()。如果intercept返回false，ViewGrou将会根据触摸的位置和子View的位置判断是否将MotionEvent分发给子View.</p></li>
<li><p>在触摸点范围内的子View会根据继续进行类似2的处理。如果子View也有自己的children，则继续按照步骤2中的逻辑进行分发。这里假设子View没有children。如果自己的onTouchListener存在的话，则首先会执行listener中的onTouch()方法或者直接去执行自身的onTouchEvent()方法。 执行这些方法如果返回true，则表示View已经消耗了这个触摸事件，事件传递结束。如果onTouch()返回false，则冒泡向上传递MotionEvent，直到Activity.onTouchEvent()，是触摸事件的终点。</p></li>
</ol>


<h3>More. SimpleOnGestureListener</h3>

<p><code>onTouch是</code>View中所有触摸事件的入口，通过上面的了解我们可以看到MotionEvent中通过提供触摸的位置和触摸的类型方便我们进行各种判断，但是我们的真实需求往往比这复杂，我们有时需要自己处理双击事件，长按事件，滑动事件等等。如果这些由我们自己处理，那我们需要在onTouch()中进行一些逻辑判断，这无形中增加了我们的开发难度和代码量。好在Android通过GestureDetector提供了更好的支持。对于一些常规的事件，我们可以直接通过GestureDetector捕获，从而降低了我们的开发成本，开发人员可以把更多的时间放在业务上。通过<code>GestureDetector.SimpleOnGestureListener</code>的实现，我们能够复写一些基础的事件，从而完成我们的一些业务逻辑。 <br/>
<img src="http://www.gongmingqm10.net//images/touch-gesture-1.png" alt="SimpleOnGestureListener"/> <br/>
通过以上代码，我们主要可以看到在<code>View.setOnTouchListener</code>中将MotionEvent委托给GestureDetector来处理，而自身返回的true或者false将决定父容器能否响应触摸事件。</p>

<h3>Sample. SwipeLayout</h3>

<p>了解了touch事件的机制以及流程，我们能够更加灵活的自定义与手势操作结合起来的控件。在这个例子中，我们自定义SwipeLayout，实现竖直翻动效果。</p>

<p>代码源地址为：<a href="https://github.com/gongmingqm10/AndroidUikit/blob/master/library/src/main/java/org/gongming/common/SwipeLayout.java">SwipeLayout源码</a></p>

<h3>Reference</h3>

<ol>
<li><a href="http://stackoverflow.com/questions/9586032/android-difference-between-onintercepttouchevent-and-dispatchtouchevent">Android: Difference between onInterceptTouchEvent and dispatchTouchEvent?</a></li>
<li><a href="http://developer.android.com/training/gestures/viewgroup.html">Managing Touch Events in a ViewGroup</a></li>
<li><a href="http://www.youtube.com/watch?v=EZAoJU-nUyI">How Android Handles Touches</a></li>
</ol>

]]></content>
  </entry>
  
</feed>
