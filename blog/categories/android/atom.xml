<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | gongmingqm10]]></title>
  <link href="http://www.gongmingqm10.net/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://www.gongmingqm10.net/"/>
  <updated>2015-12-21T23:04:34+08:00</updated>
  <id>http://www.gongmingqm10.net/</id>
  <author>
    <name><![CDATA[Gong Ming]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android 新手成长计划]]></title>
    <link href="http://www.gongmingqm10.net/blog/2015/11/30/android-xin-shou-jiao-cheng/"/>
    <updated>2015-11-30T21:17:42+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2015/11/30/android-xin-shou-jiao-cheng</id>
    <content type="html"><![CDATA[<p><img src="http://www.webmastergrade.com/wp-content/uploads/2011/04/Android-VS-Apple.jpg" width="500" alt="Android starter" /></p>

<p>最近在公司里开始遇到了新人培养的问题，新人被 assign 到 Android 项目上，为了让他能够很快有所产出，于是我们得思考怎么样快速锻炼一个新人并让他对 Android 开发产生兴趣并持续做下去呢？当然也会有一时兴起的同事会想着学习 Android，Android 入门门槛不高，但是要想真正的熟练驾驭，确实是一件道阻且长的事情，需要付出额外的努力。</p>

<!-- more -->


<h2>兴趣驱动法则</h2>

<p>其实“兴趣”不只是在 Android 开发上体现的重要，兴趣在任何地方都是最重要的。之前接触过一些朋友，某次会突然告诉我想学习 Android，但是往往一个 Hello World 都可以将之难倒。这时候学习者明显缺少兴趣驱动。Android 开发好玩的一点是我们开发的应用都可以很简单的在手机上安装使用。所以你可以尽情尝试各种新奇的点子。</p>

<p>当然，兴趣并不是本文讨论的重点，我们假设真心想学习的人都是出于兴趣。</p>

<h2>循序渐进的练习计划</h2>

<p>有了兴趣远远还不够，兴趣只能促使你完成一个 Hello World，要想真正做出东西还应该有循序渐进的计划来配合。我当时学习 Android 的方法就是每周一个任务。把学习新知识当作升级打怪，这样子你还会松懈吗？</p>

<h3>你应该掌握的 Android 开发知识</h3>

<p>Android 开发的入门门槛不高，但是细节知识真心不少。作为初学者，我们可以先了解广度，然后了解深度。刚开始可以接触尝试了解一点远离性的知识，然后直接运用一些流行的框架。快速迭代完成一个 App。那么对于新手而言，应该掌握的 Android 开发知识有哪些呢？</p>

<h4>1. Hello Android</h4>

<p>开发调试基础看起来比较模糊，具体一点是完成一个 Hello World，让此应用运行在你的手机或者模拟器中。借此了解各个文件夹模块的作用以及 App 运行的基础原理。涵盖知识点如下：</p>

<ul>
<li>搭建 Android 开发环境： Java + Android Studio + SDK；</li>
<li>熟悉项目结构：src, res, assets, values, layouts, drawable/mipmap, styles, AndroidManifest.xml, Activity；</li>
<li>解读 Hello World 运行机制：项目从哪里运行，Activity 与 layout 的关联，Activity 中如何找到布局中的实例化控件，Activity 的生命周期；</li>
</ul>


<h4>2. 计算器</h4>

<p>计算器的经典程度不亚于 Hello World，Android 计算器能够让初学者迅速建立信心，同时作为一个单纯的无网络交互的应用，计算器主要处理布局，点击事件，计算逻辑。因此在了解了 Hello World 之后做计算器，再合适不过了。计算器最终效果图如下：</p>

<p><img src="http://7xj9js.com1.z0.glb.clouddn.com/calculator.png" width="300" alt="计算器" /></p>

<p>那么对于计算器这个 demo 的要求如下：</p>

<ul>
<li>界面效果如上图，并且能够进行简单的整数运算：<code>1+1, 4*2, 6/3, 1-10</code> 等；</li>
<li>异常处理，除数为 0 时界面提示 <code>Error</code>；</li>
<li>小数点以及连续运算的支持；</li>
<li>继承 Robolectric 添加单元测试；</li>
<li>每次打开 App 结果栏会自动显示上一次的运算结果；</li>
<li>添加<code>History</code>菜单，点击列表显示历史计算表达式以及结果；</li>
</ul>


<p>通过这些要求，涵盖的知识点如下：</p>

<ul>
<li>布局管理器的了解及使用：RelativeLayout, LinearLayout；</li>
<li>Android 控件添加点击事件，TextView 动态设值；</li>
<li>Android 项目集成 Robolectric，添加简单的单元测试；</li>
<li>Android 数据持久化保存 &ndash; SharedPreferences；</li>
<li>Android 数据持久化存储 &ndash; Sqlite 数据库；</li>
<li>Android ListView 列表及数据绑定；</li>
<li>Android Activity 跳转 &ndash; Intent；</li>
<li>添加 <a href="http://jakewharton.github.io/butterknife/">ButterKnife</a> 框架，重构项目；</li>
<li>添加 <a href="http://greenrobot.org/greendao/">GreenDao</a> 框架，重构数据库数据存储及读取；</li>
</ul>


<h4>3. 豆瓣图书列表 &ndash; 图片缓存</h4>

<p>豆瓣图书列表最初起源于公司内部的一次 Android 培训，由于对 Android 初学者而言，还比较有意义，于是设置为专题的形式供大家练习。需求很简单，将给定的图书列表数据(JSON 格式)显示到界面上。包括图书信息在列表中展示，网络图片的加载以及缓存。JSON 数据<a href="http://7xj9js.com1.z0.glb.clouddn.com/douban-books.json">点击此处</a>查看。完成之后效果图如下：</p>

<p><img src="http://7xj9js.com1.z0.glb.clouddn.com/douban-reading.png" width="300" alt="Douban Books" /></p>

<p>具体要求如下：</p>

<ul>
<li>列表显示图书信息：图书图片，名称，作者／出版社／出版年份，评价，简介；</li>
<li>多次滑动列表，保证文字以及图片显示不会发生错位，并且始终流畅（有列表控件重用）；</li>
<li>添加图片缓存：图片加载成功后，断开网络，退出 App，打开应用仍然能够正确显示图片；</li>
</ul>


<p>通过这些要求我们期望初学者掌握的技能点如下：</p>

<ul>
<li>Android ListView 自定义列表样式；</li>
<li>Android Adapter 使用 ViewHolder 进行控件复用；</li>
<li>Android 主线程（UI线程）的概念，主线程阻塞的解决方案，Handler 的概念以及使用方法；</li>
<li>图片缓存的应用，内存级别的缓存以及磁盘级别的缓存；</li>
<li>使用 <a href="http://square.github.io/picasso/">Picasso</a>/<a href="https://github.com/nostra13/Android-Universal-Image-Loader">ImageLoader</a> 图片加载及缓存框架，简化开发；</li>
</ul>


<p>如果你对图片缓存部分的实现有任何疑惑，请参考工程 <a href="https://github.com/gongmingqm10/AndroidWorkshop/tree/2nd-step4">AndroidWorkShop</a>。图片磁盘缓存部分参考了 Android 官方教程。</p>

<h4>4. 豆瓣图书列表 &ndash; 网络请求</h4>

<p>这个任务其实是对第 3 条任务的改造。不同之处在于，本次任务侧重于让初学者了解如何快速构建出一个有网络请求模块的 App。我们的效果图和上一条任务的相同，不同点在于本次我们会使用真实的网络API数据。并且会对 API 请求回来的数据进行缓存。具体要求如下：</p>

<ul>
<li>推荐使用 <a href="http://square.github.io/retrofit/">Retrofit</a> 框架，从豆瓣读书 API 网络获取<a href="https://api.douban.com/v2/book/search?q=Java">图书列表</a>及<a href="http://api.douban.com/v2/book/2130190">图书详情</a>。详情参见<a href="http://developers.douban.com/wiki/?title=guide">豆瓣API</a>；</li>
<li>列表显示豆瓣图书列表，图片显示可直接使用 Picasso；</li>
<li>点击 Item 跳转至图书详情界面，显示该书籍详细信息；</li>
<li>缓存此 API 的搜索结果 (文件或者数据库Key-Value的形式缓存JSON数据)；</li>
<li>使用 SwipeRefreshLayout 添加下拉刷新功能，下拉刷新时重新添加请求数据并更新缓存；</li>
</ul>


<p>此任务我们期望初学者掌握的知识点：</p>

<ul>
<li>Retrofit 框架的使用；</li>
<li>Android 数据缓存的简易实现方案（数据库／文件形式）；</li>
<li>简单的列表点击事件，页面跳转等；</li>
<li><a href="http://android-developers.blogspot.com/2015/05/android-design-support-library.html">Android Design Support Library</a> 中常用的组件及使用；</li>
</ul>


<h4>5. 设计并实现你自己的 App</h4>

<p>如果你顺利完成了上述四条任务，那么这一步你应该已经具备了完成一个简单的 App 的技能，这一步可以按照个人兴趣完成自己的创意点子。在开始编码之前，可以先制作出一套 UI 交互图，然后整理 API 并开始编码。</p>

<h3>Android 学习常用的链接</h3>

<p>Android 拥有全面的官方学习教程以及各种丰富的开源库。我们初学时可以多浏览官方教程学习一些好的实现，下面列举了一些很常用的链接：</p>

<ol>
<li><a href="developer.android.com/training/index.html">Android 官方文档</a></li>
<li><a href="http://android-developers.blogspot.com/">Android 官方博客</a></li>
<li><a href="www.google.com/design/spec/style/color.html#">Google Material Design</a></li>
<li><a href="http://square.github.io/">Square Open Source</a></li>
<li><a href="http://jakewharton.com/">Jake Wharton 的博客</a></li>
</ol>


<p>全文很多观点都是一家之言，更多的是结合自己的项目经验以及学习经验总结而成，如有谬误及不当之处，请读者不吝赐教。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Adapter notifyDataSetChanged Not Working]]></title>
    <link href="http://www.gongmingqm10.net/blog/2015/11/29/android-adapter-notifydatasetchanged-not-working/"/>
    <updated>2015-11-29T11:30:39+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2015/11/29/android-adapter-notifydatasetchanged-not-working</id>
    <content type="html"><![CDATA[<p>刚开发 Android 开发时，总是遇到一个看似很简单的问题 “Android Adapter notifyDataSetChanegd 不生效”，而每次解决这个问题的方法总是简单粗暴，直接了当。大概是以前的时候做事以结果导向，所以对于这些奇怪的问题也总是没有深究。刚好最近在项目中再次遇到了这个问题，决心深究一下。</p>

<p><img src="http://7xj9js.com1.z0.glb.clouddn.com/Its_not_working_anymore.png" width="500" alt="notifyDataSetChanged not working" /></p>

<!-- more -->


<h3>Adapter notifyDataSetChanged 做了什么事</h3>

<p>要弄清楚 <code>adapter.notifyDataSetChanged</code> 为什么不工作，还是应该首先弄清楚它究竟做了什么事情。根据函数名的描述，主要是通知 “数据源改变”，从而刷新页面，这样新改变的数据就呈现在用户面前了。</p>

<p>Android Adapter 使用了观察者模式，每一个 ListView 可以实例化出一个 Observer，而每个 Adapter 则会实例化出一个 Subject。在 ListView setAdapter 的时候，Adapter 会将 ListView 中实例化的 Observer 注册入观察者列表中。当 Adapter 通过观察者更新时，则会调用 Observer 的 notifyChanged() 方法，如此重新刷新 ListView 的界面。</p>

<p>这个通知者模式的 UML 关系图大致可以描述如下：</p>

<p><img src="http://7xj9js.com1.z0.glb.clouddn.com/adapter%20obervable%20pattern.png" width="500" alt="notifyDataSetChanged not working" /></p>

<p>继续查看 ListView.setAdapter 方法，可以看到在设置 Adapter 的时候，ListView 会将自己的 Observer 注册入 Subject:</p>

<p>```</p>

<pre><code>@Override
public void setAdapter(ListAdapter adapter) {
    if (mAdapter != null &amp;&amp; mDataSetObserver != null) {
        mAdapter.unregisterDataSetObserver(mDataSetObserver);
    }

    ...

    super.setAdapter(adapter);

    if (mAdapter != null) {
        ...
        mDataSetObserver = new AdapterDataSetObserver();
        mAdapter.registerDataSetObserver(mDataSetObserver);

        ...
        }
    }

    ...
}
</code></pre>

<p>```</p>

<h3>为什么 notifyDataSetChanged 生效</h3>

<p>既然 <code>notifyDataSetChanged</code> 能够促使 ListView 重绘界面，那么让其生效的方式就是保证 Adapter 中的数据源生效，这样在 ListView 重绘时才能使用新的数据刷新界面。看下面一段失效的 ListView 更新失效的问题。</p>

<p>```</p>

<pre><code>    ListView itemList = (ListView) findViewById(android.R.id.list);
    data = new ArrayList&lt;&gt;();
    data.addAll(Arrays.asList("Item 1", "Item 2", "Item 3"));
    adapter = new ItemListAdapter(data);
    itemList.setAdapter(adapter);

    findViewById(R.id.fab).setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            // 模拟请求 API 刷新重新获得数据
            data = new ArrayList&lt;&gt;();
            data.addAll(Arrays.asList("Item 1", "Item 2", "Item 3", "Item 4"));
            adapter.notifyDataSetChanged();
        }
    });
</code></pre>

<p>```</p>

<p>让我们分析失效的原因，首先将 ArrayList data 设置为 Adapter 的数据源，而 Java 是引用传值，所以在 onClick() 回调函数中，当我们对 data 重新赋值时，重新赋值后的 data 并不能和 Adapter 中的数据源产生关联。因此 Adapter 中的数据源还是 “Item 1”, “Item 2”, &ldquo;Item 3"。所以这里无论怎样调用 notifyDataSetChanged 都是不能生效的。</p>

<h3>如何让 notifyDataSetChanged 生效</h3>

<p>让更新生效的方式是，让你的 Adapter 保持最新数据源。就上述例子来看，当 data 更新新值时，我们可以通过 List.add() 来更新 Adapter 中引用对应的值。实现代码如下：</p>

<p>```</p>

<pre><code>    ListView itemList = (ListView) findViewById(android.R.id.list);
    data = new ArrayList&lt;&gt;();
    data.addAll(Arrays.asList("Item 1", "Item 2", "Item 3"));
    adapter = new ItemListAdapter(data);
    itemList.setAdapter(adapter);

    findViewById(R.id.fab).setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            data.add("New Item " + view.toString());
            adapter.notifyDataSetChanged();
        }
    });
</code></pre>

<p>```</p>

<h3>End</h3>

<p>Android 中有很多优秀的设计，当我们出现问题时，可以通过阅读源码的方式探索，并结合 Google 的相关资料，了解事物的根源，方能设计出更优秀的代码。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android 应用的持续交付]]></title>
    <link href="http://www.gongmingqm10.net/blog/2015/06/29/android-testing-practice/"/>
    <updated>2015-06-29T11:40:16+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2015/06/29/android-testing-practice</id>
    <content type="html"><![CDATA[<p>当我们谈软件质量时，我们一般会谈到测试。测试作为保障软件质量的重要手段正在被开发者逐渐认知。谈到测试时，大部分人都知道Web测试，对于前端JS或者后台，大部分“靠谱”的创业公司也都会用测试来保证软件质量。可是对于起步相对较晚的移动端测试，用的人并不多。</p>

<p>在测试方面，Android早期即存在UIAtomator和Monkey之类的测试，但是用起来实在不方便。2013年，Google开源了针对An ndroid平台的移动测试框架 &ndash; Espresso。Espresso可以针对每个页面(Activity)进行测试。开发者可以根据ID获取到页面元素，然后进行点击、长按等操作。结合Junit和Mock等工具，使得移动端测试成为可能。移动端拥有了测试框架的辅助，借助CI平台，持续交付也成为可能。</p>

<!-- more -->


<h2>Android测试的类别</h2>

<p>从开发者角度来看，通常的Web平台测试可以分为单元测试、集成测试以及功能测试。移动应用主要用来显示数据，显示框输入数据，相应用户的点击、滑动等操作。所以Android应用的开发工作大部分集中在UI上。因此，App测试大致可分为UI单元测试和功能测试。</p>

<p>UI单元测试覆盖界面显示以及用户与界面的交互。功能测试则是确保功能的正确性。</p>

<p>为了更好的说明App中UI测试和功能测试如何进行的，以一个Story举例如下：</p>

<p>```
Story-101
Summary: 登录模块，用户能够使用用户名和密码登录App。
Acceptance criterions:</p>

<p>Given 作为用户，我打开App进入首页；
When 我点击“登录”按钮；
Then 我跳转到登录页面；</p>

<p>Given 作为用户，我在登录页面
When 我只输入用户名
Then 登录按钮处于Disable状态
When 我输入密码
Then 登录按钮可以点击，点击之后，调用API</p>

<p>Given 作为用户，我在登录页面
When 我输入正确的用户名和密码，并登录
Then 页面跳转到首页</p>

<p>Given 作为用户，我在登录页面
When 我输入错误的用户名和密码，并登录
Then 页面上方显示“用户名或密码错误”提示
And 密码被清空，登录按钮重新Disable</p>

<p>```</p>

<h3>UI单元测试</h3>

<p>UI(User interaction)测试又指界面测试。界面是软件与用户交互的最直接的部分，通过UI测试核实用户和软件拥有正常的交互。</p>

<p>UI测试的功能点比较简单：比如点击按钮的行为，按钮是否应该被禁用，页面文字、颜色等信息，是否弹框，点击弹框按钮应该跳转到什么页面等。</p>

<p>在登录页面中，假设登录页面的名字为LoginActivity，这是需要写的UI测试如下：</p>

<p>1.Test login button is not available until username and password are filled</p>

<p>```
usernameEditText.setText(&ldquo;gongmingqm10&rdquo;)
assertThat(loginButton.isDisabled()).isTrue()</p>

<p>passwordEditText.setText(&ldquo;password&rdquo;)
assertThat(loginButton.isDisabled()).isFalse()
```</p>

<p>2.Test should invoke Api when login button is clicked</p>

<p>```
usernameEditText.setText(&ldquo;gongmingqm10&rdquo;)
passwordEditText.setText(&ldquo;password&rdquo;)</p>

<p>loginButton.performClick()</p>

<p>verify(loginApi).login(eq(&ldquo;gongmingqm10&rdquo;), eq(&ldquo;encryptedpassword&rdquo;)</p>

<p>```</p>

<p>3.Test should show error dialog when login failed</p>

<p>```
usernameEditText.setText(&ldquo;gongmingqm10&rdquo;)
passwordEditText.setText(&ldquo;wrongpassword&rdquo;)
activity.loginFailed()
assertThat(passwordEditText.getText().toString()).isEqualTo(&ldquo;&rdquo;)
assertThat(errorText).isVisibile()
assertThat(errorText.getText().toString()).isEuqalTo(&ldquo;用户名或密码错误&rdquo;)</p>

<p>```</p>

<p>4.Test should navigate to home page when login succeed</p>

<p><code>
usernameEditText.setText("gongmingqm10")
passwordEditText.setText("correctpassword")
activity.loginSuccess()
String actualPageName = getNextStartedActivity().getComponentName()
assertThat(actualPageName).isEqualTo(HomeActivity.class.getName())
</code></p>

<p>观察上述几个测试，我们可以看到对UI的测试粒度相对较小。主要测试用户输入，按钮点击，服务器返回结果之后，界面应该如何反应。UI测试通常也包括简单的单元测试，Android中需要进行单元测试的内容较少，所以对于一些工具类的单元测试通常和UI测试放在同一个模块中。(PS: 上述测试代码的写法和你选取的测试框架有关)</p>

<h3>功能测试</h3>

<p>功能测试主要把测试对象看作一个黑盒子，测试者并不关注具体的功能实现逻辑，只需要关注输入产生期望的输出即可。Android的功能测试和Web的功能测试类似。在真机或模拟器中运行App，模拟输入、点击等操作，识别界面上是否存在某些期望的文字或行为。</p>

<p>功能测试不需要关注细节，只需要关注功能，对登录Story的功能测试如下：</p>

<p>1.With valid username and password, user can successfully login and navigate to home screen</p>

<p><code>
tap_when_element_exists "android.widget.EditText hint:'Username'"
keyboard_enter_text 'gongmingqm10'
tap_when_element_exists "android.widget.EditText hint:'Password'"
keyboard_enter_text 'some_correct_password'
@home_page.wait_for_page_to_load
welcome_message = @home_page.get_welcome_message
raise 'Navigate to home page failed' if welcome_message.empty?
</code></p>

<p>2.With wrong username and password, user will see an error text</p>

<p><code>
tap_when_element_exists "android.widget.EditText hint:'Username'"
keyboard_enter_text 'gongmingqm10'
tap_when_element_exists "android.widget.EditText hint:'Password'"
keyboard_enter_text 'wrong_password'
query "android.widget.TextView id: 'error_box' text:'用户名或者密码错误'"
</code></p>

<h2>Android常用测试框架</h2>

<h3>针对UI测试</h3>

<p>一般项目上都会采用<a href="http://robolectric.org/">Robolectric</a>框架，Robolectric运行过程中不需要启动模拟器，因此执行过程很快。</p>

<p>除了Robolectric，Google官方推荐使用Espresso来做UI测试。Espresso既可以作UI测试，也可以做简单的功能测试。</p>

<h3>针对功能测试</h3>

<p>可以做功能测试的框架也很多，包括Robotium, uiautomator, Espresso, Appium 和 Calabash。对比其主要区别如下：</p>

<p>真实项目过程中功能测试框架使用较多的是Appium和Calabash。这两个框架的优点是能够同时支持Android和iOS，并且不需要注入到工程中(即只需要编译后生成的安装包)，配合响应的测试脚本即可完成测试。</p>

<h2>Android持续交付</h2>

<p>CD(Continuous Dilivery)强调能够随时给客户交付有价值的产品。在Web开发上，我们通常运用CI平台持续部署网站到各个环境中。从而实现整个产品的持续交付。在Android平台上也是类似，唯一不同点是Android每发布一个版本需要用户手动更新手机上的App。</p>

<p><strong>1. 集成你的测试框架</strong></p>

<p>假定我们已经选定其他的技术栈，这时只需要集成UI测试和功能测试即可。UI单元测试框架我们选择Robolectric，而功能测试框架选择Calabash。参考<a href="http://robolectric.org/">Robolectric</a>和<a href="https://github.com/calabash/calabash-android">Calabash for Android</a>官方文档，集成测试框架并编写第一个Dummy Test。</p>

<p><strong>2. 通过你的第一个Dummy Test</strong></p>

<p>CI(Continuous Integration)平台，选择Jenkins。因为Jenkins有各种丰富的插件支持。选择Jenkins平台之后，最后能够有一台带界面的Mac Mini(虽然Android可以配置无界面运行，但是配置相对麻烦并且运行太慢)。在Mac Mini上搭建CI环境，配置Android运行环境。此步的目的是你的Dummy Test能够在Jenkins上运行</p>

<p><strong>3. 自动上传你的应用</strong></p>

<p>我们希望每次Push之后生成的包能够被QA测试，Showcase时候能够被客户测试。所以我们需要持续的发布新生成的包。我接触到的通常有两种做法：</p>

<ul>
<li>使用Dropbox自动同步上传：这种方法是最省成本的。每次打包新版本的时候只需要给文件带上不同的版本号，方便辨识。包生成之后，只需要存放到本地的Dropbox共享文件夹中。Dropbox会为我们自动上传。手机端则可以直接访问Dropbox下载，安装。</li>
<li>使用<a href="http://hockeyapp.net/features/">HockeyApp</a>管理版本：HockeyApp需要收费，但是可以很方便的通过部署脚本自动上传新生成的包。手机端只需要安装HockeyApp客户端，即可选择更新。</li>
</ul>


<p>类似的工具还有很多，选择适合自己的才是最好的。</p>

<h2>结语</h2>

<p>移动端测试虽然发展时间不长，但是却不断在完善中。我们以前习惯用邮件或U盘发布新版供他人测试。我们以前习惯开发App时不写测试。那些时代应该过去了。运用Robolectric，我们可以很轻松的测试驱动开发Android App；运用Calabash或Appium，我们可以更好的控制App质量，保证App功能；运用Jenkins等CI平台，我们的App可以持续交付啦!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Material Design Your Android App]]></title>
    <link href="http://www.gongmingqm10.net/blog/2015/06/25/material-design-your-android-app/"/>
    <updated>2015-06-25T15:22:27+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2015/06/25/material-design-your-android-app</id>
    <content type="html"><![CDATA[<p>14年6月26日的Google I/O大会上，Google推出了一门全新的设计语言Material Design。Material Design在随后的一年里被逐渐应用到Android, Web等平台中。Material Design的推出意味着Google对移动端和网页端设计的整合。固然没有引起轩然大波，但是Material Design却让Android开发者看到了一点福音。</p>

<p>虽然Android系统广受诟病，越来越多的用户投奔苹果的iOS系统。然而这阻挡不了Android的不断改进。14年Google I/O, Google推出了Android的5.0版本，代号Lollipop。5.0版本在设计上采用全新的Material Design，虽然这次升级对ROM生产商来说是道“过不去的坎儿”，但是对开发者群体而言却是一次很不错的升级。因为开发者可以凭借有些的设计资源打造出更好看的App。</p>

<!-- more -->


<h2>关于Material Design</h2>

<blockquote><p>Material design is a comprehensive guide for visual, motion, and interaction design across platforms and devices.</p></blockquote>

<p>这是Google官方给的解释， Material Design 中文直译为 “物质的设计”。可以简单理解为画面中的所有元素都可以看作是真实的物质，物质存在于空间中，并且存在光、影、运动等特征。所以Material Design的众多原则都是基于Material这个概念而提出的。</p>

<h3>Material Design基本原则</h3>

<p>Material Design作为设计与交互的一部分，由设计师来阐述更为专业。以下只是抛砖引玉的介绍，也许身边的设计师朋友会更专业的见解。</p>

<h4>Material is the metaphor</h4>

<blockquote><p>A material metaphor is the unifying theory of a rationalized space and a system of motion</p></blockquote>

<p>举例来说，在Android Lollipop系统中，当用户点击操作时，界面会反馈出水纹般的涟漪向周边散去，作为对用户点击操作的直接反馈。Material的设计都是基于现实，并在现实世界的基础上予以创新的。创新之处表现在元素之间整理运动的和谐。即使是在现实世界进行创新，最重要的是要Material Design不会破坏物理世界的规则。</p>

<h4>Bold, graphic, intentional</h4>

<blockquote><p>The foundational elements of print-based design—typography, grids, space, scale, color, and use of imagery—guide visual treatments.</p></blockquote>

<p>设计中的基本元素网格，空间，比例，字体，颜色等的结合能够给用户带来更好的体验，从而产生更大的价值。Material Design给我们指定了一些常见的搭配组合，比如颜色的组合、App中不同部分字体大小，组件之间的边距等。</p>

<h4>Motion provides meaning</h4>

<blockquote><p>Motion respects and reinforces the user as the prime mover. Primary user actions are inflection points that initiate motion, transforming the whole design.</p></blockquote>

<p>动画通常是App中最常见的交互，在Material Design出来之前，大部分App是很少有动画的。因为动画从设计到最后被用户使用，需要动画的设计以及开发，有时还会受限于平台。Material Design在动画方面有所加强，官方推出了许多默认的动作，页面各个元素之间的相互运动等。期望通过元素的运动向用户传达更为核心的价值和功能。</p>

<h3>为什么我们需要Material Design</h3>

<p>设计主要是为了提升用户体验，辅助产品功能，起到锦上添花的效果。Google推出Material Design也许希望对所有的Google产品进行设计上的统一化。</p>

<p>从Android平台来看，以前的Google Apps很难说有什么风格，其他厂商开发的App也是风格各异。Google希望通过Lollipop对App统一风格，所以在5.0＋平台上的Gmail, Youtube, Calender等都进行了风格的统一化，借此引导更多的设计师和开发者开发出更“接地气”的App。</p>

<p>Material Design强调跨平台设计，如果你遵从Material Design，你会发现将无论是宽屏平板设备、还是手机，你会发现你的应用可以很智能的进行展示。这将极大减轻适配平板带来的工作量。是不是有点类似于Web上的响应式设计呢？</p>

<p>当然选择是自由的，如果你觉得你的App不需要Material Design，那么TA真的不需要。</p>

<h2>如何Material Design App</h2>

<p>据个人观察，目前国内市场上大部分的App没有Material Design的概念。原因不得而知。但是遵循Material Design的应用在国外却比较常见。比如我个人常用的雅虎天气。</p>

<p>那么如何空手开发Material Design 应用呢？假定读到这里的你是个开发人员：</p>

<h3>1.合适的SDK版本和相关兼容包</h3>

<p>build.gradle</p>

<p>```
apply plugin: &lsquo;com.android.application&rsquo;</p>

<p>android {</p>

<pre><code>compileSdkVersion 22
buildToolsVersion "22.0.1"

defaultConfig {
    applicationId "net.gongmingqm10.training"
    minSdkVersion 16
    targetSdkVersion 22
    versionCode 1
    versionName "1.0"
}
...
</code></pre>

<p>}</p>

<p>dependencies {</p>

<pre><code>compile fileTree(dir: 'libs', include: ['*.jar'])
//required
compile 'com.android.support:appcompat-v7:22.2.0'
//optional for RecyclerView
compile 'com.android.support:recyclerview-v7:22.2.0'
//optional for GridLayout
compile 'com.android.support:gridlayout-v7:22.2.0'
//optional for CardView
compile 'com.android.support:cardview-v7:22.2.0'
//optional for some useful libraries
compile 'com.android.support:design:22.2.0'
</code></pre>

<p>}</p>

<p>```</p>

<h3>2.使用 Material theme</h3>

<p>values-v21/styles.xml</p>

<p>```
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;utf-8&rdquo;?>
<resources></p>

<pre><code>&lt;style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar"&gt;
    &lt;!-- Main theme colors --&gt;
    &lt;!--   your app branding color for the app bar --&gt;
    &lt;item name="colorPrimary"&gt;@color/color_primary&lt;/item&gt;
    &lt;!--   darker variant for the status bar and contextual app bars --&gt;
    &lt;item name="colorPrimaryDark"&gt;@color/color_primary_dark&lt;/item&gt;
    &lt;!--   theme UI controls like checkboxes and text fields --&gt;
    &lt;item name="colorAccent"&gt;@color/color_accent&lt;/item&gt;

&lt;/style&gt;
</code></pre>

<p></resources></p>

<p>```</p>

<p>values/styles.xml</p>

<p>```
<resources></p>

<pre><code>&lt;!-- Base application theme. --&gt;
&lt;style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar"&gt;
    &lt;!-- Customize your theme here. --&gt;
    &lt;item name="android:actionBarStyle"&gt;@style/MyActionBar&lt;/item&gt;
    &lt;!-- Support library compatibility --&gt;

    &lt;item name="actionBarStyle"&gt;@style/MyActionBar&lt;/item&gt;
&lt;/style&gt;

&lt;style name="AppTheme.NoActionBar"&gt;
    &lt;item name="windowActionBar"&gt;false&lt;/item&gt;
    &lt;item name="windowNoTitle"&gt;true&lt;/item&gt;
&lt;/style&gt;

&lt;!-- ActionBar styles --&gt;
&lt;style name="MyActionBar"
    parent="@style/Widget.AppCompat.Light.ActionBar.Solid.Inverse"&gt;
    &lt;item name="android:background"&gt;@color/color_primary&lt;/item&gt;
    &lt;item name="android:titleTextStyle"&gt;@style/MyActionBarTitleText&lt;/item&gt;

    &lt;!-- Support library compatibility --&gt;
    &lt;item name="background"&gt;@color/color_primary&lt;/item&gt;
    &lt;item name="titleTextStyle"&gt;@style/MyActionBarTitleText&lt;/item&gt;
&lt;/style&gt;

&lt;style name="MyActionBarTitleText" parent="TextAppearance.AppCompat.Widget.ActionBar.Title"&gt;
    &lt;item name="android:textColor"&gt;@color/white&lt;/item&gt;
&lt;/style&gt;
</code></pre>

<p></resources></p>

<p>```</p>

<p>使用你定义的AppTheme</p>

<p>```</p>

<pre><code>&lt;application
    android:name=".TrainingApp"
    android:allowBackup="true"
    android:icon="@mipmap/ic_launcher"
    android:label="@string/app_name"
    android:theme="@style/AppTheme" &gt;
    ...
&lt;/application&gt;
</code></pre>

<p>```</p>

<h3>3.使用专为Material Design打造的Android控件</h3>

<p>你可以参考<a href="http://developer.android.com/training/material/index.html">Google Training Material Design</a>获取更多的Material Design组件的使用方法。</p>

<h4>Lists and Cards</h4>

<h5>RecyclerView</h5>

<p>引入RecyclerView到工程中：</p>

<p><code>
compile 'com.android.support:recyclerview-v7:22.2.0'
</code>
RecyclerView控件是ListView的更高效更灵活的版本。可以看作是对ListView更好的封装：</p>

<ul>
<li>解决ListView多列显示的难题；</li>
<li>不用担心开发人员没有复用View，因为它会强迫你这样做；</li>
<li>更方便的动画支持，移除中间某一项时，可以设置后面几项动画移动;</li>
</ul>


<h5>CardView</h5>

<p><code>
compile 'com.android.support:cardview-v7:22.2.0'
</code>
卡片式布局，你的界面就是有导航和卡片组成的。卡片能够设置圆角和阴影。</p>

<h4>Design support library</h4>

<p>使用Design support包含的空间，需要引入Design support库：</p>

<p><code>
compile 'com.android.support:design:22.2.0'
</code></p>

<p>Design support提供了一些很常见很实用的控件。</p>

<h5>Navigation View</h5>

<p>Material Design推荐使用DrawerLayout抽屉式布局显示导航，所以Android一直没有为底部导航推出相应的控件。按照Google最新的设计，所有的导航都会被设置为抽屉显示，点击左上角菜单可以抽屉式弹出菜单项。</p>

<p>NavigationView就是和DrawerLayout搭配使用的神器。使用NavigationView只需要提供icon和title就可以生成专业的侧边导航。</p>

<h5>Floating Action Button</h5>

<p>Material Design引入了z轴，这个控件可以轻松制作出有阴影的悬浮圆形按钮。</p>

<h5>Snackbar</h5>

<p>底部栏消息提示控件，显示显示不再只有Toast和AlertDialog，还有Snackbar。</p>

<h5>Tabs</h5>

<p>在TabLayout出来之前，开发者通常手写Tab控件，并且需要手动控制UI。并且设计出来的Tab效果很一般。Google在2014年的iosched工程中推出了<a href="https://github.com/google/iosched/blob/master/android/src/main/java/com/google/samples/apps/iosched/ui/widget/SlidingTabLayout.java">SlidingTabLayout</a>，这个组件后来也在众多项目中被开发者用到。但是开发者还是得添加额外的代码来控制UI。</p>

<p>TabLayout帮助开发者创建符合界面风格的Tab，并且简单易用。</p>

<h5>CoordinatorLayout &amp; Collapse Toolbar</h5>

<p>更加优美的导航，导航可以相应页面滚动，也产生相应的滚动效果。可以参考Android 5.0版本默认的联系人应用。</p>

<h2>结语</h2>

<p>目前 Material Design 在国内潜伏了一年，也没引起太大的市场反馈。互联网泡沫下，决策者的心思都花在了如何推广如何吸引第一批用户上了，难以负担App重新设计带来的时间成本，更不行因为重设计造成现有用户的流失。</p>

<p>当然，如果某一天所有的国内手机都可以升级为5.0系统，是不是会有许多软件开发者考虑对App做Material Design呢？Android系统深度定制化依然成为5.0难以在国产手机中推广的重要阻碍。</p>

<p>Material Design作为Android App设计风格的趋势，尝试在你的App中使用新的风格，也许可以给你的产品带来不一样的体验。</p>

<h2>Open Party PPT 下载地址</h2>

<p><a href="http://7xj9js.com1.z0.glb.clouddn.com/Android%20Material%20Design.pptx">Android Material Design PPT 下载</a></p>

<p><strong>参考</strong></p>

<p><a href="https://www.google.com/design/spec/material-design/introduction.html">Google Materil Design</a></p>

<p><a href="http://developer.android.com/training/material/index.html">Material Design for Developers</a></p>

<p><a href="http://android-developers.blogspot.sg/2015/05/android-design-support-library.html">Android Design Support Library</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Design - Difference Between Px Sp and Dp]]></title>
    <link href="http://www.gongmingqm10.net/blog/2015/05/09/android-design-difference-between-px/"/>
    <updated>2015-05-09T11:32:59+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2015/05/09/android-design-difference-between-px</id>
    <content type="html"><![CDATA[<p>Android自兴起以来，开发者不断增加，与此同时市场上参差不齐的设备也不断增加，随之而来的则是开发者需要适配众多机型而带来的困扰与抱怨。并且随着不同厂家定制化不同的ROM，Android设备的碎片化现象日益严重。这篇文章主要讲述如何设计中严格遵从设计图标准的Android页面。</p>

<h2>1. px, dp, sp区别</h2>

<h3>什么是px</h3>

<p>px就是我们通常所说的像素的单位，在css里面，我们用px比较多。px主要指用户在屏幕上看到的事物的实际大小单位。</p>

<h3>什么是dp</h3>

<p>在看手机或者电脑参数时，我们经常说到一个关键词，屏幕分辨率(resolution)，分辨率被表示成每一个方向上的像素数量，比如800x480分辨率</p>

<!-- more -->


<p><img src="/images/retina_one_screen.jpg" title="Mac retina resolution" ></p>

<p>上图中，我们可以看到15寸的retina pro分辨率是2880x1800，而60寸的HDTV分辨率却只有1920x1080。可见如果60寸的HDTV也要达到Retina的显示效果，其分辨率大概至少为11520x7200。</p>

<p>既然已经有了分辨率的概念，那么我们就可以了解 dpi(dot per inch)的概念了。dpi本意是每英寸点的数量，但是也经常和ppi(pixel per inch)混用。指每英寸的像素数量，也被我们称为屏幕密度，dpi越大，图像从视觉上看起来越清晰。</p>

<p>Google官方对dp的解释如下：</p>

<blockquote><p>A virtual pixel unit that you should use when defining UI layout, to express layout dimensions or position in a density-independent way.
The density-independent pixel is equivalent to one physical pixel on a 160 dpi screen, which is the baseline density assumed by the system for a &ldquo;medium&rdquo; density screen. At runtime, the system transparently handles any scaling of the dp units, as necessary, based on the actual density of the screen in use. The conversion of dp units to screen pixels is simple: px = dp * (dpi / 160). For example, on a 240 dpi screen, 1 dp equals 1.5 physical pixels. You should always use dp units when defining your application&rsquo;s UI, to ensure proper display of your UI on screens with different densities.</p></blockquote>

<p>有了密度的概念，我们可以更好的理解dp(density independent pixel)了。dp是Android中用来定义UI布局中表达元素尺寸或位置的一个虚拟的像素单位，dp的存在是为了页面元素位置不受屏幕密度所影响。以设计师设计一个APP页面为例，设计师希望用户视觉上看起来如此，也就是设计师设计时通常以px作为基础单位。而在其他不同屏幕密度的设备中，也希望能够进行一定的伸缩，类似于维持一个相对一致的百分比。所以开发者通常需要以dp为单位，以适应不同密度的屏幕。</p>

<p>所以dp和px之间有一套换算标准：<code>px = dp * (dpi / 160)</code>。假设在dpi为320的屏幕上，1dp = 2px。</p>

<h3>什么是sp</h3>

<p>sp是Android中专业为字体而设置的单位。使用sp作为字体单位不仅能够使字体大小受屏幕密度影响，并且能够使字体受用户系统设置的影响。Android提供字体大小的设置选项。一旦使用sp作为字体，根据用户设置字体的不同，App中的字体大小也会显示不同。但是在正常字体设置下，1dp ＝ 1sp。</p>

<h2>2. 设计师视角</h2>

<p>Android的多屏适配存在这么多的尺寸，自然需要设计师和工程师之间找到沟通的桥梁，设计师如何规范设计才能够更加符合Android的设计标准呢。设计师与工程师对于页面的尺寸需要有一个共识性的标准，测试人员才可能进行更有效的测试，才不致于因为不同机型显示不同效果而引起不必要的工作量。</p>

<p>首先我们需要选择一个相对通用的屏幕尺寸，可以参考现有的一些主流机型的尺寸。为了便于计算，我们选择Nexus 4作为设计图的原版标准。那么所有的页面都是基于Nexus4而产生的。Nexus4尺寸如下:</p>

<p><code>主屏尺寸4.7，主屏分辨率：1280x768像素，屏幕像素密度320ppi。</code></p>

<p>一般来说，我们选择市场上最常见的机型来设计，这里我们为了计算方便，选择320ppi的机型，设计图中尺寸将是标准图中的2倍。假设在设计图中，页面内边距为32px, 按钮的高度为96px, icon大小为48x48。</p>

<p>通过<code>px＝dp*(dpi/160)</code>的标准，设计师给开发者标注图时可标注页边距为16dp，按钮高度为48dp，icon则分别出四套mdpi, hdpi, xhdpi, xxhdpi标准。</p>

<h2>3. 开发者视角</h2>

<h3>margin, padding, height, width</h3>

<p>从开发者角度来看，对于控件的尺寸，高度等，只需要按照转化后的dp设置即可。</p>

<p>```
android:layout_padding=&ldquo;16dp&rdquo;</p>

<p>android:layout_height=&ldquo;48dp&rdquo;</p>

<p>```</p>

<p>以dp为单位能够保证不同分辨率屏幕上显示不同大小的字体。并且能够保持相对大小，这样也更符合设计的初衷。</p>

<h3>图片资源</h3>

<p>对于png制作出来的图片，一般大小固定，没办法像尺寸一样自动的伸缩。所以Android会存在至少4个资源文件夹。当App运行过程中，系统能够根据当前设备的屏幕密度，自动选择使用哪种尺寸的图片资源。</p>

<table>
<thead>
<tr>
<th>ldpi </th>
<th> mdpi </th>
<th> hdpi </th>
<th> xhdpi </th>
<th> xxhdpi </th>
<th> xxxhdpi</th>
</tr>
</thead>
<tbody>
<tr>
<td>0.75 </td>
<td> 1  </td>
<td> 1.5 </td>
<td> 2 </td>
<td> 3 </td>
<td> 4</td>
</tr>
<tr>
<td>120 </td>
<td> 160 </td>
<td> 240 </td>
<td> 320 </td>
<td> 480 </td>
<td> 640</td>
</tr>
<tr>
<td>18x18 </td>
<td> 24x24 </td>
<td> 36x36 </td>
<td> 48x48 </td>
<td> 72x72 </td>
<td> 96x96</td>
</tr>
</tbody>
</table>


<h2>4. 更多</h2>

<p>附上Android主流机型：</p>

<p>Android：主流机型主要为 480x800, 480x854, 540x960, 720x1280, 800x1280 这五种。
（非主流机型还包括：240x320, 320x480, 640x960 这三种，其中两种都与 iPhone 一致。）
iOS: 主流机型主要为 320x480, 640x960, 640x1136, 1024x768, 2048x1536, 这五种。
WP：主流机型主要为 480x800，720x1280, 768x1280 这三种</p>

<p>Photoshop制图时，字体大小通常是pt这个单位。pt是长度单位， 1pt = 1/72英寸， px = pt * dpi/72。</p>

<p>另附上豆瓣关于这些单位更<a href="http://www.douban.com/note/155032221/">具体的阐释</a>。</p>
]]></content>
  </entry>
  
</feed>
