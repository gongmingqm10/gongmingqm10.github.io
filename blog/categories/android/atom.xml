<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | gongmingqm10]]></title>
  <link href="http://www.gongmingqm10.net/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://www.gongmingqm10.net/"/>
  <updated>2015-11-03T08:53:19+08:00</updated>
  <id>http://www.gongmingqm10.net/</id>
  <author>
    <name><![CDATA[Gong Ming]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android 应用的持续交付]]></title>
    <link href="http://www.gongmingqm10.net/blog/2015/06/29/android-testing-practice/"/>
    <updated>2015-06-29T11:40:16+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2015/06/29/android-testing-practice</id>
    <content type="html"><![CDATA[<p>当我们谈软件质量时，我们一般会谈到测试。测试作为保障软件质量的重要手段正在被开发者逐渐认知。谈到测试时，大部分人都知道Web测试，对于前端JS或者后台，大部分“靠谱”的创业公司也都会用测试来保证软件质量。可是对于起步相对较晚的移动端测试，用的人并不多。</p>

<p>在测试方面，Android早期即存在UIAtomator和Monkey之类的测试，但是用起来实在不方便。2013年，Google开源了针对An ndroid平台的移动测试框架 &ndash; Espresso。Espresso可以针对每个页面(Activity)进行测试。开发者可以根据ID获取到页面元素，然后进行点击、长按等操作。结合Junit和Mock等工具，使得移动端测试成为可能。移动端拥有了测试框架的辅助，借助CI平台，持续交付也成为可能。</p>

<!-- more -->


<h2>Android测试的类别</h2>

<p>从开发者角度来看，通常的Web平台测试可以分为单元测试、集成测试以及功能测试。移动应用主要用来显示数据，显示框输入数据，相应用户的点击、滑动等操作。所以Android应用的开发工作大部分集中在UI上。因此，App测试大致可分为UI单元测试和功能测试。</p>

<p>UI单元测试覆盖界面显示以及用户与界面的交互。功能测试则是确保功能的正确性。</p>

<p>为了更好的说明App中UI测试和功能测试如何进行的，以一个Story举例如下：</p>

<p>```
Story-101
Summary: 登录模块，用户能够使用用户名和密码登录App。
Acceptance criterions:</p>

<p>Given 作为用户，我打开App进入首页；
When 我点击“登录”按钮；
Then 我跳转到登录页面；</p>

<p>Given 作为用户，我在登录页面
When 我只输入用户名
Then 登录按钮处于Disable状态
When 我输入密码
Then 登录按钮可以点击，点击之后，调用API</p>

<p>Given 作为用户，我在登录页面
When 我输入正确的用户名和密码，并登录
Then 页面跳转到首页</p>

<p>Given 作为用户，我在登录页面
When 我输入错误的用户名和密码，并登录
Then 页面上方显示“用户名或密码错误”提示
And 密码被清空，登录按钮重新Disable</p>

<p>```</p>

<h3>UI单元测试</h3>

<p>UI(User interaction)测试又指界面测试。界面是软件与用户交互的最直接的部分，通过UI测试核实用户和软件拥有正常的交互。</p>

<p>UI测试的功能点比较简单：比如点击按钮的行为，按钮是否应该被禁用，页面文字、颜色等信息，是否弹框，点击弹框按钮应该跳转到什么页面等。</p>

<p>在登录页面中，假设登录页面的名字为LoginActivity，这是需要写的UI测试如下：</p>

<p>1.Test login button is not available until username and password are filled</p>

<p>```
usernameEditText.setText(&ldquo;gongmingqm10&rdquo;)
assertThat(loginButton.isDisabled()).isTrue()</p>

<p>passwordEditText.setText(&ldquo;password&rdquo;)
assertThat(loginButton.isDisabled()).isFalse()
```</p>

<p>2.Test should invoke Api when login button is clicked</p>

<p>```
usernameEditText.setText(&ldquo;gongmingqm10&rdquo;)
passwordEditText.setText(&ldquo;password&rdquo;)</p>

<p>loginButton.performClick()</p>

<p>verify(loginApi).login(eq(&ldquo;gongmingqm10&rdquo;), eq(&ldquo;encryptedpassword&rdquo;)</p>

<p>```</p>

<p>3.Test should show error dialog when login failed</p>

<p>```
usernameEditText.setText(&ldquo;gongmingqm10&rdquo;)
passwordEditText.setText(&ldquo;wrongpassword&rdquo;)
activity.loginFailed()
assertThat(passwordEditText.getText().toString()).isEqualTo(&ldquo;&rdquo;)
assertThat(errorText).isVisibile()
assertThat(errorText.getText().toString()).isEuqalTo(&ldquo;用户名或密码错误&rdquo;)</p>

<p>```</p>

<p>4.Test should navigate to home page when login succeed</p>

<p><code>
usernameEditText.setText("gongmingqm10")
passwordEditText.setText("correctpassword")
activity.loginSuccess()
String actualPageName = getNextStartedActivity().getComponentName()
assertThat(actualPageName).isEqualTo(HomeActivity.class.getName())
</code></p>

<p>观察上述几个测试，我们可以看到对UI的测试粒度相对较小。主要测试用户输入，按钮点击，服务器返回结果之后，界面应该如何反应。UI测试通常也包括简单的单元测试，Android中需要进行单元测试的内容较少，所以对于一些工具类的单元测试通常和UI测试放在同一个模块中。(PS: 上述测试代码的写法和你选取的测试框架有关)</p>

<h3>功能测试</h3>

<p>功能测试主要把测试对象看作一个黑盒子，测试者并不关注具体的功能实现逻辑，只需要关注输入产生期望的输出即可。Android的功能测试和Web的功能测试类似。在真机或模拟器中运行App，模拟输入、点击等操作，识别界面上是否存在某些期望的文字或行为。</p>

<p>功能测试不需要关注细节，只需要关注功能，对登录Story的功能测试如下：</p>

<p>1.With valid username and password, user can successfully login and navigate to home screen</p>

<p><code>
tap_when_element_exists "android.widget.EditText hint:'Username'"
keyboard_enter_text 'gongmingqm10'
tap_when_element_exists "android.widget.EditText hint:'Password'"
keyboard_enter_text 'some_correct_password'
@home_page.wait_for_page_to_load
welcome_message = @home_page.get_welcome_message
raise 'Navigate to home page failed' if welcome_message.empty?
</code></p>

<p>2.With wrong username and password, user will see an error text</p>

<p><code>
tap_when_element_exists "android.widget.EditText hint:'Username'"
keyboard_enter_text 'gongmingqm10'
tap_when_element_exists "android.widget.EditText hint:'Password'"
keyboard_enter_text 'wrong_password'
query "android.widget.TextView id: 'error_box' text:'用户名或者密码错误'"
</code></p>

<h2>Android常用测试框架</h2>

<h3>针对UI测试</h3>

<p>一般项目上都会采用<a href="http://robolectric.org/">Robolectric</a>框架，Robolectric运行过程中不需要启动模拟器，因此执行过程很快。</p>

<p>除了Robolectric，Google官方推荐使用Espresso来做UI测试。Espresso既可以作UI测试，也可以做简单的功能测试。</p>

<h3>针对功能测试</h3>

<p>可以做功能测试的框架也很多，包括Robotium, uiautomator, Espresso, Appium 和 Calabash。对比其主要区别如下：</p>

<p>真实项目过程中功能测试框架使用较多的是Appium和Calabash。这两个框架的优点是能够同时支持Android和iOS，并且不需要注入到工程中(即只需要编译后生成的安装包)，配合响应的测试脚本即可完成测试。</p>

<h2>Android持续交付</h2>

<p>CD(Continuous Dilivery)强调能够随时给客户交付有价值的产品。在Web开发上，我们通常运用CI平台持续部署网站到各个环境中。从而实现整个产品的持续交付。在Android平台上也是类似，唯一不同点是Android每发布一个版本需要用户手动更新手机上的App。</p>

<p><strong>1. 集成你的测试框架</strong></p>

<p>假定我们已经选定其他的技术栈，这时只需要集成UI测试和功能测试即可。UI单元测试框架我们选择Robolectric，而功能测试框架选择Calabash。参考<a href="http://robolectric.org/">Robolectric</a>和<a href="https://github.com/calabash/calabash-android">Calabash for Android</a>官方文档，集成测试框架并编写第一个Dummy Test。</p>

<p><strong>2. 通过你的第一个Dummy Test</strong></p>

<p>CI(Continuous Integration)平台，选择Jenkins。因为Jenkins有各种丰富的插件支持。选择Jenkins平台之后，最后能够有一台带界面的Mac Mini(虽然Android可以配置无界面运行，但是配置相对麻烦并且运行太慢)。在Mac Mini上搭建CI环境，配置Android运行环境。此步的目的是你的Dummy Test能够在Jenkins上运行</p>

<p><strong>3. 自动上传你的应用</strong></p>

<p>我们希望每次Push之后生成的包能够被QA测试，Showcase时候能够被客户测试。所以我们需要持续的发布新生成的包。我接触到的通常有两种做法：</p>

<ul>
<li>使用Dropbox自动同步上传：这种方法是最省成本的。每次打包新版本的时候只需要给文件带上不同的版本号，方便辨识。包生成之后，只需要存放到本地的Dropbox共享文件夹中。Dropbox会为我们自动上传。手机端则可以直接访问Dropbox下载，安装。</li>
<li>使用<a href="http://hockeyapp.net/features/">HockeyApp</a>管理版本：HockeyApp需要收费，但是可以很方便的通过部署脚本自动上传新生成的包。手机端只需要安装HockeyApp客户端，即可选择更新。</li>
</ul>


<p>类似的工具还有很多，选择适合自己的才是最好的。</p>

<h2>结语</h2>

<p>移动端测试虽然发展时间不长，但是却不断在完善中。我们以前习惯用邮件或U盘发布新版供他人测试。我们以前习惯开发App时不写测试。那些时代应该过去了。运用Robolectric，我们可以很轻松的测试驱动开发Android App；运用Calabash或Appium，我们可以更好的控制App质量，保证App功能；运用Jenkins等CI平台，我们的App可以持续交付啦!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Material Design Your Android App]]></title>
    <link href="http://www.gongmingqm10.net/blog/2015/06/25/material-design-your-android-app/"/>
    <updated>2015-06-25T15:22:27+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2015/06/25/material-design-your-android-app</id>
    <content type="html"><![CDATA[<p>14年6月26日的Google I/O大会上，Google推出了一门全新的设计语言Material Design。Material Design在随后的一年里被逐渐应用到Android, Web等平台中。Material Design的推出意味着Google对移动端和网页端设计的整合。固然没有引起轩然大波，但是Material Design却让Android开发者看到了一点福音。</p>

<p>虽然Android系统广受诟病，越来越多的用户投奔苹果的iOS系统。然而这阻挡不了Android的不断改进。14年Google I/O, Google推出了Android的5.0版本，代号Lollipop。5.0版本在设计上采用全新的Material Design，虽然这次升级对ROM生产商来说是道“过不去的坎儿”，但是对开发者群体而言却是一次很不错的升级。因为开发者可以凭借有些的设计资源打造出更好看的App。</p>

<!-- more -->


<h2>关于Material Design</h2>

<blockquote><p>Material design is a comprehensive guide for visual, motion, and interaction design across platforms and devices.</p></blockquote>

<p>这是Google官方给的解释， Material Design 中文直译为 “物质的设计”。可以简单理解为画面中的所有元素都可以看作是真实的物质，物质存在于空间中，并且存在光、影、运动等特征。所以Material Design的众多原则都是基于Material这个概念而提出的。</p>

<h3>Material Design基本原则</h3>

<p>Material Design作为设计与交互的一部分，由设计师来阐述更为专业。以下只是抛砖引玉的介绍，也许身边的设计师朋友会更专业的见解。</p>

<h4>Material is the metaphor</h4>

<blockquote><p>A material metaphor is the unifying theory of a rationalized space and a system of motion</p></blockquote>

<p>举例来说，在Android Lollipop系统中，当用户点击操作时，界面会反馈出水纹般的涟漪向周边散去，作为对用户点击操作的直接反馈。Material的设计都是基于现实，并在现实世界的基础上予以创新的。创新之处表现在元素之间整理运动的和谐。即使是在现实世界进行创新，最重要的是要Material Design不会破坏物理世界的规则。</p>

<h4>Bold, graphic, intentional</h4>

<blockquote><p>The foundational elements of print-based design—typography, grids, space, scale, color, and use of imagery—guide visual treatments.</p></blockquote>

<p>设计中的基本元素网格，空间，比例，字体，颜色等的结合能够给用户带来更好的体验，从而产生更大的价值。Material Design给我们指定了一些常见的搭配组合，比如颜色的组合、App中不同部分字体大小，组件之间的边距等。</p>

<h4>Motion provides meaning</h4>

<blockquote><p>Motion respects and reinforces the user as the prime mover. Primary user actions are inflection points that initiate motion, transforming the whole design.</p></blockquote>

<p>动画通常是App中最常见的交互，在Material Design出来之前，大部分App是很少有动画的。因为动画从设计到最后被用户使用，需要动画的设计以及开发，有时还会受限于平台。Material Design在动画方面有所加强，官方推出了许多默认的动作，页面各个元素之间的相互运动等。期望通过元素的运动向用户传达更为核心的价值和功能。</p>

<h3>为什么我们需要Material Design</h3>

<p>设计主要是为了提升用户体验，辅助产品功能，起到锦上添花的效果。Google推出Material Design也许希望对所有的Google产品进行设计上的统一化。</p>

<p>从Android平台来看，以前的Google Apps很难说有什么风格，其他厂商开发的App也是风格各异。Google希望通过Lollipop对App统一风格，所以在5.0＋平台上的Gmail, Youtube, Calender等都进行了风格的统一化，借此引导更多的设计师和开发者开发出更“接地气”的App。</p>

<p>Material Design强调跨平台设计，如果你遵从Material Design，你会发现将无论是宽屏平板设备、还是手机，你会发现你的应用可以很智能的进行展示。这将极大减轻适配平板带来的工作量。是不是有点类似于Web上的响应式设计呢？</p>

<p>当然选择是自由的，如果你觉得你的App不需要Material Design，那么TA真的不需要。</p>

<h2>如何Material Design App</h2>

<p>据个人观察，目前国内市场上大部分的App没有Material Design的概念。原因不得而知。但是遵循Material Design的应用在国外却比较常见。比如我个人常用的雅虎天气。</p>

<p>那么如何空手开发Material Design 应用呢？假定读到这里的你是个开发人员：</p>

<h3>1.合适的SDK版本和相关兼容包</h3>

<p>build.gradle</p>

<p>```
apply plugin: &lsquo;com.android.application&rsquo;</p>

<p>android {</p>

<pre><code>compileSdkVersion 22
buildToolsVersion "22.0.1"

defaultConfig {
    applicationId "net.gongmingqm10.training"
    minSdkVersion 16
    targetSdkVersion 22
    versionCode 1
    versionName "1.0"
}
...
</code></pre>

<p>}</p>

<p>dependencies {</p>

<pre><code>compile fileTree(dir: 'libs', include: ['*.jar'])
//required
compile 'com.android.support:appcompat-v7:22.2.0'
//optional for RecyclerView
compile 'com.android.support:recyclerview-v7:22.2.0'
//optional for GridLayout
compile 'com.android.support:gridlayout-v7:22.2.0'
//optional for CardView
compile 'com.android.support:cardview-v7:22.2.0'
//optional for some useful libraries
compile 'com.android.support:design:22.2.0'
</code></pre>

<p>}</p>

<p>```</p>

<h3>2.使用 Material theme</h3>

<p>values-v21/styles.xml</p>

<p>```
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;utf-8&rdquo;?>
<resources></p>

<pre><code>&lt;style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar"&gt;
    &lt;!-- Main theme colors --&gt;
    &lt;!--   your app branding color for the app bar --&gt;
    &lt;item name="colorPrimary"&gt;@color/color_primary&lt;/item&gt;
    &lt;!--   darker variant for the status bar and contextual app bars --&gt;
    &lt;item name="colorPrimaryDark"&gt;@color/color_primary_dark&lt;/item&gt;
    &lt;!--   theme UI controls like checkboxes and text fields --&gt;
    &lt;item name="colorAccent"&gt;@color/color_accent&lt;/item&gt;

&lt;/style&gt;
</code></pre>

<p></resources></p>

<p>```</p>

<p>values/styles.xml</p>

<p>```
<resources></p>

<pre><code>&lt;!-- Base application theme. --&gt;
&lt;style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar"&gt;
    &lt;!-- Customize your theme here. --&gt;
    &lt;item name="android:actionBarStyle"&gt;@style/MyActionBar&lt;/item&gt;
    &lt;!-- Support library compatibility --&gt;

    &lt;item name="actionBarStyle"&gt;@style/MyActionBar&lt;/item&gt;
&lt;/style&gt;

&lt;style name="AppTheme.NoActionBar"&gt;
    &lt;item name="windowActionBar"&gt;false&lt;/item&gt;
    &lt;item name="windowNoTitle"&gt;true&lt;/item&gt;
&lt;/style&gt;

&lt;!-- ActionBar styles --&gt;
&lt;style name="MyActionBar"
    parent="@style/Widget.AppCompat.Light.ActionBar.Solid.Inverse"&gt;
    &lt;item name="android:background"&gt;@color/color_primary&lt;/item&gt;
    &lt;item name="android:titleTextStyle"&gt;@style/MyActionBarTitleText&lt;/item&gt;

    &lt;!-- Support library compatibility --&gt;
    &lt;item name="background"&gt;@color/color_primary&lt;/item&gt;
    &lt;item name="titleTextStyle"&gt;@style/MyActionBarTitleText&lt;/item&gt;
&lt;/style&gt;

&lt;style name="MyActionBarTitleText" parent="TextAppearance.AppCompat.Widget.ActionBar.Title"&gt;
    &lt;item name="android:textColor"&gt;@color/white&lt;/item&gt;
&lt;/style&gt;
</code></pre>

<p></resources></p>

<p>```</p>

<p>使用你定义的AppTheme</p>

<p>```</p>

<pre><code>&lt;application
    android:name=".TrainingApp"
    android:allowBackup="true"
    android:icon="@mipmap/ic_launcher"
    android:label="@string/app_name"
    android:theme="@style/AppTheme" &gt;
    ...
&lt;/application&gt;
</code></pre>

<p>```</p>

<h3>3.使用专为Material Design打造的Android控件</h3>

<p>你可以参考<a href="http://developer.android.com/training/material/index.html">Google Training Material Design</a>获取更多的Material Design组件的使用方法。</p>

<h4>Lists and Cards</h4>

<h5>RecyclerView</h5>

<p>引入RecyclerView到工程中：</p>

<p><code>
compile 'com.android.support:recyclerview-v7:22.2.0'
</code>
RecyclerView控件是ListView的更高效更灵活的版本。可以看作是对ListView更好的封装：</p>

<ul>
<li>解决ListView多列显示的难题；</li>
<li>不用担心开发人员没有复用View，因为它会强迫你这样做；</li>
<li>更方便的动画支持，移除中间某一项时，可以设置后面几项动画移动;</li>
</ul>


<h5>CardView</h5>

<p><code>
compile 'com.android.support:cardview-v7:22.2.0'
</code>
卡片式布局，你的界面就是有导航和卡片组成的。卡片能够设置圆角和阴影。</p>

<h4>Design support library</h4>

<p>使用Design support包含的空间，需要引入Design support库：</p>

<p><code>
compile 'com.android.support:design:22.2.0'
</code></p>

<p>Design support提供了一些很常见很实用的控件。</p>

<h5>Navigation View</h5>

<p>Material Design推荐使用DrawerLayout抽屉式布局显示导航，所以Android一直没有为底部导航推出相应的控件。按照Google最新的设计，所有的导航都会被设置为抽屉显示，点击左上角菜单可以抽屉式弹出菜单项。</p>

<p>NavigationView就是和DrawerLayout搭配使用的神器。使用NavigationView只需要提供icon和title就可以生成专业的侧边导航。</p>

<h5>Floating Action Button</h5>

<p>Material Design引入了z轴，这个控件可以轻松制作出有阴影的悬浮圆形按钮。</p>

<h5>Snackbar</h5>

<p>底部栏消息提示控件，显示显示不再只有Toast和AlertDialog，还有Snackbar。</p>

<h5>Tabs</h5>

<p>在TabLayout出来之前，开发者通常手写Tab控件，并且需要手动控制UI。并且设计出来的Tab效果很一般。Google在2014年的iosched工程中推出了<a href="https://github.com/google/iosched/blob/master/android/src/main/java/com/google/samples/apps/iosched/ui/widget/SlidingTabLayout.java">SlidingTabLayout</a>，这个组件后来也在众多项目中被开发者用到。但是开发者还是得添加额外的代码来控制UI。</p>

<p>TabLayout帮助开发者创建符合界面风格的Tab，并且简单易用。</p>

<h5>CoordinatorLayout &amp; Collapse Toolbar</h5>

<p>更加优美的导航，导航可以相应页面滚动，也产生相应的滚动效果。可以参考Android 5.0版本默认的联系人应用。</p>

<h2>结语</h2>

<p>目前 Material Design 在国内潜伏了一年，也没引起太大的市场反馈。互联网泡沫下，决策者的心思都花在了如何推广如何吸引第一批用户上了，难以负担App重新设计带来的时间成本，更不行因为重设计造成现有用户的流失。</p>

<p>当然，如果某一天所有的国内手机都可以升级为5.0系统，是不是会有许多软件开发者考虑对App做Material Design呢？Android系统深度定制化依然成为5.0难以在国产手机中推广的重要阻碍。</p>

<p>Material Design作为Android App设计风格的趋势，尝试在你的App中使用新的风格，也许可以给你的产品带来不一样的体验。</p>

<h2>Open Party PPT 下载地址</h2>

<p><a href="http://7xj9js.com1.z0.glb.clouddn.com/Android%20Material%20Design.pptx">Android Material Design PPT 下载</a></p>

<p><strong>参考</strong></p>

<p><a href="https://www.google.com/design/spec/material-design/introduction.html">Google Materil Design</a></p>

<p><a href="http://developer.android.com/training/material/index.html">Material Design for Developers</a></p>

<p><a href="http://android-developers.blogspot.sg/2015/05/android-design-support-library.html">Android Design Support Library</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Design - Difference Between Px Sp and Dp]]></title>
    <link href="http://www.gongmingqm10.net/blog/2015/05/09/android-design-difference-between-px/"/>
    <updated>2015-05-09T11:32:59+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2015/05/09/android-design-difference-between-px</id>
    <content type="html"><![CDATA[<p>Android自兴起以来，开发者不断增加，与此同时市场上参差不齐的设备也不断增加，随之而来的则是开发者需要适配众多机型而带来的困扰与抱怨。并且随着不同厂家定制化不同的ROM，Android设备的碎片化现象日益严重。这篇文章主要讲述如何设计中严格遵从设计图标准的Android页面。</p>

<h2>1. px, dp, sp区别</h2>

<h3>什么是px</h3>

<p>px就是我们通常所说的像素的单位，在css里面，我们用px比较多。px主要指用户在屏幕上看到的事物的实际大小单位。</p>

<h3>什么是dp</h3>

<p>在看手机或者电脑参数时，我们经常说到一个关键词，屏幕分辨率(resolution)，分辨率被表示成每一个方向上的像素数量，比如800x480分辨率</p>

<!-- more -->


<p><img src="/images/retina_one_screen.jpg" title="Mac retina resolution" ></p>

<p>上图中，我们可以看到15寸的retina pro分辨率是2880x1800，而60寸的HDTV分辨率却只有1920x1080。可见如果60寸的HDTV也要达到Retina的显示效果，其分辨率大概至少为11520x7200。</p>

<p>既然已经有了分辨率的概念，那么我们就可以了解 dpi(dot per inch)的概念了。dpi本意是每英寸点的数量，但是也经常和ppi(pixel per inch)混用。指每英寸的像素数量，也被我们称为屏幕密度，dpi越大，图像从视觉上看起来越清晰。</p>

<p>Google官方对dp的解释如下：</p>

<blockquote><p>A virtual pixel unit that you should use when defining UI layout, to express layout dimensions or position in a density-independent way.
The density-independent pixel is equivalent to one physical pixel on a 160 dpi screen, which is the baseline density assumed by the system for a &ldquo;medium&rdquo; density screen. At runtime, the system transparently handles any scaling of the dp units, as necessary, based on the actual density of the screen in use. The conversion of dp units to screen pixels is simple: px = dp * (dpi / 160). For example, on a 240 dpi screen, 1 dp equals 1.5 physical pixels. You should always use dp units when defining your application&rsquo;s UI, to ensure proper display of your UI on screens with different densities.</p></blockquote>

<p>有了密度的概念，我们可以更好的理解dp(density independent pixel)了。dp是Android中用来定义UI布局中表达元素尺寸或位置的一个虚拟的像素单位，dp的存在是为了页面元素位置不受屏幕密度所影响。以设计师设计一个APP页面为例，设计师希望用户视觉上看起来如此，也就是设计师设计时通常以px作为基础单位。而在其他不同屏幕密度的设备中，也希望能够进行一定的伸缩，类似于维持一个相对一致的百分比。所以开发者通常需要以dp为单位，以适应不同密度的屏幕。</p>

<p>所以dp和px之间有一套换算标准：<code>px = dp * (dpi / 160)</code>。假设在dpi为320的屏幕上，1dp = 2px。</p>

<h3>什么是sp</h3>

<p>sp是Android中专业为字体而设置的单位。使用sp作为字体单位不仅能够使字体大小受屏幕密度影响，并且能够使字体受用户系统设置的影响。Android提供字体大小的设置选项。一旦使用sp作为字体，根据用户设置字体的不同，App中的字体大小也会显示不同。但是在正常字体设置下，1dp ＝ 1sp。</p>

<h2>2. 设计师视角</h2>

<p>Android的多屏适配存在这么多的尺寸，自然需要设计师和工程师之间找到沟通的桥梁，设计师如何规范设计才能够更加符合Android的设计标准呢。设计师与工程师对于页面的尺寸需要有一个共识性的标准，测试人员才可能进行更有效的测试，才不致于因为不同机型显示不同效果而引起不必要的工作量。</p>

<p>首先我们需要选择一个相对通用的屏幕尺寸，可以参考现有的一些主流机型的尺寸。为了便于计算，我们选择Nexus 4作为设计图的原版标准。那么所有的页面都是基于Nexus4而产生的。Nexus4尺寸如下:</p>

<p><code>主屏尺寸4.7，主屏分辨率：1280x768像素，屏幕像素密度320ppi。</code></p>

<p>一般来说，我们选择市场上最常见的机型来设计，这里我们为了计算方便，选择320ppi的机型，设计图中尺寸将是标准图中的2倍。假设在设计图中，页面内边距为32px, 按钮的高度为96px, icon大小为48x48。</p>

<p>通过<code>px＝dp*(dpi/160)</code>的标准，设计师给开发者标注图时可标注页边距为16dp，按钮高度为48dp，icon则分别出四套mdpi, hdpi, xhdpi, xxhdpi标准。</p>

<h2>3. 开发者视角</h2>

<h3>margin, padding, height, width</h3>

<p>从开发者角度来看，对于控件的尺寸，高度等，只需要按照转化后的dp设置即可。</p>

<p>```
android:layout_padding=&ldquo;16dp&rdquo;</p>

<p>android:layout_height=&ldquo;48dp&rdquo;</p>

<p>```</p>

<p>以dp为单位能够保证不同分辨率屏幕上显示不同大小的字体。并且能够保持相对大小，这样也更符合设计的初衷。</p>

<h3>图片资源</h3>

<p>对于png制作出来的图片，一般大小固定，没办法像尺寸一样自动的伸缩。所以Android会存在至少4个资源文件夹。当App运行过程中，系统能够根据当前设备的屏幕密度，自动选择使用哪种尺寸的图片资源。</p>

<table>
<thead>
<tr>
<th>ldpi </th>
<th> mdpi </th>
<th> hdpi </th>
<th> xhdpi </th>
<th> xxhdpi </th>
<th> xxxhdpi</th>
</tr>
</thead>
<tbody>
<tr>
<td>0.75 </td>
<td> 1  </td>
<td> 1.5 </td>
<td> 2 </td>
<td> 3 </td>
<td> 4</td>
</tr>
<tr>
<td>120 </td>
<td> 160 </td>
<td> 240 </td>
<td> 320 </td>
<td> 480 </td>
<td> 640</td>
</tr>
<tr>
<td>18x18 </td>
<td> 24x24 </td>
<td> 36x36 </td>
<td> 48x48 </td>
<td> 72x72 </td>
<td> 96x96</td>
</tr>
</tbody>
</table>


<h2>4. 更多</h2>

<p>附上Android主流机型：</p>

<p>Android：主流机型主要为 480x800, 480x854, 540x960, 720x1280, 800x1280 这五种。
（非主流机型还包括：240x320, 320x480, 640x960 这三种，其中两种都与 iPhone 一致。）
iOS: 主流机型主要为 320x480, 640x960, 640x1136, 1024x768, 2048x1536, 这五种。
WP：主流机型主要为 480x800，720x1280, 768x1280 这三种</p>

<p>Photoshop制图时，字体大小通常是pt这个单位。pt是长度单位， 1pt = 1/72英寸， px = pt * dpi/72。</p>

<p>另附上豆瓣关于这些单位更<a href="http://www.douban.com/note/155032221/">具体的阐释</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setup Jenkins for Android Integration Using Docker]]></title>
    <link href="http://www.gongmingqm10.net/blog/2015/03/12/setup-jenkins-for-android-integration-using-docker/"/>
    <updated>2015-03-12T10:46:59+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2015/03/12/setup-jenkins-for-android-integration-using-docker</id>
    <content type="html"><![CDATA[<h2>About Docker</h2>

<p>什么Docker，为什么我们要折腾Docker，而不是直接在服务器上安装运行appilication所需的各种环境呢？</p>

<p>这个问题的产生和为什么需要虚拟机的理由差不多，我需要让我的代码运行在一个干净的无干扰的机器上，这样能够保证代码测试运行环境的一致性，降低其他不可知因素对代码的影响。而Docker和VM虚拟机相比又有其特点，比如启动速度快，可以单独将Docker保存为镜像，上传后能够让别人使用。甚至可以直接将自己的code放在Docker中，直接将环境和代码一起交付给客户。客户只需要安装这个Docker，运行后就可以直接使用这个application了。</p>

<blockquote><p>Develop, Ship and Run Any Application, Anywhere</p></blockquote>

<!-- more -->


<p>Docker is a platform for developers and sysadmins to develop, ship, and run applications. Docker lets you quickly assemble applications from components and eliminates the friction that can come when shipping code. Docker lets you get your code tested and deployed into production as fast as possible.</p>

<h3>Provision</h3>

<p>我的目标在于构建一个可以运行Android的CI服务器。出于省钱的目的，我使用本地的Vagrant启动Ubuntu虚拟机来代替真正的服务器。大致思路是：</p>

<ol>
<li>启动Ubuntu虚拟机，在Ubuntu上安装Docker；</li>
<li>通过Docker安装Jenkins Docker官方镜像；</li>
<li>在这个实例Docker中配置Jenkins并安装Android运行环境；</li>
<li>在Jenkins上搭建Android CI，使得Android单元测试和集成测试能够顺利通过；</li>
<li>上传这个具有Android CI功能的Jenkins镜像；</li>
<li>本地启动B虚拟机，下载镜像，访问B虚拟机的地址，查看Android Jenkins；</li>
</ol>


<h3>1. 启动Ubuntu虚拟机并安装Docker Jenkins</h3>

<p>在安装Docker之前，首先得有一个Linux的机器能够进入，如果你已经有一台干净的Linux服务器，直接进入安装Docker步骤。</p>

<p>Vagrant安装之前，你应该在电脑上安装VirtualBox虚拟机。VirtualBox安装完成之后请参考 <a href="http://docs.vagrantup.com/v2/installation/index.html">Vagrant Installation Guide</a>。</p>

<p>Vagrant成功安装后，<code>vagrant init ubuntu/trusty64</code> 能够帮你快速安装一台Ubuntu14.04的虚拟机，第一次安装的时候会稍微慢点，因为Vagrant会帮你生成Vagrantfile文件，并下载镜像。</p>

<p>Vagrantfile生成之后不要立即启动，因为我们想通过localhost访问Vagrant，然后通过Vagrant访问其中的Docker。由于Jenkins默认会使用8080端口，所以如果Vagrant的8080端口可以转发到Docker Container中的Jenkins。localhost:8080能够转发到Vagrant Ubuntu的8080端口，然后Vagrant的8080端口继续转发到Docker的8080端口，于是可以通过<code>localhost:8080</code>访问Jenkins了。所以Vagrantfile部分配置如下，添加端口转发。因为我本机的8080端口被其他程序占用，所以我将本地的8088端口转发到虚拟机的8080端口：</p>

<p><code>
  # Create a forwarded port mapping which allows access to a specific port
  # within the machine from a port on the host machine. In the example below,
  # accessing "localhost:8080" will access port 80 on the guest machine.
  #config.vm.network :forwarded_port, guest: 80, host: 8080
  config.vm.network :forwarded_port, guest: 8080, host: 8088
</code></p>

<p>如果你之前已经启动了vagrant up, 然后更改了Vagrantfile想让forward_port生效，需要先<code>vagrant suspend</code>暂停vagrant，然后使用<code>vagrant reload</code>重新加载Vagrantfile使配置生效。</p>

<p>Vagrant Ubuntu 初始化完成之后，还是在这个有Vagrantfile的文件夹下，<code>vagrant up</code>能够直接启动这台Ubuntu服务器。</p>

<p>顺利的话我们可以进入通过<code>vagrant ssh</code>进入Ubuntu，随后需要在这台干净的Ubuntu机器上<a href="http://docs.docker.com/installation/ubuntulinux/">安装Docker</a>：</p>

<p>```
$ sudo apt-get update
$ sudo apt-get install docker.io
$ source /etc/bash_completion.d/docker.io</p>

<p>// 上述方法安装的Docker版本为1.0.1，如果你想使用较高版本Docker1.3.3</p>

<p>$ echo deb <a href="http://get.docker.com/ubuntu">http://get.docker.com/ubuntu</a> docker main > /etc/apt/sources.list.d/docker.list
$ apt-key adv &mdash;keyserver pgp.mit.edu &mdash;recv-keys 36A1D7869245C8950F966E92D8576A8BA88D21E9
$ apt-get update
$ apt-get install -y lxc-docker-1.3.3</p>

<p><code>``
Note:</code>vagrant destroy<code>会关闭并重新格式化ubuntu机器，如果你只是想简单的停止机器，请使用</code>vagrant suspend`</p>

<p>Docker成功安装后，直接启动Jenkins官方镜像：</p>

<p><code>
docker run --name androidJenkins -p 8080:8080 -v /var/jenkins_home jenkins
</code></p>

<p>安装完成后，访问 <code>http://localhost:8088/</code>，如果可以看到Jenkins界面，说明Jenkins已经安装成功。</p>

<p>进入后发现没有登录或者注册入口，然后就看到了stackoverflow上的<a href="http://stackoverflow.com/questions/10825614/how-can-i-add-a-username-and-password-to-jenkins">解决方案</a>: 系统管理 &ndash; Configure Global Security &ndash; 启用安全 — Jenkins专有用户数据库，允许用户注册 &ndash; 任何用户可以做任何事情。注册常用用户名和邮箱，然后就可以直接登录Jenkins。</p>

<h3>2. Jenkins Docker中安装Android 运行环境</h3>

<p>既然我们的Jenkins已经搭建完成，这一步我们则需要基于Jenkins安装Android的运行环境，如何在Ubuntu系统中通过命令行安装Android运行环境呢，主要参考<a href="https://www.digitalocean.com/community/tutorials/how-to-build-android-apps-with-jenkins">这篇文章</a>。</p>

<p>安装Android运行环境主要的流程为：</p>

<ol>
<li>下载Android SDK安装包 并设置环境变量.</li>
<li>下载platform-tools, Android SDK API, Android Build Tools.</li>
</ol>


<p>我这里安装Android SDK API版本为21，Build Tools版本号为21.1.2。</p>

<p>为了使Jenkins Android 环境能够在下次使用，我们通过新建 Dockerfile 的方式基于Jenkins来创建一个新的镜像，具体步骤如下：</p>

<ol>
<li><a href="https://registry.hub.docker.com/">Docker Hub</a>注册账号，用于存放自己的Repository。</li>
<li>新建Dockerfile文件，并添加配置信息。</li>
<li>运行Dockerfile，此时会执行Dockerfile中所配置的一系列命令。</li>
<li>提交Dockerfile生成的jenkins-android镜像。</li>
</ol>


<h4>配置Dockerfile</h4>

<p>```
FROM jenkins
MAINTAINER Ming Gong, <a href="&#x6d;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#103;&#x6f;&#110;&#103;&#x6d;&#105;&#x6e;&#x67;&#x71;&#109;&#x31;&#48;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#109;">&#x67;&#111;&#110;&#x67;&#109;&#105;&#110;&#103;&#x71;&#x6d;&#x31;&#48;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;</a>
USER root
RUN apt-get update &amp;&amp; apt-get -y install libstdc++6 lib32z1 lib32stdc++6 expect</p>

<p>RUN wget &mdash;progress=dot:giga <a href="http://dl.google.com/android/android-sdk_r24.1.2-linux.tgz">http://dl.google.com/android/android-sdk_r24.1.2-linux.tgz</a>
RUN mv android-sdk_r24.1.2-linux.tgz /opt/
RUN cd /opt &amp;&amp; tar xzvf ./android-sdk_r24.1.2-linux.tgz
ENV ANDROID_HOME /opt/android-sdk-linux/
ENV PATH $ANDROID_HOME/tools:$ANDROID_HOME/platform-tools:$PATH
RUN echo $PATH
RUN echo &ldquo;y&rdquo; | android update sdk -u &mdash;filter platform-tools,android-21
RUN echo &ldquo;y&rdquo; | android update sdk -u &mdash;all &mdash;filter 5
RUN chmod -R 755 $ANDROID_HOME</p>

<p>RUN apt-get install -y git-core
RUN android update sdk &mdash;no-ui</p>

<p>```</p>

<p>其中 <code>android update sdk -u --all --filter 5</code> 主要用来更新build-tools。在有android环境的机器上运行'android list sdk &mdash;all'可以查看所有的SDK信息，找到最新版本的build-tools，然后通过提供的最新版本号即可。</p>

<p>Dockerfile配置成功后，我们首先在Vagrant虚拟机里面，<code>mkdir /var/jenkins_home</code>，并给予所有权限 <code>chmod 777 /var/jenkins_home</code>。/var/jenkins_home 能够映射到Docker中的jenkins_home目录，方便我们直接备份jenkins数据。</p>

<h4>Build Dockerfile</h4>

<p>准备工作完成之后，build Dockerfile，首先切换到Dockerfile所在的当前目录下，</p>

<p>```
vagrant@ubuntu-14: sudo docker build -t gongmingqm10/jenkins-android:latest .</p>

<p>&hellip;</p>

<p>Successfully built 184c7dad595a</p>

<p>```</p>

<h4>Push Image</h4>

<p>最后输出的信息就是我们通过Dockerfile生成的新的镜像ID。构建完成之后我们需要commit并push这个镜像到docker hub的repository上。</p>

<p>```
vagrant@ubuntu-14:~/test$ sudo docker images
REPOSITORY                     TAG                   IMAGE ID            CREATED             VIRTUAL SIZE
gongmingqm10/jenkins-android       latest                184c7dad595a        11 minutes ago      188.3 MB</p>

<p>```
通过 docker images能够看到最新的镜像已经生成，这一步我们需要首先启动这个镜像，然后得到container ID，然后再PUSH 这个container。</p>

<p>首先启动镜像：</p>

<p>```
vagrant@ubuntu-14:~/test$ sudo docker run -t -i -d gongmingqm10/jenkins-android:latest
&hellip;</p>

<p>vagrant@ubuntu-14:~/test$ sudo docker ps
CONTAINER ID        IMAGE                              COMMAND                CREATED             STATUS              PORTS                               NAMES
43fcce2388fc        gongmingqm10/jenkins-adnroid:latest    /bin/bash              17 seconds ago      Up 16 seconds                                           determined_lumiere
vagrant@ubuntu-14:~/test$ sudo docker commit -m &ldquo;Add Android Config&rdquo; -a &ldquo;Ming Gong&rdquo; 43fcce2388fc gongmingqm10/jenkins-android:latest
75f1b93aedc4b57426b75c96ce69170016b3c0b0b6283cda5562f8464bbfd2f4
vagrant@ubuntu-14:~/test$ sudo docker push gongmingqm10/jenkins-android</p>

<p>```
首次push，可能会提示你输入自己的Docker Hub的用户名和密码。</p>

<h4>运行 jenkins-android</h4>

<p>```
sudo docker run &mdash;name jenkinsAndroid -p 8080:8080 -v /var/jenkins_home:/var/jenkins_home gongmingqm10/jenkins-android</p>

<p>```</p>

<p>我们使用jenkinsAndroid作为container的名字，注意这个名字也不能与已用的container 名字重复。运行一次之后，如果被自己停了，发现没有启动的话，可以使用 <code>sudo docker ps -a</code> 查看所有的container，然后找到 jenkinsAndroid这个名字的container对应的ID。启动之：</p>

<p>```
sudo docker start f6b88bdad68f</p>

<p>```</p>

<h4>访问 Jenkins</h4>

<p>在第一部分，我们直接使用Jenkins官方的Repository启动了Jenkins进行访问，经过这部分我们自己构建Dockerfile，添加了一些Android的运行环境，目的是给Android Test提供必要的运行环境。访问 <code>localhost:8088</code>可以访问这个具有Android环境的Jenkins。注册用户并登录，这一部分就完成了。</p>

<h3>4. Jenkins中配置Android Build</h3>

<p>通过访问<code>localhost:8088</code>，我们可以进入Jenkins控制台。为了使得Jenkins可以运行Android的单元测试和功能测试，主要安装如下插件：</p>

<p><code>git plugin</code>： 从 git repo 中 clone 代码</p>

<p><code>android emulator plugin</code>：Android运行功能测试时，能够帮助我们生成或者启动Android虚拟机</p>

<p><code>build monitor view</code>：全屏显示当前Build情况，适合投影到大屏幕上，方便所有人实时了解build情况</p>

<p>构建Functional test过程中，我希望通过android emulator pligin直接启动在container中已经新建的AVD。运行过程中却始终出错:</p>

<p>```
$ /opt/android-sdk-linux/tools/emulator -no-boot-anim -ports 9731,9732 -avd Nexus_5_API_21 -no-snapshot-load -no-snapshot-save -no-window
emulator: ERROR: Could not load OpenGLES emulation library: libX11.so.6: cannot open shared object file: No such file or directory
emulator: WARNING: Could not initialize OpenglES emulation, using software renderer.
emulator: warning: opening audio output failed</p>

<p>$ /opt/android-sdk-linux/platform-tools/adb connect localhost:9732
connected to localhost:9732
[android] Waiting for emulator to finish booting&hellip;
$ /opt/android-sdk-linux/platform-tools/adb -s localhost:9732 shell getprop init.svc.bootanim
error: device offline
$ /opt/android-sdk-linux/platform-tools/adb connect localhost:9732
$ /opt/android-sdk-linux/platform-tools/adb -s localhost:9732 shell getprop init.svc.bootanim
error: device offline
$ /opt/android-sdk-linux/platform-tools/adb connect localhost:9732
$ /opt/android-sdk-linux/platform-tools/adb -s localhost:9732 shell getprop init.svc.bootanim
error: device offline
$ /opt/android-sdk-linux/platform-tools/adb disconnect localhost:9732
$ /opt/android-sdk-linux/platform-tools/adb connect localhost:9732
$ /opt/android-sdk-linux/platform-tools/adb -s localhost:9732 shell getprop init.svc.bootanim
error: device offline
$ /opt/android-sdk-linux/platform-tools/adb connect localhost:9732
$ /opt/android-sdk-linux/platform-tools/adb -s localhost:9732 shell getprop init.svc.bootanim
error: device offline
$ /opt/android-sdk-linux/platform-tools/adb connect localhost:9732
$ /opt/android-sdk-linux/platform-tools/adb -s localhost:9732 shell getprop init.svc.bootanim
error: device offline
$ /opt/android-sdk-linux/platform-tools/adb disconnect localhost:9732
$ /opt/android-sdk-linux/platform-tools/adb connect localhost:9732
[android] Emulator was shut down before it finished booting
$ /opt/android-sdk-linux/platform-tools/adb disconnect localhost:9732
[android] Stopping Android emulator
$ /opt/android-sdk-linux/platform-tools/adb kill-server
Finished: NOT_BUILT</p>

<p>```
网上查了一下，主要是64位机器下运行32位emulator导致的一些问题。如果可以在一台都图形界面的机器上手动启动虚拟机，运行functional test的时候就应该不存在这个问题。此处先略过这个问题，后面会有专门的文章来研究这个问题。</p>

<p>在Jenkins中，建立的Build主要为 Android Unit Test &ndash; Android Functional Test &ndash; Android Deploy Hocky App.</p>

<p>通过Android的单元测试和功能测试基本可以保证App的功能处于正常状态；而Deploy到Hockey App则是为了持续集成的需要，我们要确保我们的App能够被实时生成，这样我们的产品就可以随时被测试并展示给客户，或者直接发布Hockey App 上某一个稳定的版本。</p>

<p>要想Jenkins能够直接将应用上传到HockeyApp上，我们只需要在Jenkins中安装<code>Hockey App Plugin</code>，然后通过注册Hockey App提供相应的API Token并进行简单配置，即可以直接通过Jenkins来上传发布我们的App。</p>

<h3>5. Android Flavor</h3>

<p>Android Flavor是为了Android在构建时使用不同的资源，类似于Ruby运行时可以设置不同的环境。</p>

<p>在app/build.gradle做如下配置：</p>

<p>```
android {</p>

<pre><code>defaultConfig{...}

productFlavors {
    dev {
        applicationId "com.tarcle.moment.dev"
    }
    qa {
        applicationId "com.tarcle.moment.qa"
    }
    production {
        applicationId "com.tarcle.moment"
    }

}

signingConfigs {
    release {...}
}

buildTypes {
    release {...}
}

packageOptions {...}
</code></pre>

<p>}</p>

<p>```</p>

<p>通过上面的配置，我们给APP添加了三种环境变量，于是可以直接在app目录下面新建<code>dev, qa, production</code>等文件夹。通过IDE中选择不同的Build variables，便可以在当前工程中使用什么环境的配置。</p>

<p>通过<code>./gradlew clean build 任务</code>， 能够在 <code>app/build/outputs/apk</code>等目录下生成不同环境下的Debug和Release包。而这里面的Release包则可以用来Jenkins中上传到Hockey App中。</p>

<p>配置Jenkins Build和Hockey App可能用到如下插件。对于不同的Flavor，我们可以在Deploy HockeyApp 的配置中添加Build Parameters，构建时我们可以自己选择不同类型的包。从而发布不同环境下的版本。</p>

<p><code>Copy Artifact Plugin</code> 从其他的Build中直接拷贝已经生成的APK文件包。</p>

<p><code>Android Lint Plugin</code> 构建后发布Lint Report。</p>

<h3>Other</h3>

<p>关于如何直接在虚拟机中，不使用Docker构建Android Build, 将会在另一篇博文中阐述。</p>

<p>如下是我们可能用到的关于Docker 和 Android的常用命令：</p>

<p><code>android list avd</code> 查看所有当前设备。</p>

<p><code>android create avd -f -a -s 1080x1920 -n Nexus_5_API_21 -t android-21</code> 创建API-21名为Nexus_5_API_21的emulator。</p>

<p><code>emulator -avd Nexus_5_API_21</code> 运行已创建的名为 Nexus_5_API_21的emulator，注意运行时命令行会一直处于阻塞中，所以可以在末尾加上 <code>&amp;</code> 让其进入后台运行。</p>

<p><code>adb devices</code> List of devices attached。</p>

<p><code>sudo docker exec -i -t a45953b9f2fe bash</code> 进入运行中的container的控制台</p>

<p><code>echo 'y' | apt-get install libgl1-mesa-dev</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Continuous Integration]]></title>
    <link href="http://www.gongmingqm10.net/blog/2015/03/09/android-continuous-integration/"/>
    <updated>2015-03-09T12:39:35+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2015/03/09/android-continuous-integration</id>
    <content type="html"><![CDATA[<p>随着Android平台的逐渐成熟，伴随着一系列针对Android测试框架的推出，开发人员终于可以如愿以偿的在移动端的开发上进行单元测试，集成测试以及功能测试。在敏捷流程中从开发，到测试，到验收最终成为面向用户的Release版本，经历的是Story一个完整的生命周期。CI(Continuous Integration, 持续交付)在敏捷实践中也因此扮演了非常重要的角色。</p>

<p>如果说Web的持续集成，以及各类测试框架有一定的历史积淀了。那么Android的持续集成可以说是新鲜事物，大部分IT公司知道如何对服务器端或者Web端进行一系列自动化测试，保证其功能的正确性。而对于移动端的产品比较多的则是由测试人员组成的人肉测试。移动端的这种人工测试，无论是对测试人员，还是要经常打包并且来修复各种Bug的开发人员来说，其代价是巨大的。</p>

<!-- more -->


<p>从Android 2.3.3 版本就开始，我就成为了Android的开发者。从开发者的角度见证了Android的步步升级，也从普通用户的角度见证了Android在中低端市场上的统治权。虽然我对Apple的产品也很满意，但是我对Android的感情却也是无法割舍的。我庆幸自己终于能够在Android上也见证测试驱动开发的实践，也庆幸自己有机会去亲身实践，从零开始学习并了解Android的持续集成。</p>

<h3>前言</h3>

<p>本文主要是从零开始，以学习者的角色来探索如何构建可用的Android CI环境。最后的目标是，在Jenkins上从build单元测试，到功能测试的运行，最后通过一键部署编译出可供QA测试的QA版本，可供Release的Release版本，并借助HockeyApp，生成可下载的链接。</p>

<ol>
<li>构建出一个含有单元测试和集成测试简单的App原型。</li>
<li>通过vagrant在本地运行Ubuntu虚拟机，并安装Jenkins服务器，在Ubuntu上安装配置Android运行环境。</li>
<li>在Jenkins中创建Android Pipeline, Android Build &ndash;> Android Functional Test &ndash;> Android Deploy Hockey App。</li>
<li>在Android工程中创建不同的环境变量，使得构建时能够选择不同的构建变量，编译生成QA和Release等不同环境下的App。</li>
</ol>


<h3>1. 构建Android基础工程，本地运行测试</h3>

<p>这里的基础工程主要指的是能够运行测试的基础功能，我选择使用Robolectric做单元测试，使用espresso做继承测试（后面的文章也会探讨使用）。基础工程主要参考了<a href="https://github.com/robolectric/deckard-gradle">robolectric/decard-gradle</a>, 通过一些gradlew的配置，使我们的工程能够直接运行单元测试和集成测试。</p>

<p>运行单元测试:</p>

<p>```
./gradlew test</p>

<p>```</p>

<p>运行espresso测试：</p>

<p><code>
./gradlew connectedAndroidTest
</code></p>

<p>一旦你这个实例运行成功，说明这一步其实已经完成。后面我们只需要通过jenkins来跑这几条命令，然后展示结果即可。</p>

<h3>2. 在虚拟机中安装Jenkins和Android环境</h3>

<p>为了从零开始，我选择了一台干净的Ubuntu/trusty机器，为了使构建从零开始，可以更好的模拟我们在EC2机器真实的情
形。从测试的角度来说，我选择使用<a href="https://www.vagrantup.com/">Vagrant</a>来启动虚拟机。</p>

<p><code>``
XiaoMing:ci minggong$ vagrant init ubuntu/trusty64
A</code>Vagrantfile<code>has been placed in this directory. You are now
ready to</code>vagrant up<code>your first virtual environment! Please read
the comments in the Vagrantfile as well as documentation on
</code>vagrantup.com` for more information on using Vagrant.
XiaoMing:ci minggong$ vagrant up
Bringing machine &lsquo;default&rsquo; up with &lsquo;virtualbox&rsquo; provider&hellip;
[default] Importing base box &lsquo;ubuntu/trusty64&rsquo;&hellip;
[default] Matching MAC address for NAT networking&hellip;
[default] Setting the name of the VM&hellip;
[default] Clearing any previously set forwarded ports&hellip;
[default] Fixed port collision for 22 => 2222. Now on port 2200.
[default] Creating shared folders metadata&hellip;
[default] Clearing any previously set network interfaces&hellip;
[default] Preparing network interfaces based on configuration&hellip;
[default] Forwarding ports&hellip;
[default] &mdash; 22 => 2200 (adapter 1)
[default] Booting VM&hellip;
[default] Waiting for machine to boot. This may take a few minutes&hellip;
[default] Machine booted and ready!
[default] Mounting shared folders&hellip;
[default] &mdash; /vagrant
XiaoMing:ci minggong$ vagrant ssh
Welcome to Ubuntu 14.04 LTS (GNU/Linux 3.13.0-24-generic x86_64)</p>

<ul>
<li>Documentation:  <a href="https://help.ubuntu.com/">https://help.ubuntu.com/</a>
Last login: Tue Apr 22 19:47:09 2014 from 10.0.2.2
```</li>
</ul>


<p>如果在Vagrantfile中已经设置了静态IP，则可以直接通过IP登陆。vagrant默认用户名为 <code>vagrant</code>, 密码为<code>vagrant</code>。</p>

<p>使用 <code>vagrant ssh</code> 登录虚拟机之后，则开始安装各种环境：</p>

<ul>
<li>Java</li>
<li>Jenkins</li>
<li>Android Environment</li>
</ul>


<h4>2.1 安装Java</h4>

<p>apt-get直接安装jdk1.7:</p>

<p>```
vagrant@ubuntu-14:~$ sudo apt-get update
vagrant@ubuntu-14:~$ sudo apt-get install openjdk-7-jdk -y
vagrant@ubuntu-14:~$ java -version
java version &ldquo;1.7.0_75&rdquo;
OpenJDK Runtime Environment (IcedTea 2.5.4) (7u75-2.5.4-1~trusty1)
OpenJDK 64-Bit Server VM (build 24.75-b04, mixed mode)</p>

<p>```</p>

<h4>2.2 安装Jenkins</h4>

<p>参考<a href="https://wiki.jenkins-ci.org/display/JENKINS/Installing+Jenkins+on+Ubuntu">Jenkins官方教程</a>:</p>

<p>```
wget -q -O &ndash; <a href="https://jenkins-ci.org/debian/jenkins-ci.org.key">https://jenkins-ci.org/debian/jenkins-ci.org.key</a> | sudo apt-key add &ndash;
sudo sh -c &lsquo;echo deb <a href="http://pkg.jenkins-ci.org/debian">http://pkg.jenkins-ci.org/debian</a> binary/ > /etc/apt/sources.list.d/jenkins.list&rsquo;
sudo apt-get update
sudo apt-get install jenkins -y</p>

<p><code>``
安装完Jenkins后，首先验证下Jenkins是否安装完毕,</code>curl <a href="http://localhost:8080">http://localhost:8080</a>`, 如果发现能够输出一堆HTML标签，那么证明Jenkins已经安装成功并已经启动了。Jenkins常见的使用命令如下，默认启动在8080端口：</p>

<p><code>
vagrant@ubuntu-14:~$ sudo /etc/init.d/jenkins -help
Usage: /etc/init.d/jenkins {start|stop|status|restart|force-reload}
</code>
Jenkins默认de配置文件为<code>/etc/default/jenkins</code>, 可以看到Jenkins_home定义的路径：</p>

<p><code>
 #jenkins home location
 JENKINS_HOME=/var/lib/jenkins
</code>
如果需要更改默认的Jenkins home 路径，需要更改 <code>/etc/default/jenkins</code>地址，然后重新启动jenkins即可生效。</p>

<h4>2.3 安装Android运行环境</h4>

<p>最后一步我们需要安装Android运行环境，这样我们的Jenkins才能够运行Android的相关测试。主要参考文章 <a href="https://www.digitalocean.com/community/tutorials/how-to-build-android-apps-with-jenkins">How to Build Apps with Jenkins</a></p>

<ul>
<li><a href="http://developer.android.com/sdk/index.html">Android SDK官网</a>找到最新的SDK安装包地址：<a href="http://dl.google.com/android/android-sdk_r24.1.2-linux.tgz,">http://dl.google.com/android/android-sdk_r24.1.2-linux.tgz,</a> 下载并解压：</li>
</ul>


<p>```
$ cd /opt
$ sudo wget <a href="http://dl.google.com/android/android-sdk_r24.1.2-linux.tgz">http://dl.google.com/android/android-sdk_r24.1.2-linux.tgz</a>
$ sudo tar zxvf android-sdk_r24.1.2-linux.tgz
$ sudo rm android-sdk_r24.1.2-linux.tgz</p>

<p>```</p>

<ul>
<li>设置Android环境变量：</li>
</ul>


<p>```
$ vi /etc/profile.d/android.sh</p>

<p>```</p>

<p>Add the following to android.sh file</p>

<p>```
export ANDROID_HOME=&ldquo;/opt/android-sdk-linux&rdquo;
export PATH=&ldquo;$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools:$PATH&rdquo;</p>

<p>```</p>

<p>然后 <code>source /etc/profile</code>， 使文件生效。</p>

<ul>
<li>配置 Android SDK</li>
</ul>


<p>最简单粗暴的方法是下载所有的SDK及相关的一系列工具，当然也可以挨个下载，具体参考上面提到的这篇文章。我采用直接更新全部的方法：</p>

<p>```
android update sdk &mdash;no-ui</p>

<p>```</p>

<p>经过漫长的等待，下载完毕之后这部分的工作也基本完成。(这一步一般留在半夜自行下载)</p>

<h4>2.4 安装Git</h4>

<p>为了使Jenkins能够直接从Git Repository上下载代码，需要在Ubuntu中安装Git:</p>

<p>```
sudo apt-get update
sudo apt-get install git -y</p>

<p>```</p>

<h4>2.5 配置Jenkins</h4>

<p>Jenkins启动后，首先注册登录用户，然后创建新的Build Project。构建就基本完成了。当然你也可以在前一篇博客 <a href="http://www.gongmingqm10.net/blog/2015/03/11/setup-jenkins-for-android-integration-using-docker/">Set up Jenkins for Android integration using Docker</a>中找到一些插件，通过这些插件能够更好的实现Android的持续集成，包括通过Hockey App 持续的发布新的版本。</p>

<p>具体安装细节，可以参考<a href="http://www.gongmingqm10.net/blog/2015/03/11/setup-jenkins-for-android-integration-using-docker/">Setup Android CI using Docker</a></p>

<p>粗略说来，安装插件: <code>Git plugin, Android emulator plugin, Copy artifact plugin, Android lint plugin, Hockey app plugin, Build monitor plugin</code></p>

<p>运行时发现jenkins用户对jenkins-home目录没有操作权限，需要通过chmod增加权限。在当前vagrant用户下，<code>su jenkins</code> 能够切换到jenkins目录下，但是需要提供密码。所以可以自行修改密码：</p>

<p><code>
vagrant@ubuntu-14:/var/lib/jenkins$ sudo passwd jenkins
Enter new UNIX password:
Retype new UNIX password:
passwd: password updated successfully
vagrant@ubuntu-14:/var/lib/jenkins$ su jenkins
Password:
jenkins@ubuntu-14:~$
</code>
权限设置成功后，再次运行测试，提示Android Build Tools没有安装成功：</p>

<p>```
+ ./gradlew clean build</p>

<p>FAILURE: Build failed with an exception.</p>

<ul>
<li>What went wrong:
A problem occurred configuring project &lsquo;:app&rsquo;.

<blockquote><p>failed to find Build Tools revision 21.1.2</p></blockquote></li>
</ul>


<p>```</p>

<p>Android Build Tools的版本号是我们在app/build.gradle中指定的21.1.2。通过 <code>android list sdk --all</code>能够查看所有可以下载的sdk列表。</p>

<p>```
Packages available for installation or update: 138
   1- Android SDK Tools, revision 24.1.2
   2- Android SDK Platform-tools, revision 22
   3- Android SDK Build-tools, revision 22.0.1
   4- Android SDK Build-tools, revision 22 (Obsolete)
   5- Android SDK Build-tools, revision 21.1.2
   6- Android SDK Build-tools, revision 21.1.1 (Obsolete)
   7- Android SDK Build-tools, revision 21.1 (Obsolete)
   8- Android SDK Build-tools, revision 21.0.2 (Obsolete)
   9- Android SDK Build-tools, revision 21.0.1 (Obsolete)</p>

<p>```</p>

<p>可以看到21.1.2的索引值是5，所以可以使用 <code>android update sdk -u --all --filter &lt;number&gt;</code>更新，发现出现权限问题。</p>

<p><code>
Installing Archives:
  Preparing to install archives
  Downloading Android SDK Build-tools, revision 21.1.2
  URL not found: /opt/android-sdk-linux/temp/build-tools_r21.1.2-linux.zip (Permission denied)
  Done. Nothing was installed.
</code>
可以直接在当前用户下给/opt/android-sdk-linux以及其子文件夹增加777权限。</p>

<p><code>
sudo chmod -R 777 /opt/android-sdk-linux
</code>
然后安装Android build tools 21.1.2, <code>android update sdk -u --all --filter 5</code>。安装完成后还可能会出现错误:</p>

<p>```
:app:mergeDevDebugResources FAILED</p>

<p>FAILURE: Build failed with an exception.</p>

<ul>
<li>What went wrong:
Execution failed for task &lsquo;:app:mergeDevDebugResources&rsquo;.

<blockquote><p>Error: org.gradle.process.internal.ExecException: A problem occurred starting process &lsquo;command &rsquo;/opt/android-sdk-linux/build-tools/22.0.1/aapt'&lsquo;
```</p></blockquote></li>
</ul>


<p>Google了一番，才发现是Android在64为Linux机器上运行而产生的问题，需要安装<code>ia32-libs</code>, 但是通过apt安装确被告知ia32-libs不存在，无法安装。<a href="http://stackoverflow.com/questions/23182765/how-to-install-ia32-libs-in-ubuntu-14-04-lts-trusty-tahr">stackoverflow</a>解决办法如下：</p>

<p><code>
sudo -i
cd /etc/apt/sources.list.d
echo "deb http://old-releases.ubuntu.com/ubuntu/ raring main restricted universe multiverse" &gt;ia32-libs-raring.list
apt-get update
apt-get install ia32-libs
</code>
安装成功后，Android 单元测试即可成功运行。</p>

<p>单元测试之后，我们往往需要运行功能测试，功能测试的时候则需要打开模拟器。也就是 headless android emulator。首先在虚拟机中创建 avd, 然后启动运行模拟器。</p>

<p>运行之前需要先安装 API-21对应的 armeabi-v7a， 才能够创建虚拟机。通过查看<code>android list sdk --all</code>得知其对应的序列号是68，所以可以通过android update安装：</p>

<p><code>
android update sdk -u --all --filter 68
</code>
安装完成后创建API-21虚拟机：</p>

<p><code>
android create avd -f -a -s 1080x1920 -n Nexus-21 -t android-21 --abi
</code>
虚拟机创建成功后需要打开虚拟机：</p>

<p><code>
emulator -avd Nexus-21 -no-skin -no-audio -no-window
</code>
顺利的话，到这里功能测试应该也能够运行了。但是在我的虚拟机里面却没办法启动android emulator。看来想构建真正的android功能测试，还是用一台配有显示器的Mac mini来运行比较的靠谱。</p>

<h3>3.Other</h3>

<p>如何在Android中配置不同的Flavor，如何上传构建好的App到HockeyApp中。欢迎查看我的<a href="http://www.gongmingqm10.net/blog/2015/03/11/setup-jenkins-for-android-integration-using-docker/">博客</a>。</p>
]]></content>
  </entry>
  
</feed>
