<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | gongmingqm10]]></title>
  <link href="http://www.gongmingqm10.net/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://www.gongmingqm10.net/"/>
  <updated>2015-12-27T23:46:12+08:00</updated>
  <id>http://www.gongmingqm10.net/</id>
  <author>
    <name><![CDATA[Gong Ming]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android 转屏那些事儿]]></title>
    <link href="http://www.gongmingqm10.net/blog/2015/12/16/you-should-know-about-android-rotate/"/>
    <updated>2015-12-16T15:39:43+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2015/12/16/you-should-know-about-android-rotate</id>
    <content type="html"><![CDATA[<p>在 Android 开发或面试过程中，屏幕旋转是一个容易让人忽视的知识点。在我之前经历的项目中，App 通常是为竖屏状态设置的，所以通常我们会对每个页面都设置竖屏方向，这时候我们不需要考虑旋转屏问题。但是最近项目中，我们的 App 是为平板设计的，而横竖屏旋转是属于客户的一个需求，当然平板上横竖屏的确比较常用。所以就借此机会研究了下 Android 横竖屏问题。</p>

<p><img src="http://7xj9js.com1.z0.glb.clouddn.com/portrait_landscape.png" width="500" alt="Android 横竖屏" /></p>

<!-- More -->


<p>横竖屏之所以需要引起开发者的注意，是因为 App 在横竖屏切换的过程中，页面会重绘，那么页面上已有的数据（比如登录页面已经输入的用户名）如何保存成为了一个问题。按照官方的推荐，Activity本身的确有处理旋转屏事件的函数，但是当一个页面中需要保存的数据很多的时候（比如很多 EditText），还是手工处理，就显得有些繁琐了。下面我们将循序渐进地探索 Android 屏幕旋转之最佳实践。</p>

<h2>Activity 旋转中的保存与恢复</h2>

<p>在解决问题或者探索最佳实践的时候，我们可以从简单的问题入手，慢慢衍生至复杂的情形，最后再抽象出一些比较通用的解决方案。这一步我们单纯的探索一个 Activity（没有 Fragment）的数据保存与恢复。</p>

<h3>Activity 的生命周期</h3>

<p>Activity 从创建到呈现在用户面前到消亡，有着自己完整的生命周期：</p>

<p><img src="http://7xj9js.com1.z0.glb.clouddn.com/activity_lifecycle.png" width="500" alt="Activity 生命周期" /></p>

<p>旋转屏幕时，打印相关 Log 如下：</p>

<p><img src="http://7xj9js.com1.z0.glb.clouddn.com/activity_rotate_cycle.png" width="600" alt="Activity 旋转中的生命周期" /></p>

<p>从 Log 可以看到，在屏幕旋转时，原来的 Activity 调用了 onDestroy，随后重新实例化了一个 MainActivity。重新实例化的 MainActivity 也会经历 “onCreate &ndash;> onStart &ndash;> onResume” 的生命周期。</p>

<h3>Activity 中窗口保存与恢复</h3>

<p>为了进一步探索 Activity 在旋转屏过程中的数据保存及恢复的逻辑，我们构造了一个具有用户名和密码的登录界面。当用户在用户名中输入用户名时，这时候旋转屏幕，此时期望的操作应该是输入的用户名仍然能够保留：</p>

<p><img src="http://7xj9js.com1.z0.glb.clouddn.com/activity_login.png" width="400" alt="Activity Login 页面" /></p>

<p>在不添加任何额外代码的情况下，我们可以看到输入框中的数据在旋转屏后仍然能够保留，这些控件基本状态的值是如何被保留的呢？</p>

<p>Activity 中方法 <code>protected void onSaveInstanceState(Bundle outState) {...}</code> 主要做状态保存相关的处理，如果我们有需要特地保存的变量等，我们可以在 <code>onSaveInstanceState</code> 中保存，保存后的 bundle 以 outState Bundle 的格式保存。当 Activity 再次被初始化时，<code>onCreate(Bundle savedInstanceState)</code> 会将保存的 bundle 传递给 Activity 主页面，Activity 主页面接收到这些状态保存的数据后，能够根据保存中的控件的ID信息，状态数据等对页面进行自动的初始化。当我们转屏时，会主动触发 <code>onSaveInstanceState</code> 被调用。Log 打印如下：</p>

<p><img src="http://7xj9js.com1.z0.glb.clouddn.com/activity_onrestore_data.png" width="600" alt="Activity onSaveInstanceState &amp; onRestoreInstanceState" /></p>

<p>根据 Log 很明确看出在旋转屏之后，随着 onPause 的执行，<code>onSaveInstanceState</code> 也被执行。当 Activity 再次初始化时，<code>onCreate(Bundle savedInstanceState)</code> 会传递回一个非空的 savedInstanceState（而当 Activity 第一次初始化时此值为空），同时 <code>onRestoreInstanceState</code> 也会被调用，用来将保存的窗口状态信息重新应用：</p>

<p>生命周期：<code>onCreate</code> &ndash;> <code>onStart</code> &ndash;> <code>onResume</code> &ndash;> Running 转屏 &ndash;> <code>onPause</code> &ndash;> <code>onSaveInstanceState</code> &ndash;> <code>onStop</code> &ndash;> <code>onDestroy</code> &ndash;> <code>onCreate</code> &ndash;> <code>onStart</code> &ndash;> <code>onRestoreInstanceState</code> &ndash;> <code>onResume</code>;</p>

<p><img src="http://7xj9js.com1.z0.glb.clouddn.com/activity_savedInstanceState.png" width="600" alt="Android savedInstanceState" /></p>

<p>通过对 <code>savedInstanceState</code> 的查看，发现 savedInstanceState 中包含有 Key 为 <code>android:viewHierarchyState</code> 的 bundle 数据，此 bundle 数据具体内容如下：</p>

<p>```
Bundle[{android:views={</p>

<pre><code>    16908290=android.view.AbsSavedState$1@347440f8,         2131492927=android.view.AbsSavedState$1@347440f8,       2131492928=android.view.AbsSavedState$1@347440f8,       2131492929=android.support.v7.widget.Toolbar$SavedState@391b69d1,       2131492930=android.view.AbsSavedState$1@347440f8,       2131492944=TextView.SavedState{138fec36 start=8 end=8 text=gongming},       2131492945=TextView.SavedState{16043737 start=0 end=0 text=},       2131492946=android.view.AbsSavedState$1@347440f8
},
android:focusedViewId=2131492944}
</code></pre>

<p>]
```
可以看到 username 的输入框 EditText，其 ID 以及当前的值都已经保存至 savedInstanceState 中。</p>

<p>那么，对于 Activity.java 的而言，最重要的保存数据和恢复数据的源代码如下：</p>

<p>```</p>

<pre><code>private static final String WINDOW_HIERARCHY_TAG = "android:viewHierarchyState";

protected void onSaveInstanceState(Bundle outState) {
    outState.putBundle(WINDOW_HIERARCHY_TAG, mWindow.saveHierarchyState());
    Parcelable p = mFragments.saveAllState();
    if (p != null) {
        outState.putParcelable(FRAGMENTS_TAG, p);
    }
    getApplication().dispatchActivitySaveInstanceState(this, outState);
}

protected void onRestoreInstanceState(Bundle savedInstanceState) {
    if (mWindow != null) {
        Bundle windowState = savedInstanceState.getBundle(WINDOW_HIERARCHY_TAG);
        if (windowState != null) {
            mWindow.restoreHierarchyState(windowState);
        }
    }
}
</code></pre>

<p>```
这就是为什么我们没有做过多的处理却可以让 App 在旋转屏幕时仍然自动保存恢复输入框中的文字。</p>

<h3>Activity 中数据保存与恢复</h3>

<p>既然 Activity 本身对窗口（控件）的状态信息进行了保存及恢复处理。那么我们在屏幕切换时最应该关心的就是页面数据的保存与恢复。页面数据主要有两种：</p>

<ul>
<li>API 请求的数据：在横竖屏切换时对API数据进行保存及恢复能够防止 API 的重复调用；</li>
<li>页面中的状态值：在 Activity 运行过程中被改变的状态值，在恢复时需要手动保存及恢复，以便不影响状态值相关的页面逻辑；</li>
</ul>


<p>在 Activity 中进行变量的存储及读取时，使用 <code>onSaveInstanceState</code> 进行数据的存储，使用 <code>onRestoreInstanceState</code> 进行数据的读取：</p>

<p>```</p>

<pre><code>private boolean shouldSaveData = false;

private static final String KEY_SHOULD_SAVE_DATA = "save_data_key";

@Override
protected void onSaveInstanceState(Bundle outState) {
    outState.putBoolean(KEY_SHOULD_SAVE_DATA, shouldSaveData);
    super.onSaveInstanceState(outState);

    Log.i(TAG, "@@Activity onSaveInstanceState@@" + this.toString());
}

@Override
protected void onRestoreInstanceState(Bundle savedInstanceState) {
    super.onRestoreInstanceState(savedInstanceState);
    shouldSaveData = savedInstanceState.getBoolean(KEY_SHOULD_SAVE_DATA);
    Log.i(TAG, "@@Activity onRestoreInstanceState@@" + this.toString());
}
</code></pre>

<p>```</p>

<h3>Activity 中弹框的状态保存及恢复</h3>

<p>在 Activity 中经常会遇到 Dialog，甚至像下面具有输入框的 Dialog：</p>

<p><img src="http://7xj9js.com1.z0.glb.clouddn.com/activity_signature_dialog.png" width="400" alt="Android Dialog" /></p>

<p>当用户点击 Login 按钮，弹出弹框需要用户签名，这时如果屏幕不小心进行了一次旋转，那么这个弹出的 Dialog 便消失，随之消失的还有用户输入了一半的输入框文字。Activity 在旋转过程中对于 Dialog 自身的生命周期进行很好的管理，如果为了达到更好的用户体验，转屏时也需要保存输入框状态，那么此处我们强烈推荐用户使用 <a href="http://developer.android.com/reference/android/app/DialogFragment.html">DialogFragment</a> 代替 Dialog。</p>

<p>由于 Fragment 也具有生命周期，使用 DialogFragment 之后，我们结合 Activity 与 Fragment 的生命周期，查看整个过程经历了哪些流程。</p>

<p><img src="http://7xj9js.com1.z0.glb.clouddn.com/fragment_lifecycle.png" width="300" alt="Frgament 生命周期" /></p>

<p>结合 DialogFragment 在 Activity 中旋转的重新初始化及数据恢复，我们可以看到执行顺序如下：</p>

<p><img src="http://7xj9js.com1.z0.glb.clouddn.com/activity_fragment_rotate.png" width="500" alt="Android Fragment 执行顺序" /></p>

<p>在转屏时，Activity 和 Fragment 都会重新实例化，并且都通过 <code>onSaveInstanceState</code> 进行状态保存。值得注意的是不同于 Activity, Fragment 并没有 <code>onRestoreInstanceState</code> 方法，Fragment 的状态恢复在 <code>onActivityCreated</code> 方法中。查看 DialogFragment 源码，我们可以看到如下调用：</p>

<p>```</p>

<pre><code>@Override
public void onActivityCreated(Bundle savedInstanceState) {
    super.onActivityCreated(savedInstanceState);
    ...
    if (savedInstanceState != null) {
        Bundle dialogState = savedInstanceState.getBundle(SAVED_DIALOG_STATE_TAG);
        if (dialogState != null) {
            mDialog.onRestoreInstanceState(dialogState);
        }
    }
}

...

@Override
public void onSaveInstanceState(Bundle outState) {
    super.onSaveInstanceState(outState);
    if (mDialog != null) {
        Bundle dialogState = mDialog.onSaveInstanceState();
        if (dialogState != null) {
            outState.putBundle(SAVED_DIALOG_STATE_TAG, dialogState);
        }
    }
    ...
}
</code></pre>

<p>```</p>

<p>由于 DialogFragment 其实就是展示一个 Dialog，而 DialogFragment 对 Dialog 的状态保存及恢复使得 Dialog 的状态得以保存。</p>

<h2>Fragment 状态的保存及恢复</h2>

<p>有了上面对 DialogFragment 转屏时状态保存及恢复的研究，那么在一个普通的 Fragment(DialogFragment 是一种特殊的 Fragment) 中状态保存及恢复又是怎样的呢？</p>

<p>实际上通过 DialogFragment 我们可以知道保存状态值还是通过 <code>onSaveInstanceState</code> 方法，而 <code>onActivityCreated</code> 中则可以获取状态值。</p>

<p>在转屏时，我们会有很多特殊的考虑。所以如果你的 App 需要支持横竖屏切换，你可以留意如下几点：</p>

<h3>1. Dialog 转屏消失问题</h3>

<p>Dialog 转屏消失在现实中是一个很常见的情形，对应的解决方案就是利用 DialogFragment 来替代 Dialog。这样旋转屏幕时弹起的 Dialog 就不会消失。</p>

<h3>2. Fragment 保存组件信息的坑</h3>

<p>最近在项目中发现，有时候放置在 Fragment 中的 ListView 转屏后不能自动回到转屏之前的位置。后来发现导致原因是 Activity 的 Layout 在添加 Fragment 时候没有指定 id 或 tag。于是该 Fragment 在 Activity 重绘时不能被系统当作 “同一个” Fragment，所以旋转时控件的一些基本状态信息没办法恢复。</p>

<p>```
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;utf-8&rdquo;?>
&lt;fragment xmlns:android=&ldquo;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&rdquo;</p>

<pre><code>android:id="@+id/home_fragment"
android:layout_width="match_parent"
android:layout_height="match_parent" android:paddingLeft="@dimen/activity_horizontal_margin"
android:paddingRight="@dimen/activity_horizontal_margin"
android:paddingTop="@dimen/activity_vertical_margin"
android:paddingBottom="@dimen/activity_vertical_margin"
android:name="net.gongmingqm10.androidrotate.HomeFragment" /&gt;
</code></pre>

<p><code>``
其中的</code>android:id=&ldquo;@+id/home_fragment&rdquo;` 是重点。一旦 Fragment 的状态保存出现问题，可先确认 Fragment 是不是设置了 id 或 tag。</p>

<h3>3. 使用 setRetainInstance</h3>

<p>关于 Fragment，我们发现 <code>setRetainInstance</code> 方法经常被用到，那么这个方法的作用是什么呢？我们看看官方的解释：</p>

<p>```</p>

<pre><code>/**
 * Control whether a fragment instance is retained across Activity
 * re-creation (such as from a configuration change).  This can only
 * be used with fragments not in the back stack.  If set, the fragment
 * lifecycle will be slightly different when an activity is recreated:
 * &lt;ul&gt;
 * &lt;li&gt; {@link #onDestroy()} will not be called (but {@link #onDetach()} still
 * will be, because the fragment is being detached from its current activity).
 * &lt;li&gt; {@link #onCreate(Bundle)} will not be called since the fragment
 * is not being re-created.
 * &lt;li&gt; {@link #onAttach(Activity)} and {@link #onActivityCreated(Bundle)} &lt;b&gt;will&lt;/b&gt;
 * still be called.
 * &lt;/ul&gt;
 */
</code></pre>

<p><code>``
结合方法名以及方法的解释，可以知道一旦我们设置</code>setRetainInstance(true)<code>，意味着在 Activity 重绘时，我们的 Fragment 不会被重复绘制，也就是它会被“保留”。为了验证其作用，我们发现在设置为</code>true<code>状态时，旋转屏幕，Fragment 依然是之前的 Fragment。而如果将它设置为默认的 false，那么旋转屏幕时 Fragment 会被销毁，然后重新创建出另外一个 fragment 实例。并且如官方所说，如果 Fragment 不重复创建，意味着 Fragment 的</code>onCreate<code>和</code>onDestroy<code>方法不会被重复调用。所以在旋转屏 Fragment 中，我们经常会设置</code>setRetainInstance(true)`，这样旋转时 Fragment 不需要重新创建。</p>

<p>如果你的 App 恰好可以不做转屏，那么你可以很省事的在 Manifest 文件中添加标注，强制所有页面使用竖屏/横屏。如果你的页面不幸的需要支持横竖屏切换，那么你在预估工作量或者给客户报价时一定要考虑到。虽然加入转屏支持不会导致工作量翻倍，但是却有可能引起许多问题。尤其当页面有很多业务逻辑，有状态值的时候。所以我们在项目开发过程中，应该知道什么时候需要考虑状态保存，当状态保存出现问题时，应该怎么解决之。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android 新手成长计划]]></title>
    <link href="http://www.gongmingqm10.net/blog/2015/11/30/android-xin-shou-jiao-cheng/"/>
    <updated>2015-11-30T21:17:42+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2015/11/30/android-xin-shou-jiao-cheng</id>
    <content type="html"><![CDATA[<p><img src="http://www.webmastergrade.com/wp-content/uploads/2011/04/Android-VS-Apple.jpg" width="500" alt="Android starter" /></p>

<p>最近在公司里开始遇到了新人培养的问题，新人被 assign 到 Android 项目上，为了让他能够很快有所产出，于是我们得思考怎么样快速锻炼一个新人并让他对 Android 开发产生兴趣并持续做下去呢？当然也会有一时兴起的同事会想着学习 Android，Android 入门门槛不高，但是要想真正的熟练驾驭，确实是一件道阻且长的事情，需要付出额外的努力。</p>

<!-- more -->


<h2>兴趣驱动法则</h2>

<p>其实“兴趣”不只是在 Android 开发上体现的重要，兴趣在任何地方都是最重要的。之前接触过一些朋友，某次会突然告诉我想学习 Android，但是往往一个 Hello World 都可以将之难倒。这时候学习者明显缺少兴趣驱动。Android 开发好玩的一点是我们开发的应用都可以很简单的在手机上安装使用。所以你可以尽情尝试各种新奇的点子。</p>

<p>当然，兴趣并不是本文讨论的重点，我们假设真心想学习的人都是出于兴趣。</p>

<h2>循序渐进的练习计划</h2>

<p>有了兴趣远远还不够，兴趣只能促使你完成一个 Hello World，要想真正做出东西还应该有循序渐进的计划来配合。我当时学习 Android 的方法就是每周一个任务。把学习新知识当作升级打怪，这样子你还会松懈吗？</p>

<h3>你应该掌握的 Android 开发知识</h3>

<p>Android 开发的入门门槛不高，但是细节知识真心不少。作为初学者，我们可以先了解广度，然后了解深度。刚开始可以接触尝试了解一点远离性的知识，然后直接运用一些流行的框架。快速迭代完成一个 App。那么对于新手而言，应该掌握的 Android 开发知识有哪些呢？</p>

<h4>1. Hello Android</h4>

<p>开发调试基础看起来比较模糊，具体一点是完成一个 Hello World，让此应用运行在你的手机或者模拟器中。借此了解各个文件夹模块的作用以及 App 运行的基础原理。涵盖知识点如下：</p>

<ul>
<li>搭建 Android 开发环境： Java + Android Studio + SDK；</li>
<li>熟悉项目结构：src, res, assets, values, layouts, drawable/mipmap, styles, AndroidManifest.xml, Activity；</li>
<li>解读 Hello World 运行机制：项目从哪里运行，Activity 与 layout 的关联，Activity 中如何找到布局中的实例化控件，Activity 的生命周期；</li>
</ul>


<h4>2. 计算器</h4>

<p>计算器的经典程度不亚于 Hello World，Android 计算器能够让初学者迅速建立信心，同时作为一个单纯的无网络交互的应用，计算器主要处理布局，点击事件，计算逻辑。因此在了解了 Hello World 之后做计算器，再合适不过了。计算器最终效果图如下：</p>

<p><img src="http://7xj9js.com1.z0.glb.clouddn.com/calculator.png" width="300" alt="计算器" /></p>

<p>那么对于计算器这个 demo 的要求如下：</p>

<ul>
<li>界面效果如上图，并且能够进行简单的整数运算：<code>1+1, 4*2, 6/3, 1-10</code> 等；</li>
<li>异常处理，除数为 0 时界面提示 <code>Error</code>；</li>
<li>小数点以及连续运算的支持；</li>
<li>继承 Robolectric 添加单元测试；</li>
<li>每次打开 App 结果栏会自动显示上一次的运算结果；</li>
<li>添加<code>History</code>菜单，点击列表显示历史计算表达式以及结果；</li>
</ul>


<p>通过这些要求，涵盖的知识点如下：</p>

<ul>
<li>布局管理器的了解及使用：RelativeLayout, LinearLayout；</li>
<li>Android 控件添加点击事件，TextView 动态设值；</li>
<li>Android 项目集成 Robolectric，添加简单的单元测试；</li>
<li>Android 数据持久化保存 &ndash; SharedPreferences；</li>
<li>Android 数据持久化存储 &ndash; Sqlite 数据库；</li>
<li>Android ListView 列表及数据绑定；</li>
<li>Android Activity 跳转 &ndash; Intent；</li>
<li>添加 <a href="http://jakewharton.github.io/butterknife/">ButterKnife</a> 框架，重构项目；</li>
<li>添加 <a href="http://greenrobot.org/greendao/">GreenDao</a> 框架，重构数据库数据存储及读取；</li>
</ul>


<h4>3. 豆瓣图书列表 &ndash; 图片缓存</h4>

<p>豆瓣图书列表最初起源于公司内部的一次 Android 培训，由于对 Android 初学者而言，还比较有意义，于是设置为专题的形式供大家练习。需求很简单，将给定的图书列表数据(JSON 格式)显示到界面上。包括图书信息在列表中展示，网络图片的加载以及缓存。JSON 数据<a href="http://7xj9js.com1.z0.glb.clouddn.com/douban-books.json">点击此处</a>查看。完成之后效果图如下：</p>

<p><img src="http://7xj9js.com1.z0.glb.clouddn.com/douban-reading.png" width="300" alt="Douban Books" /></p>

<p>具体要求如下：</p>

<ul>
<li>列表显示图书信息：图书图片，名称，作者／出版社／出版年份，评价，简介；</li>
<li>多次滑动列表，保证文字以及图片显示不会发生错位，并且始终流畅（有列表控件重用）；</li>
<li>添加图片缓存：图片加载成功后，断开网络，退出 App，打开应用仍然能够正确显示图片；</li>
</ul>


<p>通过这些要求我们期望初学者掌握的技能点如下：</p>

<ul>
<li>Android ListView 自定义列表样式；</li>
<li>Android Adapter 使用 ViewHolder 进行控件复用；</li>
<li>Android 主线程（UI线程）的概念，主线程阻塞的解决方案，Handler 的概念以及使用方法；</li>
<li>图片缓存的应用，内存级别的缓存以及磁盘级别的缓存；</li>
<li>使用 <a href="http://square.github.io/picasso/">Picasso</a>/<a href="https://github.com/nostra13/Android-Universal-Image-Loader">ImageLoader</a> 图片加载及缓存框架，简化开发；</li>
</ul>


<p>如果你对图片缓存部分的实现有任何疑惑，请参考工程 <a href="https://github.com/gongmingqm10/AndroidWorkshop/tree/2nd-step4">AndroidWorkShop</a>。图片磁盘缓存部分参考了 Android 官方教程。</p>

<h4>4. 豆瓣图书列表 &ndash; 网络请求</h4>

<p>这个任务其实是对第 3 条任务的改造。不同之处在于，本次任务侧重于让初学者了解如何快速构建出一个有网络请求模块的 App。我们的效果图和上一条任务的相同，不同点在于本次我们会使用真实的网络API数据。并且会对 API 请求回来的数据进行缓存。具体要求如下：</p>

<ul>
<li>推荐使用 <a href="http://square.github.io/retrofit/">Retrofit</a> 框架，从豆瓣读书 API 网络获取<a href="https://api.douban.com/v2/book/search?q=Java">图书列表</a>及<a href="http://api.douban.com/v2/book/2130190">图书详情</a>。详情参见<a href="http://developers.douban.com/wiki/?title=guide">豆瓣API</a>；</li>
<li>列表显示豆瓣图书列表，图片显示可直接使用 Picasso；</li>
<li>点击 Item 跳转至图书详情界面，显示该书籍详细信息；</li>
<li>缓存此 API 的搜索结果 (文件或者数据库Key-Value的形式缓存JSON数据)；</li>
<li>使用 SwipeRefreshLayout 添加下拉刷新功能，下拉刷新时重新添加请求数据并更新缓存；</li>
</ul>


<p>此任务我们期望初学者掌握的知识点：</p>

<ul>
<li>Retrofit 框架的使用；</li>
<li>Android 数据缓存的简易实现方案（数据库／文件形式）；</li>
<li>简单的列表点击事件，页面跳转等；</li>
<li><a href="http://android-developers.blogspot.com/2015/05/android-design-support-library.html">Android Design Support Library</a> 中常用的组件及使用；</li>
</ul>


<h4>5. 设计并实现你自己的 App</h4>

<p>如果你顺利完成了上述四条任务，那么这一步你应该已经具备了完成一个简单的 App 的技能，这一步可以按照个人兴趣完成自己的创意点子。在开始编码之前，可以先制作出一套 UI 交互图，然后整理 API 并开始编码。</p>

<h3>Android 学习常用的链接</h3>

<p>Android 拥有全面的官方学习教程以及各种丰富的开源库。我们初学时可以多浏览官方教程学习一些好的实现，下面列举了一些很常用的链接：</p>

<ol>
<li><a href="developer.android.com/training/index.html">Android 官方文档</a></li>
<li><a href="http://android-developers.blogspot.com/">Android 官方博客</a></li>
<li><a href="www.google.com/design/spec/style/color.html#">Google Material Design</a></li>
<li><a href="http://square.github.io/">Square Open Source</a></li>
<li><a href="http://jakewharton.com/">Jake Wharton 的博客</a></li>
</ol>


<p>全文很多观点都是一家之言，更多的是结合自己的项目经验以及学习经验总结而成，如有谬误及不当之处，请读者不吝赐教。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Adapter notifyDataSetChanged Not Working]]></title>
    <link href="http://www.gongmingqm10.net/blog/2015/11/29/android-adapter-notifydatasetchanged-not-working/"/>
    <updated>2015-11-29T11:30:39+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2015/11/29/android-adapter-notifydatasetchanged-not-working</id>
    <content type="html"><![CDATA[<p>刚开发 Android 开发时，总是遇到一个看似很简单的问题 “Android Adapter notifyDataSetChanegd 不生效”，而每次解决这个问题的方法总是简单粗暴，直接了当。大概是以前的时候做事以结果导向，所以对于这些奇怪的问题也总是没有深究。刚好最近在项目中再次遇到了这个问题，决心深究一下。</p>

<p><img src="http://7xj9js.com1.z0.glb.clouddn.com/Its_not_working_anymore.png" width="500" alt="notifyDataSetChanged not working" /></p>

<!-- more -->


<h3>Adapter notifyDataSetChanged 做了什么事</h3>

<p>要弄清楚 <code>adapter.notifyDataSetChanged</code> 为什么不工作，还是应该首先弄清楚它究竟做了什么事情。根据函数名的描述，主要是通知 “数据源改变”，从而刷新页面，这样新改变的数据就呈现在用户面前了。</p>

<p>Android Adapter 使用了观察者模式，每一个 ListView 可以实例化出一个 Observer，而每个 Adapter 则会实例化出一个 Subject。在 ListView setAdapter 的时候，Adapter 会将 ListView 中实例化的 Observer 注册入观察者列表中。当 Adapter 通过观察者更新时，则会调用 Observer 的 notifyChanged() 方法，如此重新刷新 ListView 的界面。</p>

<p>这个通知者模式的 UML 关系图大致可以描述如下：</p>

<p><img src="http://7xj9js.com1.z0.glb.clouddn.com/adapter%20obervable%20pattern.png" width="500" alt="notifyDataSetChanged not working" /></p>

<p>继续查看 ListView.setAdapter 方法，可以看到在设置 Adapter 的时候，ListView 会将自己的 Observer 注册入 Subject:</p>

<p>```</p>

<pre><code>@Override
public void setAdapter(ListAdapter adapter) {
    if (mAdapter != null &amp;&amp; mDataSetObserver != null) {
        mAdapter.unregisterDataSetObserver(mDataSetObserver);
    }

    ...

    super.setAdapter(adapter);

    if (mAdapter != null) {
        ...
        mDataSetObserver = new AdapterDataSetObserver();
        mAdapter.registerDataSetObserver(mDataSetObserver);

        ...
        }
    }

    ...
}
</code></pre>

<p>```</p>

<h3>为什么 notifyDataSetChanged 生效</h3>

<p>既然 <code>notifyDataSetChanged</code> 能够促使 ListView 重绘界面，那么让其生效的方式就是保证 Adapter 中的数据源生效，这样在 ListView 重绘时才能使用新的数据刷新界面。看下面一段失效的 ListView 更新失效的问题。</p>

<p>```</p>

<pre><code>    ListView itemList = (ListView) findViewById(android.R.id.list);
    data = new ArrayList&lt;&gt;();
    data.addAll(Arrays.asList("Item 1", "Item 2", "Item 3"));
    adapter = new ItemListAdapter(data);
    itemList.setAdapter(adapter);

    findViewById(R.id.fab).setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            // 模拟请求 API 刷新重新获得数据
            data = new ArrayList&lt;&gt;();
            data.addAll(Arrays.asList("Item 1", "Item 2", "Item 3", "Item 4"));
            adapter.notifyDataSetChanged();
        }
    });
</code></pre>

<p>```</p>

<p>让我们分析失效的原因，首先将 ArrayList data 设置为 Adapter 的数据源，而 Java 是引用传值，所以在 onClick() 回调函数中，当我们对 data 重新赋值时，重新赋值后的 data 并不能和 Adapter 中的数据源产生关联。因此 Adapter 中的数据源还是 “Item 1”, “Item 2”, &ldquo;Item 3"。所以这里无论怎样调用 notifyDataSetChanged 都是不能生效的。</p>

<h3>如何让 notifyDataSetChanged 生效</h3>

<p>让更新生效的方式是，让你的 Adapter 保持最新数据源。就上述例子来看，当 data 更新新值时，我们可以通过 List.add() 来更新 Adapter 中引用对应的值。实现代码如下：</p>

<p>```</p>

<pre><code>    ListView itemList = (ListView) findViewById(android.R.id.list);
    data = new ArrayList&lt;&gt;();
    data.addAll(Arrays.asList("Item 1", "Item 2", "Item 3"));
    adapter = new ItemListAdapter(data);
    itemList.setAdapter(adapter);

    findViewById(R.id.fab).setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            data.add("New Item " + view.toString());
            adapter.notifyDataSetChanged();
        }
    });
</code></pre>

<p>```</p>

<h3>End</h3>

<p>Android 中有很多优秀的设计，当我们出现问题时，可以通过阅读源码的方式探索，并结合 Google 的相关资料，了解事物的根源，方能设计出更优秀的代码。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android 应用的持续交付]]></title>
    <link href="http://www.gongmingqm10.net/blog/2015/06/29/android-testing-practice/"/>
    <updated>2015-06-29T11:40:16+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2015/06/29/android-testing-practice</id>
    <content type="html"><![CDATA[<p>当我们谈软件质量时，我们一般会谈到测试。测试作为保障软件质量的重要手段正在被开发者逐渐认知。谈到测试时，大部分人都知道Web测试，对于前端JS或者后台，大部分“靠谱”的创业公司也都会用测试来保证软件质量。可是对于起步相对较晚的移动端测试，用的人并不多。</p>

<p>在测试方面，Android早期即存在UIAtomator和Monkey之类的测试，但是用起来实在不方便。2013年，Google开源了针对An ndroid平台的移动测试框架 &ndash; Espresso。Espresso可以针对每个页面(Activity)进行测试。开发者可以根据ID获取到页面元素，然后进行点击、长按等操作。结合Junit和Mock等工具，使得移动端测试成为可能。移动端拥有了测试框架的辅助，借助CI平台，持续交付也成为可能。</p>

<!-- more -->


<h2>Android测试的类别</h2>

<p>从开发者角度来看，通常的Web平台测试可以分为单元测试、集成测试以及功能测试。移动应用主要用来显示数据，显示框输入数据，相应用户的点击、滑动等操作。所以Android应用的开发工作大部分集中在UI上。因此，App测试大致可分为UI单元测试和功能测试。</p>

<p>UI单元测试覆盖界面显示以及用户与界面的交互。功能测试则是确保功能的正确性。</p>

<p>为了更好的说明App中UI测试和功能测试如何进行的，以一个Story举例如下：</p>

<p>```
Story-101
Summary: 登录模块，用户能够使用用户名和密码登录App。
Acceptance criterions:</p>

<p>Given 作为用户，我打开App进入首页；
When 我点击“登录”按钮；
Then 我跳转到登录页面；</p>

<p>Given 作为用户，我在登录页面
When 我只输入用户名
Then 登录按钮处于Disable状态
When 我输入密码
Then 登录按钮可以点击，点击之后，调用API</p>

<p>Given 作为用户，我在登录页面
When 我输入正确的用户名和密码，并登录
Then 页面跳转到首页</p>

<p>Given 作为用户，我在登录页面
When 我输入错误的用户名和密码，并登录
Then 页面上方显示“用户名或密码错误”提示
And 密码被清空，登录按钮重新Disable</p>

<p>```</p>

<h3>UI单元测试</h3>

<p>UI(User interaction)测试又指界面测试。界面是软件与用户交互的最直接的部分，通过UI测试核实用户和软件拥有正常的交互。</p>

<p>UI测试的功能点比较简单：比如点击按钮的行为，按钮是否应该被禁用，页面文字、颜色等信息，是否弹框，点击弹框按钮应该跳转到什么页面等。</p>

<p>在登录页面中，假设登录页面的名字为LoginActivity，这是需要写的UI测试如下：</p>

<p>1.Test login button is not available until username and password are filled</p>

<p>```
usernameEditText.setText(&ldquo;gongmingqm10&rdquo;)
assertThat(loginButton.isDisabled()).isTrue()</p>

<p>passwordEditText.setText(&ldquo;password&rdquo;)
assertThat(loginButton.isDisabled()).isFalse()
```</p>

<p>2.Test should invoke Api when login button is clicked</p>

<p>```
usernameEditText.setText(&ldquo;gongmingqm10&rdquo;)
passwordEditText.setText(&ldquo;password&rdquo;)</p>

<p>loginButton.performClick()</p>

<p>verify(loginApi).login(eq(&ldquo;gongmingqm10&rdquo;), eq(&ldquo;encryptedpassword&rdquo;)</p>

<p>```</p>

<p>3.Test should show error dialog when login failed</p>

<p>```
usernameEditText.setText(&ldquo;gongmingqm10&rdquo;)
passwordEditText.setText(&ldquo;wrongpassword&rdquo;)
activity.loginFailed()
assertThat(passwordEditText.getText().toString()).isEqualTo(&ldquo;&rdquo;)
assertThat(errorText).isVisibile()
assertThat(errorText.getText().toString()).isEuqalTo(&ldquo;用户名或密码错误&rdquo;)</p>

<p>```</p>

<p>4.Test should navigate to home page when login succeed</p>

<p><code>
usernameEditText.setText("gongmingqm10")
passwordEditText.setText("correctpassword")
activity.loginSuccess()
String actualPageName = getNextStartedActivity().getComponentName()
assertThat(actualPageName).isEqualTo(HomeActivity.class.getName())
</code></p>

<p>观察上述几个测试，我们可以看到对UI的测试粒度相对较小。主要测试用户输入，按钮点击，服务器返回结果之后，界面应该如何反应。UI测试通常也包括简单的单元测试，Android中需要进行单元测试的内容较少，所以对于一些工具类的单元测试通常和UI测试放在同一个模块中。(PS: 上述测试代码的写法和你选取的测试框架有关)</p>

<h3>功能测试</h3>

<p>功能测试主要把测试对象看作一个黑盒子，测试者并不关注具体的功能实现逻辑，只需要关注输入产生期望的输出即可。Android的功能测试和Web的功能测试类似。在真机或模拟器中运行App，模拟输入、点击等操作，识别界面上是否存在某些期望的文字或行为。</p>

<p>功能测试不需要关注细节，只需要关注功能，对登录Story的功能测试如下：</p>

<p>1.With valid username and password, user can successfully login and navigate to home screen</p>

<p><code>
tap_when_element_exists "android.widget.EditText hint:'Username'"
keyboard_enter_text 'gongmingqm10'
tap_when_element_exists "android.widget.EditText hint:'Password'"
keyboard_enter_text 'some_correct_password'
@home_page.wait_for_page_to_load
welcome_message = @home_page.get_welcome_message
raise 'Navigate to home page failed' if welcome_message.empty?
</code></p>

<p>2.With wrong username and password, user will see an error text</p>

<p><code>
tap_when_element_exists "android.widget.EditText hint:'Username'"
keyboard_enter_text 'gongmingqm10'
tap_when_element_exists "android.widget.EditText hint:'Password'"
keyboard_enter_text 'wrong_password'
query "android.widget.TextView id: 'error_box' text:'用户名或者密码错误'"
</code></p>

<h2>Android常用测试框架</h2>

<h3>针对UI测试</h3>

<p>一般项目上都会采用<a href="http://robolectric.org/">Robolectric</a>框架，Robolectric运行过程中不需要启动模拟器，因此执行过程很快。</p>

<p>除了Robolectric，Google官方推荐使用Espresso来做UI测试。Espresso既可以作UI测试，也可以做简单的功能测试。</p>

<h3>针对功能测试</h3>

<p>可以做功能测试的框架也很多，包括Robotium, uiautomator, Espresso, Appium 和 Calabash。对比其主要区别如下：</p>

<p>真实项目过程中功能测试框架使用较多的是Appium和Calabash。这两个框架的优点是能够同时支持Android和iOS，并且不需要注入到工程中(即只需要编译后生成的安装包)，配合响应的测试脚本即可完成测试。</p>

<h2>Android持续交付</h2>

<p>CD(Continuous Dilivery)强调能够随时给客户交付有价值的产品。在Web开发上，我们通常运用CI平台持续部署网站到各个环境中。从而实现整个产品的持续交付。在Android平台上也是类似，唯一不同点是Android每发布一个版本需要用户手动更新手机上的App。</p>

<p><strong>1. 集成你的测试框架</strong></p>

<p>假定我们已经选定其他的技术栈，这时只需要集成UI测试和功能测试即可。UI单元测试框架我们选择Robolectric，而功能测试框架选择Calabash。参考<a href="http://robolectric.org/">Robolectric</a>和<a href="https://github.com/calabash/calabash-android">Calabash for Android</a>官方文档，集成测试框架并编写第一个Dummy Test。</p>

<p><strong>2. 通过你的第一个Dummy Test</strong></p>

<p>CI(Continuous Integration)平台，选择Jenkins。因为Jenkins有各种丰富的插件支持。选择Jenkins平台之后，最后能够有一台带界面的Mac Mini(虽然Android可以配置无界面运行，但是配置相对麻烦并且运行太慢)。在Mac Mini上搭建CI环境，配置Android运行环境。此步的目的是你的Dummy Test能够在Jenkins上运行</p>

<p><strong>3. 自动上传你的应用</strong></p>

<p>我们希望每次Push之后生成的包能够被QA测试，Showcase时候能够被客户测试。所以我们需要持续的发布新生成的包。我接触到的通常有两种做法：</p>

<ul>
<li>使用Dropbox自动同步上传：这种方法是最省成本的。每次打包新版本的时候只需要给文件带上不同的版本号，方便辨识。包生成之后，只需要存放到本地的Dropbox共享文件夹中。Dropbox会为我们自动上传。手机端则可以直接访问Dropbox下载，安装。</li>
<li>使用<a href="http://hockeyapp.net/features/">HockeyApp</a>管理版本：HockeyApp需要收费，但是可以很方便的通过部署脚本自动上传新生成的包。手机端只需要安装HockeyApp客户端，即可选择更新。</li>
</ul>


<p>类似的工具还有很多，选择适合自己的才是最好的。</p>

<h2>结语</h2>

<p>移动端测试虽然发展时间不长，但是却不断在完善中。我们以前习惯用邮件或U盘发布新版供他人测试。我们以前习惯开发App时不写测试。那些时代应该过去了。运用Robolectric，我们可以很轻松的测试驱动开发Android App；运用Calabash或Appium，我们可以更好的控制App质量，保证App功能；运用Jenkins等CI平台，我们的App可以持续交付啦!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Material Design Your Android App]]></title>
    <link href="http://www.gongmingqm10.net/blog/2015/06/25/material-design-your-android-app/"/>
    <updated>2015-06-25T15:22:27+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2015/06/25/material-design-your-android-app</id>
    <content type="html"><![CDATA[<p>14年6月26日的Google I/O大会上，Google推出了一门全新的设计语言Material Design。Material Design在随后的一年里被逐渐应用到Android, Web等平台中。Material Design的推出意味着Google对移动端和网页端设计的整合。固然没有引起轩然大波，但是Material Design却让Android开发者看到了一点福音。</p>

<p>虽然Android系统广受诟病，越来越多的用户投奔苹果的iOS系统。然而这阻挡不了Android的不断改进。14年Google I/O, Google推出了Android的5.0版本，代号Lollipop。5.0版本在设计上采用全新的Material Design，虽然这次升级对ROM生产商来说是道“过不去的坎儿”，但是对开发者群体而言却是一次很不错的升级。因为开发者可以凭借有些的设计资源打造出更好看的App。</p>

<!-- more -->


<h2>关于Material Design</h2>

<blockquote><p>Material design is a comprehensive guide for visual, motion, and interaction design across platforms and devices.</p></blockquote>

<p>这是Google官方给的解释， Material Design 中文直译为 “物质的设计”。可以简单理解为画面中的所有元素都可以看作是真实的物质，物质存在于空间中，并且存在光、影、运动等特征。所以Material Design的众多原则都是基于Material这个概念而提出的。</p>

<h3>Material Design基本原则</h3>

<p>Material Design作为设计与交互的一部分，由设计师来阐述更为专业。以下只是抛砖引玉的介绍，也许身边的设计师朋友会更专业的见解。</p>

<h4>Material is the metaphor</h4>

<blockquote><p>A material metaphor is the unifying theory of a rationalized space and a system of motion</p></blockquote>

<p>举例来说，在Android Lollipop系统中，当用户点击操作时，界面会反馈出水纹般的涟漪向周边散去，作为对用户点击操作的直接反馈。Material的设计都是基于现实，并在现实世界的基础上予以创新的。创新之处表现在元素之间整理运动的和谐。即使是在现实世界进行创新，最重要的是要Material Design不会破坏物理世界的规则。</p>

<h4>Bold, graphic, intentional</h4>

<blockquote><p>The foundational elements of print-based design—typography, grids, space, scale, color, and use of imagery—guide visual treatments.</p></blockquote>

<p>设计中的基本元素网格，空间，比例，字体，颜色等的结合能够给用户带来更好的体验，从而产生更大的价值。Material Design给我们指定了一些常见的搭配组合，比如颜色的组合、App中不同部分字体大小，组件之间的边距等。</p>

<h4>Motion provides meaning</h4>

<blockquote><p>Motion respects and reinforces the user as the prime mover. Primary user actions are inflection points that initiate motion, transforming the whole design.</p></blockquote>

<p>动画通常是App中最常见的交互，在Material Design出来之前，大部分App是很少有动画的。因为动画从设计到最后被用户使用，需要动画的设计以及开发，有时还会受限于平台。Material Design在动画方面有所加强，官方推出了许多默认的动作，页面各个元素之间的相互运动等。期望通过元素的运动向用户传达更为核心的价值和功能。</p>

<h3>为什么我们需要Material Design</h3>

<p>设计主要是为了提升用户体验，辅助产品功能，起到锦上添花的效果。Google推出Material Design也许希望对所有的Google产品进行设计上的统一化。</p>

<p>从Android平台来看，以前的Google Apps很难说有什么风格，其他厂商开发的App也是风格各异。Google希望通过Lollipop对App统一风格，所以在5.0＋平台上的Gmail, Youtube, Calender等都进行了风格的统一化，借此引导更多的设计师和开发者开发出更“接地气”的App。</p>

<p>Material Design强调跨平台设计，如果你遵从Material Design，你会发现将无论是宽屏平板设备、还是手机，你会发现你的应用可以很智能的进行展示。这将极大减轻适配平板带来的工作量。是不是有点类似于Web上的响应式设计呢？</p>

<p>当然选择是自由的，如果你觉得你的App不需要Material Design，那么TA真的不需要。</p>

<h2>如何Material Design App</h2>

<p>据个人观察，目前国内市场上大部分的App没有Material Design的概念。原因不得而知。但是遵循Material Design的应用在国外却比较常见。比如我个人常用的雅虎天气。</p>

<p>那么如何空手开发Material Design 应用呢？假定读到这里的你是个开发人员：</p>

<h3>1.合适的SDK版本和相关兼容包</h3>

<p>build.gradle</p>

<p>```
apply plugin: &lsquo;com.android.application&rsquo;</p>

<p>android {</p>

<pre><code>compileSdkVersion 22
buildToolsVersion "22.0.1"

defaultConfig {
    applicationId "net.gongmingqm10.training"
    minSdkVersion 16
    targetSdkVersion 22
    versionCode 1
    versionName "1.0"
}
...
</code></pre>

<p>}</p>

<p>dependencies {</p>

<pre><code>compile fileTree(dir: 'libs', include: ['*.jar'])
//required
compile 'com.android.support:appcompat-v7:22.2.0'
//optional for RecyclerView
compile 'com.android.support:recyclerview-v7:22.2.0'
//optional for GridLayout
compile 'com.android.support:gridlayout-v7:22.2.0'
//optional for CardView
compile 'com.android.support:cardview-v7:22.2.0'
//optional for some useful libraries
compile 'com.android.support:design:22.2.0'
</code></pre>

<p>}</p>

<p>```</p>

<h3>2.使用 Material theme</h3>

<p>values-v21/styles.xml</p>

<p>```
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;utf-8&rdquo;?>
<resources></p>

<pre><code>&lt;style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar"&gt;
    &lt;!-- Main theme colors --&gt;
    &lt;!--   your app branding color for the app bar --&gt;
    &lt;item name="colorPrimary"&gt;@color/color_primary&lt;/item&gt;
    &lt;!--   darker variant for the status bar and contextual app bars --&gt;
    &lt;item name="colorPrimaryDark"&gt;@color/color_primary_dark&lt;/item&gt;
    &lt;!--   theme UI controls like checkboxes and text fields --&gt;
    &lt;item name="colorAccent"&gt;@color/color_accent&lt;/item&gt;

&lt;/style&gt;
</code></pre>

<p></resources></p>

<p>```</p>

<p>values/styles.xml</p>

<p>```
<resources></p>

<pre><code>&lt;!-- Base application theme. --&gt;
&lt;style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar"&gt;
    &lt;!-- Customize your theme here. --&gt;
    &lt;item name="android:actionBarStyle"&gt;@style/MyActionBar&lt;/item&gt;
    &lt;!-- Support library compatibility --&gt;

    &lt;item name="actionBarStyle"&gt;@style/MyActionBar&lt;/item&gt;
&lt;/style&gt;

&lt;style name="AppTheme.NoActionBar"&gt;
    &lt;item name="windowActionBar"&gt;false&lt;/item&gt;
    &lt;item name="windowNoTitle"&gt;true&lt;/item&gt;
&lt;/style&gt;

&lt;!-- ActionBar styles --&gt;
&lt;style name="MyActionBar"
    parent="@style/Widget.AppCompat.Light.ActionBar.Solid.Inverse"&gt;
    &lt;item name="android:background"&gt;@color/color_primary&lt;/item&gt;
    &lt;item name="android:titleTextStyle"&gt;@style/MyActionBarTitleText&lt;/item&gt;

    &lt;!-- Support library compatibility --&gt;
    &lt;item name="background"&gt;@color/color_primary&lt;/item&gt;
    &lt;item name="titleTextStyle"&gt;@style/MyActionBarTitleText&lt;/item&gt;
&lt;/style&gt;

&lt;style name="MyActionBarTitleText" parent="TextAppearance.AppCompat.Widget.ActionBar.Title"&gt;
    &lt;item name="android:textColor"&gt;@color/white&lt;/item&gt;
&lt;/style&gt;
</code></pre>

<p></resources></p>

<p>```</p>

<p>使用你定义的AppTheme</p>

<p>```</p>

<pre><code>&lt;application
    android:name=".TrainingApp"
    android:allowBackup="true"
    android:icon="@mipmap/ic_launcher"
    android:label="@string/app_name"
    android:theme="@style/AppTheme" &gt;
    ...
&lt;/application&gt;
</code></pre>

<p>```</p>

<h3>3.使用专为Material Design打造的Android控件</h3>

<p>你可以参考<a href="http://developer.android.com/training/material/index.html">Google Training Material Design</a>获取更多的Material Design组件的使用方法。</p>

<h4>Lists and Cards</h4>

<h5>RecyclerView</h5>

<p>引入RecyclerView到工程中：</p>

<p><code>
compile 'com.android.support:recyclerview-v7:22.2.0'
</code>
RecyclerView控件是ListView的更高效更灵活的版本。可以看作是对ListView更好的封装：</p>

<ul>
<li>解决ListView多列显示的难题；</li>
<li>不用担心开发人员没有复用View，因为它会强迫你这样做；</li>
<li>更方便的动画支持，移除中间某一项时，可以设置后面几项动画移动;</li>
</ul>


<h5>CardView</h5>

<p><code>
compile 'com.android.support:cardview-v7:22.2.0'
</code>
卡片式布局，你的界面就是有导航和卡片组成的。卡片能够设置圆角和阴影。</p>

<h4>Design support library</h4>

<p>使用Design support包含的空间，需要引入Design support库：</p>

<p><code>
compile 'com.android.support:design:22.2.0'
</code></p>

<p>Design support提供了一些很常见很实用的控件。</p>

<h5>Navigation View</h5>

<p>Material Design推荐使用DrawerLayout抽屉式布局显示导航，所以Android一直没有为底部导航推出相应的控件。按照Google最新的设计，所有的导航都会被设置为抽屉显示，点击左上角菜单可以抽屉式弹出菜单项。</p>

<p>NavigationView就是和DrawerLayout搭配使用的神器。使用NavigationView只需要提供icon和title就可以生成专业的侧边导航。</p>

<h5>Floating Action Button</h5>

<p>Material Design引入了z轴，这个控件可以轻松制作出有阴影的悬浮圆形按钮。</p>

<h5>Snackbar</h5>

<p>底部栏消息提示控件，显示显示不再只有Toast和AlertDialog，还有Snackbar。</p>

<h5>Tabs</h5>

<p>在TabLayout出来之前，开发者通常手写Tab控件，并且需要手动控制UI。并且设计出来的Tab效果很一般。Google在2014年的iosched工程中推出了<a href="https://github.com/google/iosched/blob/master/android/src/main/java/com/google/samples/apps/iosched/ui/widget/SlidingTabLayout.java">SlidingTabLayout</a>，这个组件后来也在众多项目中被开发者用到。但是开发者还是得添加额外的代码来控制UI。</p>

<p>TabLayout帮助开发者创建符合界面风格的Tab，并且简单易用。</p>

<h5>CoordinatorLayout &amp; Collapse Toolbar</h5>

<p>更加优美的导航，导航可以相应页面滚动，也产生相应的滚动效果。可以参考Android 5.0版本默认的联系人应用。</p>

<h2>结语</h2>

<p>目前 Material Design 在国内潜伏了一年，也没引起太大的市场反馈。互联网泡沫下，决策者的心思都花在了如何推广如何吸引第一批用户上了，难以负担App重新设计带来的时间成本，更不行因为重设计造成现有用户的流失。</p>

<p>当然，如果某一天所有的国内手机都可以升级为5.0系统，是不是会有许多软件开发者考虑对App做Material Design呢？Android系统深度定制化依然成为5.0难以在国产手机中推广的重要阻碍。</p>

<p>Material Design作为Android App设计风格的趋势，尝试在你的App中使用新的风格，也许可以给你的产品带来不一样的体验。</p>

<h2>Open Party PPT 下载地址</h2>

<p><a href="http://7xj9js.com1.z0.glb.clouddn.com/Android%20Material%20Design.pptx">Android Material Design PPT 下载</a></p>

<p><strong>参考</strong></p>

<p><a href="https://www.google.com/design/spec/material-design/introduction.html">Google Materil Design</a></p>

<p><a href="http://developer.android.com/training/material/index.html">Material Design for Developers</a></p>

<p><a href="http://android-developers.blogspot.sg/2015/05/android-design-support-library.html">Android Design Support Library</a></p>
]]></content>
  </entry>
  
</feed>
