<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | gongmingqm10]]></title>
  <link href="http://www.gongmingqm10.net/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://www.gongmingqm10.net/"/>
  <updated>2016-05-11T15:20:53+08:00</updated>
  <id>http://www.gongmingqm10.net/</id>
  <author>
    <name><![CDATA[Gong Ming]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ButterKnife Principle]]></title>
    <link href="http://www.gongmingqm10.net/blog/2016/05/11/butterknife-principle/"/>
    <updated>2016-05-11T15:15:25+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2016/05/11/butterknife-principle</id>
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/576124-831ee4dbd091aa30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/200" alt="ButterKnife 原理" /></p>

<p>最近在研究 Java 中的 Annotation，初衷是先了解注解，然后再了解下 Android 开发中常用框架的原理。经历的 Android 项目中，使用注解比较多的是：<a href="https://github.com/JakeWharton/butterknife">ButterKnife</a>, <a href="https://github.com/roboguice/roboguice">Roboguice</a>, <a href="https://github.com/roboguice/roboguice">Dagger</a> 。ButterKnife 主要是 View Binding, 而 Roboguice 和 Dagger 则主要是做 DI(Dependency Injection)。本文主要研究 ButterKnife 的原理。</p>

<p>开始之前，还是应该向 ButterKnife 的作者 Jake Wharton 大神以及开源社区致敬。</p>

<!-- More -->


<h2>ButterKnife 初瞰</h2>

<p>ButterKnife 到底是什么？看看官方的解释：</p>

<blockquote><p>Bind Android views and callbacks to fields and methods.</p></blockquote>

<p>通过 ButterKnife <a href="http://jakewharton.github.io/butterknife/">官方文档</a>，我们可以很快速的使用它。并且可以看到 ButterKnife 主要是实例化 View 或者给某个 View 添加各种事件 Listenters。</p>

<p><img src="http://upload-images.jianshu.io/upload_images/576124-2be2b864707172b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="ButterKnife View Binding" /></p>

<p>所以使用 ButterKnife 主要有几步：</p>

<p>1.Gradle 中引入 ButterKnife 框架：</p>

<p><code>
compile 'com.jakewharton:butterknife:8.0.1'
</code>
2.ButterKnife 初始化:</p>

<p>```
@Override
protected void onCreate(Bundle savedInstanceState) {</p>

<pre><code>super.onCreate(savedInstanceState);   
setContentView(getLayoutResourceId());    
ButterKnife.bind(this);
</code></pre>

<p>}}
```
3.声明 Field/Method</p>

<p>```
@Bind(R.id.btn_home)ImageView homeBtn;
@Bind(R.id.btn_explore)ImageView exploreBtn;
@OnClick(R.id.btn_home) void clickHomeBtn() {</p>

<pre><code>// Handle the home btn click
</code></pre>

<p>}
```</p>

<h2>Java Annotation</h2>

<p>如果你对注解了解比较少，在进一步了解 ButterKnife 之前，有必要了解一下 Java Annotation 的基础知识。可以参考如下两份资料：</p>

<ol>
<li>Mkyong <a href="http://www.mkyong.com/java/java-custom-annotations-example/">Java Custom Annotations</a></li>
<li>Trenia <a href="http://trinea.github.io/download/pdf/android/java-annotation.pdf">Java Annotations</a></li>
</ol>


<p>通过上面的例子以及讲解，我们可以知道如何自定义注解。自定义注解我们需要知道两个基础的元注解<code>@Retention</code> 和 <code>@Target</code>.</p>

<h3>元注解 @Retention</h3>

<p><code>@Retention</code> 保留时间：有三类值可以选择，<code>SOURCE</code>  <code>RUNTIME</code> <code>CLASS</code>。</p>

<p><code>SOURCE</code> 源码时保留：使用此类的注解多为标记注解，比如 <code>@Override</code>、<code>@Deprecated</code>、<code>@SuppressWarnings</code> 等。</p>

<p><code>RUNTIME</code> 运行时保留：程序在运行过程中，使用这些 Annotation, 比如我们常用的 <code>@Test</code>。</p>

<p><code>CLASS</code> 编译时保留：Java 文件在编译时由 apt 自动解析，需要自定义类继承自 AbstractProcessor 并重写 Process 函数。比如 ButterKnife 中使用的  <code>@BindView</code>, <code>@OnClick</code> 等就是声明为 CLASS 的。</p>

<h3>元注解 @Target</h3>

<p>Target 表示注解可以用来修饰哪些元素。可选值包括 TYPE, METHOD, CONSTRUCTOR, FIELD, PARAMETER 等。</p>

<h2>ButterKnifeProcessor</h2>

<p>ButterKnife 中所有的注解都使用 Retention 为 CLASS 保留。所以在 ButterKnife 中，有个很重要的 ButterKnifeProcessor。当 java 文件进行编译时，ButterKnifeProcessor 的 process() 方法被调用，生成相关的 ViewBinder 类，用于将 View 或者 Listener 进行绑定。</p>

<p>ButterKnifeProcessor 的关键逻辑如下：</p>

<p><img src="http://upload-images.jianshu.io/upload_images/576124-0fa0624d662090af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="ButterKnifeProcessor.process()" /></p>

<p>process() 会找到所有 ButterKnife 相关的 annotation，并将这些相应的注解生成为 ViewBinder 类，一个 ViewBinder 示例如下：</p>

<p><img src="http://upload-images.jianshu.io/upload_images/576124-a9f0fdf997e95ed8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="Screen Shot 2016-05-11 at 2.52.20 PM.png" /></p>

<p>ViewBinder 通过 findViewById 实例化 Activity 中页面上的组件，并且能够设置各控件的点击时间，滑动事件等。</p>

<blockquote><p>为什么 ButterKnife Annotation 的字段或者方法不能声明为 private?</p></blockquote>

<p>bind() 方法中，通过 activity.homeBtn 对 View 赋值。因此所有 ButterKnife annotation 标记的 field 或者 method 都不能声明为 private, 因为 private 没办法在 ViewBinder 中直接访问。由此可见：</p>

<blockquote><p>ButterKnife 并不是依靠反射实现 View Injection 的！</p></blockquote>

<h2>ButterKnife.bind(this)</h2>

<p>在 ButterKnife 工作之前，我们一定得在设置 View  后调用 <code>ButterKnife.bind(Activity)</code> ，这样才能使 ButterKnife View 注入成功。那么 ButterKnife.bind(Activity) 是如何工作的呢？</p>

<p><img src="http://upload-images.jianshu.io/upload_images/576124-dce842ddf87bb891.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="ButterKnife.bind(this)" /></p>

<p>App 在打包时，ButterKnife Processor 就为所有使用 ButterKnife 注解的 Activity 生成 ViewBinder()。通过上述代码可以看到，ButterKnife 会尝试实例化当前 Activity 所关联的所有 ViewBinder 类。实例化之后再调用 <code>ViewBinder.bind(...)</code> 方法，bind() 方法是在 App 运行过程中才会被调用的。于是当前 Avtivity 的 View 被实例化赋值，如果有点击事件的注解，也会绑定相应的事件。</p>

<h2>结语</h2>

<p>ButterKnife 主要是做 View 注入的，使用起来比较简便。当然如果你想做一些 依赖注入，比如 Android MVP 架构中 Activity 与 Presenter 的依赖。你可能需要借助一些其他的库， 比如 Dagger。研究下 ButterKnife 的原理，才发现这个库做得如此的睿智。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[App 本地化解决方案]]></title>
    <link href="http://www.gongmingqm10.net/blog/2016/03/19/app-localisation-solution/"/>
    <updated>2016-03-19T13:38:10+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2016/03/19/app-localisation-solution</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>“本地化” 这个词对大家而言并不陌生，文艺点的解释大概就是 “入乡随俗” 吧。当然我们这里的本地化主要指的软件产品的本地化。对于某个国外应用，如果需要投放到中国市场，需要注意哪些问题呢？本文主要从开发的视角来探讨应用本地化的问题。</p>

<!-- More -->


<h2>本地化</h2>

<p>本地化(Localisation)主要是提升软件对于不同地区不同环境的用户的用户体验问题。从语言角度来说，我们需要给 App 支持中文。但是翻译就是本地化的全部吗？</p>

<p>谈到体验问题，语言只是用户体验的一部分。为了提升用户体验，本地化除了语言翻译之外，还包括许多内容。本地化大体受语言、网络、文化等因素的影响。</p>

<p><strong>1.语言</strong></p>

<p>语言关系着用户能否使用你的App，是否理解App的核心价值。所以在移动开发中，开发人员能够轻易的创建出针对不同语言的字符串资源文件，App运行时会根据当前设备的语言设置加载对应的字符串资源。这是Android和iOS框架本身所支持的。所以语言是本地化最直接的一部分，也是最容易做的一部分。</p>

<p><strong>2.网络</strong></p>

<p>网络意味着连通性，决定着App中的各项服务能否正常使用。比如某跑步软件中，内嵌 Google 地图来记录用户的位置以及轨迹，当一个中国用户下载这个应用时并不能正常使用。因为应用没有考虑到中国用户对 Google 服务访问受限。网络问题在中国本地化中尤其突出，因为你需要时刻考虑"防火长城"对软件中各服务模块的影响。</p>

<p><strong>3.文化</strong></p>

<p>本地化方面文化的成分虽然不多，但是却是最值得挖掘的地方。以文本方向为例：Arabic文字是从右到左的方向，Android4.2版本开始全面支持Right to Left布局，iOS也在WWDC2015中宣布全面支持右到左的文字布局。除了文本方向之外，文化还包括用户行为偏好。比如美国用户可以喜欢用运动相机拍摄极限视频。但是中国用户却更喜欢用运动相机自拍，然后分享朋友圈。不同的用户习惯决定着产品差异化的定位。</p>

<p>有了上述对本地化的理解。那我们可以来比较一下 翻译、本地化、国际化的异同点。下面我们可以了解下主要区别：</p>

<p><img src="http://rack.2.mshcdn.com/media/ZgkyMDEyLzAyLzEzLzE3XzAyXzUyXzgzM19maWxlCnAJdGh1bWIJMTIwMHg5NjAwPg/00de5e48" alt="本地化比较" /></p>

<h2>实践与坑</h2>

<p>了解了本地化之后，那么在整个的项目实践中，我们有哪些需要注意的地方呢？</p>

<h3>翻译</h3>

<p>在本地化翻译过程中，我们一般需要先进行翻译相关文本。然后给客户验证反馈。翻译过程中需要提前确认，特别是对于法律性质的长文本翻译，可能还要和客户的法务部门打交道，敦促他们尽快完成翻译校对服务。当然，如果你自己没办法翻译一些服务条款等，可以把翻译服务委托给其他翻译机构。</p>

<p>翻译的沟通和确认可以直接使用 Google Excel 在线协作编辑，当然也可以使用 <a href="http://transfix.io/">Transfix</a> 平台协作翻译。</p>

<h3>代码管理</h3>

<p>对于本地化项目，我们一般推荐客户在同一份代码库上进行开发。这样对于后期发布新功能将很有帮助。如果一开始就采用两套不同的代码库来做本地化，那以后英文版上增加了新功能，再复制到现在的版本上，将增加很多不必要的工作量，并带来诸多不一致性。</p>

<p>当然如果你综合考虑之后，觉得中文版的App和英文版的App将有很大差异化，客户想直接做一个“具有中国特色的本地化”App，那就勇敢的重新开始吧。</p>

<p>在现实情况中，如果你能够给客户做中国的本地化，那么未来可能的业务也许是其他语言的本地化。这时候在代码管理的时候如果可以多考虑一点，也许可以带来新的商机。</p>

<h3>国内媒体分享</h3>

<p>国内媒体分享可以说是本地化中一个很重要的方面。美国的社交平台主要是 Facebook, Twitter, Pinterest, youtube 等，但是在中国这些分享平台将是 微信朋友圈，QQ 空间，新浪微博, youku等。</p>

<p>如果选择做国内媒体分享，需要确定是使用系统默认(Android系统默认的分享方式支持QQ, Wechat等； iOS不支持国内的渠道分享)分享组件，还是使用各社交平台的SDK进行集成。工作量是不一样的，所以要根据项目的进度安排进行合适的计划。</p>

<p>如果你已经决定要集成各大社交平台 SDK 进行分享，那么我们应该尽快提交审核，申请相关的key和 secret。因为我们要预防审核过程中的各种问题。</p>

<h3>网络-GFW</h3>

<p>网络可用性这个问题估计只有在做 APP 汉化的时候才会遇到。具体来说，中国市场Google服务(包括Google Map, Google Analytics, Google Cloud Messaging, Google Plus)等处于不可用(或者不稳定)状态。因此，除了App的文字资源需要汉化之外，App中使用的系列Google服务也应该更换为在国内可以使用的服务。</p>

<p>由于Google服务不可用的情况，很多国产Android手机将手机中的Google服务给移除掉了，所以国内的 App应用请慎用Google服务(组件)，毕竟网络是个很大的问题。</p>

<p>除了Google服务之外，对于其他的服务也需要考虑稳定性等。因为有些国外的服务虽然不是Google的，但是在国内也很难访问。</p>

<p>App中常见的服务：</p>

<ol>
<li>地图：Google Map不可用，国内可以替代为高德地图服务；</li>
<li>社会化分享/登录: Google plus登录，Facebook和Twitter分享；</li>
<li>App统计：Google Analytics不稳定；国内可以替换为Umeng或者Flurry；</li>
<li>消息推送：Google Cloud Messaging不稳定；国内可以用个推或 JPush；</li>
</ol>


<p>当我们在对应用做服务选择的时候，除了需要考虑网络易用性之外，也需要考虑所选框架的文档是否适合客户的后期维护。因为我们的项目一般结束之后，要让客户能够快速接手，如果选择一些文档不全后期支持很差的服务，那团队解散之后。客户将很难维护这份代码。</p>

<h3>应用分发</h3>

<p>应用开发完成之后，离发布还有一步。你需要将App分发到应用市场中，才能够真正让用户使用App。这里的应用分发指Android应用的分发。对于iOS的应用分发，按照官方流程走，应该不会出现太多意外。</p>

<p>Android 应用市场分发，在中国尤其繁琐。由于Google Play Store在国内的Android手机中基本不可用，从而给了其他应用商店很多机会，比如：腾讯应用宝、百度市场、豌豆荚、安卓市场、360市场以及小米市场等。</p>

<p>在我们给某客户分发应用的时候，发现Android应用市场一般会自动爬取Google Play上的应用，于是我们的英文版就被官方市场收录，当时我们提交开发完成的中文版应用的时候，我们被告知应用侵权无法上架。最后经过复杂的邮件沟通，版权证明，应用认领等来解决这些版权问题。而这种特定的应用审核问题是没有提前预知的。这种问题也使得整个上线时间推迟了半个月左右。</p>

<p>所以在应用分发之前，我们应该提前在应用上线之前进行试水。避免这种应用审核可能带来的风险。</p>

<h2>写在后面</h2>

<p>App本地化不再是字符串的本地化，包括影响软件可用性的服务的本地化。有效且全面的本地化才能够真正构建出一款易用“接地气”的App。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android 转屏那些事儿]]></title>
    <link href="http://www.gongmingqm10.net/blog/2015/12/16/you-should-know-about-android-rotate/"/>
    <updated>2015-12-16T15:39:43+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2015/12/16/you-should-know-about-android-rotate</id>
    <content type="html"><![CDATA[<p>在 Android 开发或面试过程中，屏幕旋转是一个容易让人忽视的知识点。在我之前经历的项目中，App 通常是为竖屏状态设置的，所以通常我们会对每个页面都设置竖屏方向，这时候我们不需要考虑旋转屏问题。但是最近项目中，我们的 App 是为平板设计的，而横竖屏旋转是属于客户的一个需求，当然平板上横竖屏的确比较常用。所以就借此机会研究了下 Android 横竖屏问题。</p>

<p><img src="http://7xj9js.com1.z0.glb.clouddn.com/portrait_landscape.png" width="500" alt="Android 横竖屏" /></p>

<!-- More -->


<p>横竖屏之所以需要引起开发者的注意，是因为 App 在横竖屏切换的过程中，页面会重绘，那么页面上已有的数据（比如登录页面已经输入的用户名）如何保存成为了一个问题。按照官方的推荐，Activity本身的确有处理旋转屏事件的函数，但是当一个页面中需要保存的数据很多的时候（比如很多 EditText），还是手工处理，就显得有些繁琐了。下面我们将循序渐进地探索 Android 屏幕旋转之最佳实践。</p>

<h2>Activity 旋转中的保存与恢复</h2>

<p>在解决问题或者探索最佳实践的时候，我们可以从简单的问题入手，慢慢衍生至复杂的情形，最后再抽象出一些比较通用的解决方案。这一步我们单纯的探索一个 Activity（没有 Fragment）的数据保存与恢复。</p>

<h3>Activity 的生命周期</h3>

<p>Activity 从创建到呈现在用户面前到消亡，有着自己完整的生命周期：</p>

<p><img src="http://7xj9js.com1.z0.glb.clouddn.com/activity_lifecycle.png" width="500" alt="Activity 生命周期" /></p>

<p>旋转屏幕时，打印相关 Log 如下：</p>

<p><img src="http://7xj9js.com1.z0.glb.clouddn.com/activity_rotate_cycle.png" width="600" alt="Activity 旋转中的生命周期" /></p>

<p>从 Log 可以看到，在屏幕旋转时，原来的 Activity 调用了 onDestroy，随后重新实例化了一个 MainActivity。重新实例化的 MainActivity 也会经历 “onCreate &ndash;> onStart &ndash;> onResume” 的生命周期。</p>

<h3>Activity 中窗口保存与恢复</h3>

<p>为了进一步探索 Activity 在旋转屏过程中的数据保存及恢复的逻辑，我们构造了一个具有用户名和密码的登录界面。当用户在用户名中输入用户名时，这时候旋转屏幕，此时期望的操作应该是输入的用户名仍然能够保留：</p>

<p><img src="http://7xj9js.com1.z0.glb.clouddn.com/activity_login.png" width="400" alt="Activity Login 页面" /></p>

<p>在不添加任何额外代码的情况下，我们可以看到输入框中的数据在旋转屏后仍然能够保留，这些控件基本状态的值是如何被保留的呢？</p>

<p>Activity 中方法 <code>protected void onSaveInstanceState(Bundle outState) {...}</code> 主要做状态保存相关的处理，如果我们有需要特地保存的变量等，我们可以在 <code>onSaveInstanceState</code> 中保存，保存后的 bundle 以 outState Bundle 的格式保存。当 Activity 再次被初始化时，<code>onCreate(Bundle savedInstanceState)</code> 会将保存的 bundle 传递给 Activity 主页面，Activity 主页面接收到这些状态保存的数据后，能够根据保存中的控件的ID信息，状态数据等对页面进行自动的初始化。当我们转屏时，会主动触发 <code>onSaveInstanceState</code> 被调用。Log 打印如下：</p>

<p><img src="http://7xj9js.com1.z0.glb.clouddn.com/activity_onrestore_data.png" width="600" alt="Activity onSaveInstanceState &amp; onRestoreInstanceState" /></p>

<p>根据 Log 很明确看出在旋转屏之后，随着 onPause 的执行，<code>onSaveInstanceState</code> 也被执行。当 Activity 再次初始化时，<code>onCreate(Bundle savedInstanceState)</code> 会传递回一个非空的 savedInstanceState（而当 Activity 第一次初始化时此值为空），同时 <code>onRestoreInstanceState</code> 也会被调用，用来将保存的窗口状态信息重新应用：</p>

<p>生命周期：<code>onCreate</code> &ndash;> <code>onStart</code> &ndash;> <code>onResume</code> &ndash;> Running 转屏 &ndash;> <code>onPause</code> &ndash;> <code>onSaveInstanceState</code> &ndash;> <code>onStop</code> &ndash;> <code>onDestroy</code> &ndash;> <code>onCreate</code> &ndash;> <code>onStart</code> &ndash;> <code>onRestoreInstanceState</code> &ndash;> <code>onResume</code>;</p>

<p><img src="http://7xj9js.com1.z0.glb.clouddn.com/activity_savedInstanceState.png" width="600" alt="Android savedInstanceState" /></p>

<p>通过对 <code>savedInstanceState</code> 的查看，发现 savedInstanceState 中包含有 Key 为 <code>android:viewHierarchyState</code> 的 bundle 数据，此 bundle 数据具体内容如下：</p>

<p>```
Bundle[{android:views={</p>

<pre><code>    16908290=android.view.AbsSavedState$1@347440f8,         2131492927=android.view.AbsSavedState$1@347440f8,       2131492928=android.view.AbsSavedState$1@347440f8,       2131492929=android.support.v7.widget.Toolbar$SavedState@391b69d1,       2131492930=android.view.AbsSavedState$1@347440f8,       2131492944=TextView.SavedState{138fec36 start=8 end=8 text=gongming},       2131492945=TextView.SavedState{16043737 start=0 end=0 text=},       2131492946=android.view.AbsSavedState$1@347440f8
},
android:focusedViewId=2131492944}
</code></pre>

<p>]
```
可以看到 username 的输入框 EditText，其 ID 以及当前的值都已经保存至 savedInstanceState 中。</p>

<p>那么，对于 Activity.java 的而言，最重要的保存数据和恢复数据的源代码如下：</p>

<p>```</p>

<pre><code>private static final String WINDOW_HIERARCHY_TAG = "android:viewHierarchyState";

protected void onSaveInstanceState(Bundle outState) {
    outState.putBundle(WINDOW_HIERARCHY_TAG, mWindow.saveHierarchyState());
    Parcelable p = mFragments.saveAllState();
    if (p != null) {
        outState.putParcelable(FRAGMENTS_TAG, p);
    }
    getApplication().dispatchActivitySaveInstanceState(this, outState);
}

protected void onRestoreInstanceState(Bundle savedInstanceState) {
    if (mWindow != null) {
        Bundle windowState = savedInstanceState.getBundle(WINDOW_HIERARCHY_TAG);
        if (windowState != null) {
            mWindow.restoreHierarchyState(windowState);
        }
    }
}
</code></pre>

<p>```
这就是为什么我们没有做过多的处理却可以让 App 在旋转屏幕时仍然自动保存恢复输入框中的文字。</p>

<h3>Activity 中数据保存与恢复</h3>

<p>既然 Activity 本身对窗口（控件）的状态信息进行了保存及恢复处理。那么我们在屏幕切换时最应该关心的就是页面数据的保存与恢复。页面数据主要有两种：</p>

<ul>
<li>API 请求的数据：在横竖屏切换时对API数据进行保存及恢复能够防止 API 的重复调用；</li>
<li>页面中的状态值：在 Activity 运行过程中被改变的状态值，在恢复时需要手动保存及恢复，以便不影响状态值相关的页面逻辑；</li>
</ul>


<p>在 Activity 中进行变量的存储及读取时，使用 <code>onSaveInstanceState</code> 进行数据的存储，使用 <code>onRestoreInstanceState</code> 进行数据的读取：</p>

<p>```</p>

<pre><code>private boolean shouldSaveData = false;

private static final String KEY_SHOULD_SAVE_DATA = "save_data_key";

@Override
protected void onSaveInstanceState(Bundle outState) {
    outState.putBoolean(KEY_SHOULD_SAVE_DATA, shouldSaveData);
    super.onSaveInstanceState(outState);

    Log.i(TAG, "@@Activity onSaveInstanceState@@" + this.toString());
}

@Override
protected void onRestoreInstanceState(Bundle savedInstanceState) {
    super.onRestoreInstanceState(savedInstanceState);
    shouldSaveData = savedInstanceState.getBoolean(KEY_SHOULD_SAVE_DATA);
    Log.i(TAG, "@@Activity onRestoreInstanceState@@" + this.toString());
}
</code></pre>

<p>```</p>

<h3>Activity 中弹框的状态保存及恢复</h3>

<p>在 Activity 中经常会遇到 Dialog，甚至像下面具有输入框的 Dialog：</p>

<p><img src="http://7xj9js.com1.z0.glb.clouddn.com/activity_signature_dialog.png" width="400" alt="Android Dialog" /></p>

<p>当用户点击 Login 按钮，弹出弹框需要用户签名，这时如果屏幕不小心进行了一次旋转，那么这个弹出的 Dialog 便消失，随之消失的还有用户输入了一半的输入框文字。Activity 在旋转过程中对于 Dialog 自身的生命周期进行很好的管理，如果为了达到更好的用户体验，转屏时也需要保存输入框状态，那么此处我们强烈推荐用户使用 <a href="http://developer.android.com/reference/android/app/DialogFragment.html">DialogFragment</a> 代替 Dialog。</p>

<p>由于 Fragment 也具有生命周期，使用 DialogFragment 之后，我们结合 Activity 与 Fragment 的生命周期，查看整个过程经历了哪些流程。</p>

<p><img src="http://7xj9js.com1.z0.glb.clouddn.com/fragment_lifecycle.png" width="300" alt="Frgament 生命周期" /></p>

<p>结合 DialogFragment 在 Activity 中旋转的重新初始化及数据恢复，我们可以看到执行顺序如下：</p>

<p><img src="http://7xj9js.com1.z0.glb.clouddn.com/activity_fragment_rotate.png" width="500" alt="Android Fragment 执行顺序" /></p>

<p>在转屏时，Activity 和 Fragment 都会重新实例化，并且都通过 <code>onSaveInstanceState</code> 进行状态保存。值得注意的是不同于 Activity, Fragment 并没有 <code>onRestoreInstanceState</code> 方法，Fragment 的状态恢复在 <code>onActivityCreated</code> 方法中。查看 DialogFragment 源码，我们可以看到如下调用：</p>

<p>```</p>

<pre><code>@Override
public void onActivityCreated(Bundle savedInstanceState) {
    super.onActivityCreated(savedInstanceState);
    ...
    if (savedInstanceState != null) {
        Bundle dialogState = savedInstanceState.getBundle(SAVED_DIALOG_STATE_TAG);
        if (dialogState != null) {
            mDialog.onRestoreInstanceState(dialogState);
        }
    }
}

...

@Override
public void onSaveInstanceState(Bundle outState) {
    super.onSaveInstanceState(outState);
    if (mDialog != null) {
        Bundle dialogState = mDialog.onSaveInstanceState();
        if (dialogState != null) {
            outState.putBundle(SAVED_DIALOG_STATE_TAG, dialogState);
        }
    }
    ...
}
</code></pre>

<p>```</p>

<p>由于 DialogFragment 其实就是展示一个 Dialog，而 DialogFragment 对 Dialog 的状态保存及恢复使得 Dialog 的状态得以保存。</p>

<h2>Fragment 状态的保存及恢复</h2>

<p>有了上面对 DialogFragment 转屏时状态保存及恢复的研究，那么在一个普通的 Fragment(DialogFragment 是一种特殊的 Fragment) 中状态保存及恢复又是怎样的呢？</p>

<p>实际上通过 DialogFragment 我们可以知道保存状态值还是通过 <code>onSaveInstanceState</code> 方法，而 <code>onActivityCreated</code> 中则可以获取状态值。</p>

<p>在转屏时，我们会有很多特殊的考虑。所以如果你的 App 需要支持横竖屏切换，你可以留意如下几点：</p>

<h3>1. Dialog 转屏消失问题</h3>

<p>Dialog 转屏消失在现实中是一个很常见的情形，对应的解决方案就是利用 DialogFragment 来替代 Dialog。这样旋转屏幕时弹起的 Dialog 就不会消失。</p>

<h3>2. Fragment 保存组件信息的坑</h3>

<p>最近在项目中发现，有时候放置在 Fragment 中的 ListView 转屏后不能自动回到转屏之前的位置。后来发现导致原因是 Activity 的 Layout 在添加 Fragment 时候没有指定 id 或 tag。于是该 Fragment 在 Activity 重绘时不能被系统当作 “同一个” Fragment，所以旋转时控件的一些基本状态信息没办法恢复。</p>

<p>```
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;utf-8&rdquo;?>
&lt;fragment xmlns:android=&ldquo;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&rdquo;</p>

<pre><code>android:id="@+id/home_fragment"
android:layout_width="match_parent"
android:layout_height="match_parent" android:paddingLeft="@dimen/activity_horizontal_margin"
android:paddingRight="@dimen/activity_horizontal_margin"
android:paddingTop="@dimen/activity_vertical_margin"
android:paddingBottom="@dimen/activity_vertical_margin"
android:name="net.gongmingqm10.androidrotate.HomeFragment" /&gt;
</code></pre>

<p><code>``
其中的</code>android:id=&ldquo;@+id/home_fragment&rdquo;` 是重点。一旦 Fragment 的状态保存出现问题，可先确认 Fragment 是不是设置了 id 或 tag。</p>

<h3>3. 使用 setRetainInstance</h3>

<p>关于 Fragment，我们发现 <code>setRetainInstance</code> 方法经常被用到，那么这个方法的作用是什么呢？我们看看官方的解释：</p>

<p>```</p>

<pre><code>/**
 * Control whether a fragment instance is retained across Activity
 * re-creation (such as from a configuration change).  This can only
 * be used with fragments not in the back stack.  If set, the fragment
 * lifecycle will be slightly different when an activity is recreated:
 * &lt;ul&gt;
 * &lt;li&gt; {@link #onDestroy()} will not be called (but {@link #onDetach()} still
 * will be, because the fragment is being detached from its current activity).
 * &lt;li&gt; {@link #onCreate(Bundle)} will not be called since the fragment
 * is not being re-created.
 * &lt;li&gt; {@link #onAttach(Activity)} and {@link #onActivityCreated(Bundle)} &lt;b&gt;will&lt;/b&gt;
 * still be called.
 * &lt;/ul&gt;
 */
</code></pre>

<p><code>``
结合方法名以及方法的解释，可以知道一旦我们设置</code>setRetainInstance(true)<code>，意味着在 Activity 重绘时，我们的 Fragment 不会被重复绘制，也就是它会被“保留”。为了验证其作用，我们发现在设置为</code>true<code>状态时，旋转屏幕，Fragment 依然是之前的 Fragment。而如果将它设置为默认的 false，那么旋转屏幕时 Fragment 会被销毁，然后重新创建出另外一个 fragment 实例。并且如官方所说，如果 Fragment 不重复创建，意味着 Fragment 的</code>onCreate<code>和</code>onDestroy<code>方法不会被重复调用。所以在旋转屏 Fragment 中，我们经常会设置</code>setRetainInstance(true)`，这样旋转时 Fragment 不需要重新创建。</p>

<p>如果你的 App 恰好可以不做转屏，那么你可以很省事的在 Manifest 文件中添加标注，强制所有页面使用竖屏/横屏。如果你的页面不幸的需要支持横竖屏切换，那么你在预估工作量或者给客户报价时一定要考虑到。虽然加入转屏支持不会导致工作量翻倍，但是却有可能引起许多问题。尤其当页面有很多业务逻辑，有状态值的时候。所以我们在项目开发过程中，应该知道什么时候需要考虑状态保存，当状态保存出现问题时，应该怎么解决之。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android 新手成长计划]]></title>
    <link href="http://www.gongmingqm10.net/blog/2015/11/30/android-xin-shou-jiao-cheng/"/>
    <updated>2015-11-30T21:17:42+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2015/11/30/android-xin-shou-jiao-cheng</id>
    <content type="html"><![CDATA[<p><img src="http://www.webmastergrade.com/wp-content/uploads/2011/04/Android-VS-Apple.jpg" width="500" alt="Android starter" /></p>

<p>最近在公司里开始遇到了新人培养的问题，新人被 assign 到 Android 项目上，为了让他能够很快有所产出，于是我们得思考怎么样快速锻炼一个新人并让他对 Android 开发产生兴趣并持续做下去呢？当然也会有一时兴起的同事会想着学习 Android，Android 入门门槛不高，但是要想真正的熟练驾驭，确实是一件道阻且长的事情，需要付出额外的努力。</p>

<!-- more -->


<h2>兴趣驱动法则</h2>

<p>其实“兴趣”不只是在 Android 开发上体现的重要，兴趣在任何地方都是最重要的。之前接触过一些朋友，某次会突然告诉我想学习 Android，但是往往一个 Hello World 都可以将之难倒。这时候学习者明显缺少兴趣驱动。Android 开发好玩的一点是我们开发的应用都可以很简单的在手机上安装使用。所以你可以尽情尝试各种新奇的点子。</p>

<p>当然，兴趣并不是本文讨论的重点，我们假设真心想学习的人都是出于兴趣。</p>

<h2>循序渐进的练习计划</h2>

<p>有了兴趣远远还不够，兴趣只能促使你完成一个 Hello World，要想真正做出东西还应该有循序渐进的计划来配合。我当时学习 Android 的方法就是每周一个任务。把学习新知识当作升级打怪，这样子你还会松懈吗？</p>

<h3>你应该掌握的 Android 开发知识</h3>

<p>Android 开发的入门门槛不高，但是细节知识真心不少。作为初学者，我们可以先了解广度，然后了解深度。刚开始可以接触尝试了解一点远离性的知识，然后直接运用一些流行的框架。快速迭代完成一个 App。那么对于新手而言，应该掌握的 Android 开发知识有哪些呢？</p>

<h4>1. Hello Android</h4>

<p>开发调试基础看起来比较模糊，具体一点是完成一个 Hello World，让此应用运行在你的手机或者模拟器中。借此了解各个文件夹模块的作用以及 App 运行的基础原理。涵盖知识点如下：</p>

<ul>
<li>搭建 Android 开发环境： Java + Android Studio + SDK；</li>
<li>熟悉项目结构：src, res, assets, values, layouts, drawable/mipmap, styles, AndroidManifest.xml, Activity；</li>
<li>解读 Hello World 运行机制：项目从哪里运行，Activity 与 layout 的关联，Activity 中如何找到布局中的实例化控件，Activity 的生命周期；</li>
</ul>


<h4>2. 计算器</h4>

<p>计算器的经典程度不亚于 Hello World，Android 计算器能够让初学者迅速建立信心，同时作为一个单纯的无网络交互的应用，计算器主要处理布局，点击事件，计算逻辑。因此在了解了 Hello World 之后做计算器，再合适不过了。计算器最终效果图如下：</p>

<p><img src="http://7xj9js.com1.z0.glb.clouddn.com/calculator.png" width="300" alt="计算器" /></p>

<p>那么对于计算器这个 demo 的要求如下：</p>

<ul>
<li>界面效果如上图，并且能够进行简单的整数运算：<code>1+1, 4*2, 6/3, 1-10</code> 等；</li>
<li>异常处理，除数为 0 时界面提示 <code>Error</code>；</li>
<li>小数点以及连续运算的支持；</li>
<li>继承 Robolectric 添加单元测试；</li>
<li>每次打开 App 结果栏会自动显示上一次的运算结果；</li>
<li>添加<code>History</code>菜单，点击列表显示历史计算表达式以及结果；</li>
</ul>


<p>通过这些要求，涵盖的知识点如下：</p>

<ul>
<li>布局管理器的了解及使用：RelativeLayout, LinearLayout；</li>
<li>Android 控件添加点击事件，TextView 动态设值；</li>
<li>Android 项目集成 Robolectric，添加简单的单元测试；</li>
<li>Android 数据持久化保存 &ndash; SharedPreferences；</li>
<li>Android 数据持久化存储 &ndash; Sqlite 数据库；</li>
<li>Android ListView 列表及数据绑定；</li>
<li>Android Activity 跳转 &ndash; Intent；</li>
<li>添加 <a href="http://jakewharton.github.io/butterknife/">ButterKnife</a> 框架，重构项目；</li>
<li>添加 <a href="http://greenrobot.org/greendao/">GreenDao</a> 框架，重构数据库数据存储及读取；</li>
</ul>


<h4>3. 豆瓣图书列表 &ndash; 图片缓存</h4>

<p>豆瓣图书列表最初起源于公司内部的一次 Android 培训，由于对 Android 初学者而言，还比较有意义，于是设置为专题的形式供大家练习。需求很简单，将给定的图书列表数据(JSON 格式)显示到界面上。包括图书信息在列表中展示，网络图片的加载以及缓存。JSON 数据<a href="http://7xj9js.com1.z0.glb.clouddn.com/douban-books.json">点击此处</a>查看。完成之后效果图如下：</p>

<p><img src="http://7xj9js.com1.z0.glb.clouddn.com/douban-reading.png" width="300" alt="Douban Books" /></p>

<p>具体要求如下：</p>

<ul>
<li>列表显示图书信息：图书图片，名称，作者／出版社／出版年份，评价，简介；</li>
<li>多次滑动列表，保证文字以及图片显示不会发生错位，并且始终流畅（有列表控件重用）；</li>
<li>添加图片缓存：图片加载成功后，断开网络，退出 App，打开应用仍然能够正确显示图片；</li>
</ul>


<p>通过这些要求我们期望初学者掌握的技能点如下：</p>

<ul>
<li>Android ListView 自定义列表样式；</li>
<li>Android Adapter 使用 ViewHolder 进行控件复用；</li>
<li>Android 主线程（UI线程）的概念，主线程阻塞的解决方案，Handler 的概念以及使用方法；</li>
<li>图片缓存的应用，内存级别的缓存以及磁盘级别的缓存；</li>
<li>使用 <a href="http://square.github.io/picasso/">Picasso</a>/<a href="https://github.com/nostra13/Android-Universal-Image-Loader">ImageLoader</a> 图片加载及缓存框架，简化开发；</li>
</ul>


<p>如果你对图片缓存部分的实现有任何疑惑，请参考工程 <a href="https://github.com/gongmingqm10/AndroidWorkshop/tree/2nd-step4">AndroidWorkShop</a>。图片磁盘缓存部分参考了 Android 官方教程。</p>

<h4>4. 豆瓣图书列表 &ndash; 网络请求</h4>

<p>这个任务其实是对第 3 条任务的改造。不同之处在于，本次任务侧重于让初学者了解如何快速构建出一个有网络请求模块的 App。我们的效果图和上一条任务的相同，不同点在于本次我们会使用真实的网络API数据。并且会对 API 请求回来的数据进行缓存。具体要求如下：</p>

<ul>
<li>推荐使用 <a href="http://square.github.io/retrofit/">Retrofit</a> 框架，从豆瓣读书 API 网络获取<a href="https://api.douban.com/v2/book/search?q=Java">图书列表</a>及<a href="http://api.douban.com/v2/book/2130190">图书详情</a>。详情参见<a href="http://developers.douban.com/wiki/?title=guide">豆瓣API</a>；</li>
<li>列表显示豆瓣图书列表，图片显示可直接使用 Picasso；</li>
<li>点击 Item 跳转至图书详情界面，显示该书籍详细信息；</li>
<li>缓存此 API 的搜索结果 (文件或者数据库Key-Value的形式缓存JSON数据)；</li>
<li>使用 SwipeRefreshLayout 添加下拉刷新功能，下拉刷新时重新添加请求数据并更新缓存；</li>
</ul>


<p>此任务我们期望初学者掌握的知识点：</p>

<ul>
<li>Retrofit 框架的使用；</li>
<li>Android 数据缓存的简易实现方案（数据库／文件形式）；</li>
<li>简单的列表点击事件，页面跳转等；</li>
<li><a href="http://android-developers.blogspot.com/2015/05/android-design-support-library.html">Android Design Support Library</a> 中常用的组件及使用；</li>
</ul>


<h4>5. 设计并实现你自己的 App</h4>

<p>如果你顺利完成了上述四条任务，那么这一步你应该已经具备了完成一个简单的 App 的技能，这一步可以按照个人兴趣完成自己的创意点子。在开始编码之前，可以先制作出一套 UI 交互图，然后整理 API 并开始编码。</p>

<h3>Android 学习常用的链接</h3>

<p>Android 拥有全面的官方学习教程以及各种丰富的开源库。我们初学时可以多浏览官方教程学习一些好的实现，下面列举了一些很常用的链接：</p>

<ol>
<li><a href="developer.android.com/training/index.html">Android 官方文档</a></li>
<li><a href="http://android-developers.blogspot.com/">Android 官方博客</a></li>
<li><a href="www.google.com/design/spec/style/color.html#">Google Material Design</a></li>
<li><a href="http://square.github.io/">Square Open Source</a></li>
<li><a href="http://jakewharton.com/">Jake Wharton 的博客</a></li>
</ol>


<p>全文很多观点都是一家之言，更多的是结合自己的项目经验以及学习经验总结而成，如有谬误及不当之处，请读者不吝赐教。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Adapter notifyDataSetChanged Not Working]]></title>
    <link href="http://www.gongmingqm10.net/blog/2015/11/29/android-adapter-notifydatasetchanged-not-working/"/>
    <updated>2015-11-29T11:30:39+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2015/11/29/android-adapter-notifydatasetchanged-not-working</id>
    <content type="html"><![CDATA[<p>刚开发 Android 开发时，总是遇到一个看似很简单的问题 “Android Adapter notifyDataSetChanegd 不生效”，而每次解决这个问题的方法总是简单粗暴，直接了当。大概是以前的时候做事以结果导向，所以对于这些奇怪的问题也总是没有深究。刚好最近在项目中再次遇到了这个问题，决心深究一下。</p>

<p><img src="http://7xj9js.com1.z0.glb.clouddn.com/Its_not_working_anymore.png" width="500" alt="notifyDataSetChanged not working" /></p>

<!-- more -->


<h3>Adapter notifyDataSetChanged 做了什么事</h3>

<p>要弄清楚 <code>adapter.notifyDataSetChanged</code> 为什么不工作，还是应该首先弄清楚它究竟做了什么事情。根据函数名的描述，主要是通知 “数据源改变”，从而刷新页面，这样新改变的数据就呈现在用户面前了。</p>

<p>Android Adapter 使用了观察者模式，每一个 ListView 可以实例化出一个 Observer，而每个 Adapter 则会实例化出一个 Subject。在 ListView setAdapter 的时候，Adapter 会将 ListView 中实例化的 Observer 注册入观察者列表中。当 Adapter 通过观察者更新时，则会调用 Observer 的 notifyChanged() 方法，如此重新刷新 ListView 的界面。</p>

<p>这个通知者模式的 UML 关系图大致可以描述如下：</p>

<p><img src="http://7xj9js.com1.z0.glb.clouddn.com/adapter%20obervable%20pattern.png" width="500" alt="notifyDataSetChanged not working" /></p>

<p>继续查看 ListView.setAdapter 方法，可以看到在设置 Adapter 的时候，ListView 会将自己的 Observer 注册入 Subject:</p>

<p>```</p>

<pre><code>@Override
public void setAdapter(ListAdapter adapter) {
    if (mAdapter != null &amp;&amp; mDataSetObserver != null) {
        mAdapter.unregisterDataSetObserver(mDataSetObserver);
    }

    ...

    super.setAdapter(adapter);

    if (mAdapter != null) {
        ...
        mDataSetObserver = new AdapterDataSetObserver();
        mAdapter.registerDataSetObserver(mDataSetObserver);

        ...
        }
    }

    ...
}
</code></pre>

<p>```</p>

<h3>为什么 notifyDataSetChanged 生效</h3>

<p>既然 <code>notifyDataSetChanged</code> 能够促使 ListView 重绘界面，那么让其生效的方式就是保证 Adapter 中的数据源生效，这样在 ListView 重绘时才能使用新的数据刷新界面。看下面一段失效的 ListView 更新失效的问题。</p>

<p>```</p>

<pre><code>    ListView itemList = (ListView) findViewById(android.R.id.list);
    data = new ArrayList&lt;&gt;();
    data.addAll(Arrays.asList("Item 1", "Item 2", "Item 3"));
    adapter = new ItemListAdapter(data);
    itemList.setAdapter(adapter);

    findViewById(R.id.fab).setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            // 模拟请求 API 刷新重新获得数据
            data = new ArrayList&lt;&gt;();
            data.addAll(Arrays.asList("Item 1", "Item 2", "Item 3", "Item 4"));
            adapter.notifyDataSetChanged();
        }
    });
</code></pre>

<p>```</p>

<p>让我们分析失效的原因，首先将 ArrayList data 设置为 Adapter 的数据源，而 Java 是引用传值，所以在 onClick() 回调函数中，当我们对 data 重新赋值时，重新赋值后的 data 并不能和 Adapter 中的数据源产生关联。因此 Adapter 中的数据源还是 “Item 1”, “Item 2”, &ldquo;Item 3"。所以这里无论怎样调用 notifyDataSetChanged 都是不能生效的。</p>

<h3>如何让 notifyDataSetChanged 生效</h3>

<p>让更新生效的方式是，让你的 Adapter 保持最新数据源。就上述例子来看，当 data 更新新值时，我们可以通过 List.add() 来更新 Adapter 中引用对应的值。实现代码如下：</p>

<p>```</p>

<pre><code>    ListView itemList = (ListView) findViewById(android.R.id.list);
    data = new ArrayList&lt;&gt;();
    data.addAll(Arrays.asList("Item 1", "Item 2", "Item 3"));
    adapter = new ItemListAdapter(data);
    itemList.setAdapter(adapter);

    findViewById(R.id.fab).setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            data.add("New Item " + view.toString());
            adapter.notifyDataSetChanged();
        }
    });
</code></pre>

<p>```</p>

<h3>End</h3>

<p>Android 中有很多优秀的设计，当我们出现问题时，可以通过阅读源码的方式探索，并结合 Google 的相关资料，了解事物的根源，方能设计出更优秀的代码。</p>
]]></content>
  </entry>
  
</feed>
