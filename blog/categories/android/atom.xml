<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: android | gongmingqm10]]></title>
  <link href="http://www.gongmingqm10.net/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://www.gongmingqm10.net/"/>
  <updated>2014-10-29T11:28:21+08:00</updated>
  <id>http://www.gongmingqm10.net/</id>
  <author>
    <name><![CDATA[Gong Ming]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android电话监听]]></title>
    <link href="http://www.gongmingqm10.net/blog/2014/10/29/androiddian-hua-jian-ting/"/>
    <updated>2014-10-29T11:11:48+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2014/10/29/androiddian-hua-jian-ting</id>
    <content type="html"><![CDATA[<p>看题名，本篇博文似乎是关于怎么监听别人的电话。其实不然，这里我主要做的是监听自己的电话。监听自己电话的场景来源如下：<br/>
我最近在换手机，当然也在换号。于是面对两个号码两部手机，特别是一些捆绑了银行卡活着以前的快递等情况下，我必须得带两部手机出门，防止旧手机上重要的电话漏接。最开始是想直接进行通过转接，但是面对电信和移动间的通话转移，我放弃了这个想法。于是开始想着用软件提醒。<br/>
在老手机上安装APP，这个APP的作用是监听来电，来电挂断之后会自动给你设定的新手机上发送短信，告诉你谁给你打来了一个未接电话，这样你在新手机上看到短信来电提醒，于是可以直接在新手机上进行回复了。虽然不能直接解决通话的问题，但是确解决了我的问题。考虑到老手机上每个月的短信套餐，发现其实成本也几乎为零。</p>

<p>实现部分主要注册一个CallReceiver，并给我们的Receiver监听电话，发送短信，开机重启等权限。编译通过后便可以安装在手机上使用了。贴出主要代码：</p>

<p>```
package net.gongmingqm10.callwatcher;</p>

<p>import android.app.Service;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.telephony.SmsManager;
import android.telephony.TelephonyManager;
import android.util.Log;</p>

<p>public class CallReceiver extends BroadcastReceiver {</p>

<pre><code>private final static String NUMBER = "Your Phone number"; //我的新手机号
@Override
public void onReceive(Context context, Intent intent) {
    if (intent.getAction().equals(Intent.ACTION_NEW_OUTGOING_CALL)) return;
    TelephonyManager tm = (TelephonyManager) context.getSystemService(Service.TELEPHONY_SERVICE);
    SmsManager sms = SmsManager.getDefault();
    Log.i("state", "state = " + tm.getCallState());
    if (tm.getCallState() == TelephonyManager.CALL_STATE_IDLE) {
        String incomingNumber = intent.getStringExtra("incoming_number");
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        sms.sendTextMessage(NUMBER, "", "主人，有人给你附属机打电话了：" + incomingNumber, null, null);
    }
}
</code></pre>

<p>}</p>

<p>```</p>

<p>```
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;utf-8&rdquo;?>
&lt;manifest xmlns:android=&ldquo;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&rdquo;</p>

<pre><code>package="net.gongmingqm10.callwatcher" &gt;

&lt;uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"/&gt;
&lt;uses-permission android:name="android.permission.READ_PHONE_STATE"/&gt;
&lt;uses-permission android:name="android.permission.PROCESS_OUTGOING_CALLS"/&gt;
&lt;uses-permission android:name="android.permission.SEND_SMS"/&gt;

&lt;application
    android:allowBackup="true"
    android:icon="@drawable/ic_launcher"
    android:label="@string/app_name"
    android:theme="@style/AppTheme" &gt;
    &lt;activity
        android:name=".MainActivity"
        android:label="@string/app_name" &gt;
        &lt;intent-filter&gt;
            &lt;action android:name="android.intent.action.MAIN" /&gt;

            &lt;category android:name="android.intent.category.LAUNCHER" /&gt;
        &lt;/intent-filter&gt;
    &lt;/activity&gt;
    &lt;receiver android:name=".CallReceiver"&gt;
        &lt;intent-filter&gt;
            &lt;action android:name="android.intent.action.BOOT_COMPLETED"/&gt;
            &lt;action android:name="android.intent.action.PHONE_STATE"/&gt;
            &lt;action android:name="android.intent.action.NEW_OUTGOING_CALL"/&gt;
        &lt;/intent-filter&gt;
    &lt;/receiver&gt;
&lt;/application&gt;
</code></pre>

<p></manifest></p>

<p>```</p>

<p>主界面几乎没任何交互。主要实现功能，想更多交互的话可以继续～</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Data Cache]]></title>
    <link href="http://www.gongmingqm10.net/blog/2014/10/28/android-data-cache/"/>
    <updated>2014-10-28T17:11:26+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2014/10/28/android-data-cache</id>
    <content type="html"><![CDATA[<p>Android APP开发过程中，我们通常会加入缓存模块。缓存即在本地保存APP的一些数据，大部分是将网络请求的数据进行本地保存，这样在缓存数据有效期内就可以直接使用缓存数据，降低了APP和服务器的压力，也极大提升了用户体验。Android数据缓存既可以以数据表的形式进行保存，也可以以文件的形式进行缓存。这里我主要通过缓存文件存储数据，并在APP下一次启动时读取。</p>

<h3>Usage</h3>

<p>整个Cache模块的设计思想很简单，每个缓存数据都对应一个key，每个缓存数据又会被存到以此key命名的文件中，需要时直接读取。关键类分别为<code>CacheData</code>, <code>CacheManager</code>, <code>CacheUtils</code>。</p>

<ul>
<li>CacheData：数据封装类，所有欲缓存的数据都通过CacheData封装，CacheData中能够定义缓存有效期，并可以通过getData()直接获取真实的缓存数据。</li>
<li>CacheManager: 缓存管理类，单例模式设计，负责缓存的存储和读取。</li>
<li>CacheUtils: 缓存常用类，所有的缓存Key都应该在这个类中定义，此类还定义了一些时间常量，缓存有效期中可以使用。</li>
</ul>


<p>使用方法如下：</p>

<ul>
<li>step1: <code>CacheManager.init(Context context)</code>, 在APP加载时就应该对CacheManager初始化。</li>
<li>step2: 自定义的Model需要实现序列化，使用CacheData进行包装，然后使用CacheManager进行存储和读取。</li>
</ul>


<h3>Code Download</h3>

<p>项目代码托管在<a href="https://github.com/gongmingqm10/AndroidUikit/tree/master/library/src/main/java/org/gongming/common/cache">Github Repo</a>中，欢迎star和fork。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Openfire - Android IM 框架使用]]></title>
    <link href="http://www.gongmingqm10.net/blog/2014/10/21/openfire-android-im-kuang-jia-shi-yong/"/>
    <updated>2014-10-21T10:02:58+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2014/10/21/openfire-android-im-kuang-jia-shi-yong</id>
    <content type="html"><![CDATA[<p>IM(Instant Messaging)在Android中可谓运用广泛。QQ，Wechat，陌陌等应用都可以看作IM实时通讯APP，实时通讯在社交类APP中运用范围较广，其功能看起来也是比较cool的。今天我们将研究一下android IM软件是如何实现的。像IM这种实施通讯软件，除非公司有比较大的实力和精力，才会自己去整这么一套框架。对于广大中小软件开发者来说，想到比较多的就是开源框架。Opensource对于开发者来说简直就是福音，对于整个软件行业也起到了不小的推动性的作用。<br/>
Openfire在这种环境下应运而生，而且作为实时通讯类开源框架迅速走红，下面我们就一起来学习这样一款拯救宇宙的开源框架，文章的最后会运用Openfire做出一个可以实时通讯的AndroidAPP，如果结合上地理位置再多点UI和交互上的设计提升，这不就是陌陌吗？YY了一会，觉得挺有趣，那么 <code>Just do it</code>。</p>

<p>Openfire概念性介绍请点击：<a href="http://blog.csdn.net/ithomer/article/details/7192257">http://blog.csdn.net/ithomer/article/details/7192257</a><br/>
Openfire官网：<a href="http://www.igniterealtime.org/">http://www.igniterealtime.org/</a><br/>
Openfire安装文档：<a href="http://www.igniterealtime.org/builds/openfire/docs/latest/documentation/install-guide.html">http://www.igniterealtime.org/builds/openfire/docs/latest/documentation/install-guide.html</a></p>

<h3>1. 选择服务器</h3>

<p>对于实时通讯软件，除了我们的客户端，服务器端更是关键。因为服务器是连接两个会话的桥梁。根据安装文档中，Openfire提供了多个平台的安装版本。Windows, Linux/Unix。所以支持还是很丰富的。至于服务器的选择我们可以选择自己的ECS，本地PC，或者Linux虚拟机。选择本机安装的请略过此步骤。<br/>
为了更加符合真实的安装环境，我选择本地的Linux虚拟机作为服务器环境。方便以后部署到真实的服务器环境中。  <br/>
在进行下一步之前请先在server上安装mysql和java。</p>

<h3>2. Install openfire</h3>

<p>从官网上下载对应的版本，我这里选择<a href="http://www.igniterealtime.org/downloads/index.jsp">Openfire_3.9.3 Linux版本</a>，登陆服务器后直接使用wget下载</p>

<p>```
wget <a href="http://www.igniterealtime.org/downloadServlet?filename=openfire/openfire-3.9.3-1.i386.rpm">http://www.igniterealtime.org/downloadServlet?filename=openfire/openfire-3.9.3-1.i386.rpm</a></p>

<p>//下载完成后使用rpm进行安装</p>

<p>rpm -ivh openfire-3.9.3-1.i386.rpm</p>

<p>```
Openfire安装完成后会在/opt目录下生成openfire/目录。
安装完成后就需要进行数据库的配置，按照官方文档：</p>

<p>```
Make sure that you are using MySQL 4.1.18 or later (5.x recommended) ¹.
Create a database for the Openfire tables:
mysqladmin create [databaseName]
(note: &ldquo;databaseName&rdquo; can be something like &lsquo;openfire&rsquo;)
Import the schema file from the resources/database directory of the installation folder:
Unix/Linux: cat openfire_mysql.sql | mysql [databaseName];
Windows: type openfire_mysql.sql | mysql [databaseName];
Start the Openfire setup tool, and use the appropriate JDBC connection settings.</p>

<p>```</p>

<p>首先使用<code>mysqladmin create openfire</code>创建名为openfire的数据库, <code>cd /opt/openfire/resources/database</code>进入openfire的数据库资源目录，使用<code>cat openfire_mysql.sql | mysql openfire</code>导入openfire的schema数据库文件。</p>

<h3>3. 启动Openfire服务</h3>

<p>使用rpm安装完成后的openfire会在/etc/init.d/中自动生成openfire 文件，可以直接在这里打开服务.</p>

<p>```
Usage /etc/init.d/openfire {start|stop|restart|status|condrestart|reload}</p>

<p>```</p>

<p>运行openfire服务：<code>/etc/init.d/openfire start</code>，运行<code>/etc/init.d/openfire status</code>显示没有成功运行。<br/>
查看log <code>cat /opt/openfire/logs</code>，显示<code>nohup: cannot run command /opt/openfire/jre/bin/java: No such file or directory</code>，看来openfire找不到java，所以不能成功启动，但是我们的系统的确已经安装了java，所以可以通过软链解决：</p>

<p>```
cd /opt/openfire/jre/bin
cp java java.bak
rm java
ln -s /usr/bin/java java
service openfire start</p>

<p>```</p>

<p>软链完成之后，再次开启openfire服务：</p>

<p>```
[root@iZ23572i0rtZ bin]# /etc/init.d/openfire status
openfire is not running
[root@iZ23572i0rtZ bin]# /etc/init.d/openfire start
Starting openfire:
[root@iZ23572i0rtZ bin]# /etc/init.d/openfire status
openfire is running</p>

<p>```
status显示openfire已经成功启动。通过虚拟机ip访问9090端口，这时会跳转到setup界面，只需要通过setup便可以完成相关配置。</p>

<p>配置完成之后即可以登录自己的管理控制台。</p>

<h3>4. Integrate to Android</h3>

<p>既然服务器安装完成，那我们可以着手我们的APP。与Openfire关联的客户端XMPP协议库是smack。摸索一番之后发现，要在Android中使用Smack必须使用ASmack库。<a href="http://asmack.freakempire.de/">ASmack下载地址</a>。<br/>
以实例为主，通过smack实现两个客户端之间的即时通信。<a href="https://github.com/gongmingqm10/SmackDemo">下载地址</a></p>

<h4>Attention</h4>

<ul>
<li>在AndroidManifest中必须添加Internet permission,否则连接失败。<code>&lt;uses-permission android:name="android.permission.INTERNET"/&gt;</code>.</li>
<li>客户端对客户端创建聊天时，SID为 username@XXXX, XXXX表示的是服务器名字，我这里是ECS主机名。</li>
</ul>


<h3>5. Github Repository</h3>

<p><a href="https://github.com/gongmingqm10/SmackDemo">https://github.com/gongmingqm10/SmackDemo</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android deploy your app]]></title>
    <link href="http://www.gongmingqm10.net/blog/2014/10/17/android-deploy-your-app/"/>
    <updated>2014-10-17T12:56:13+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2014/10/17/android-deploy-your-app</id>
    <content type="html"><![CDATA[<p>发布Android APP说通俗点就是“打包”，大部分情况下我们可以直接通过IDE进行签名打包，打包好的apk文件就可以上传到各大应用市场啦。今天项目开发过程中突然遇到需要更换debug.keystore的问题了，于是突然想好好研究一下Android打包的全过程，以及各个文件的作用。说做就做，how to publish your app?</p>

<h3>Proguard－代码混淆</h3>

<p>我们经常在js库中看到各种代码混淆，代码混淆主要是对你的代码的类名，方法名以及字段名进行命名，并删除一些无用的换行空格等。让你的代码变得难以读懂，这样能够防止别人反编译你的代码后窃取你的内容。<br/>
android中代码混淆主要使用IDE自动生成的文件，并通过一些简单的配置就可以实现。中间的混淆步骤则不需要我们关系，android编译过程中自身会处理这些内部的逻辑。我们只需要配置文件就可以。<br/>
通过官网提供的资料，<a href="http://developer.android.com/tools/help/proguard.html">http://developer.android.com/tools/help/proguard.html</a>，以及网上的大部分资料都是过时的，目前的AndroidStudio0.89中生成project时候只会生成proguard.cfg文件，要想启用proguard代码混淆，我们只需要在app的build.gradle中添加下述配置：</p>

<p>```
android {</p>

<pre><code>buildTypes {
    release {
        runProguard true
        proguardFile getDefaultProguardFile('proguard-android.txt')
    }
}
</code></pre>

<p>}</p>

<p>```</p>

<p>而这个proguard-android.txt则在<code>{sdk.dir}/tools/proguard/proguard-android.txt</code>中，这时proguard混淆时默认的文件，不过我们的sdk目录下却没有。Google君终于帮我们找到了：<a href="https://android.googlesource.com/platform/sdk/+/master/files/proguard-android.txt">https://android.googlesource.com/platform/sdk/+/master/files/proguard-android.txt</a>。于是简单粗暴的在tools/目录下新建proguard/proguard-android.txt文件。这时候android就可以使用默认文件进行混淆啦。</p>

<h3>Signing your application</h3>

<p>Android需要所有的应用在安装之前被数字签名，Android通过签名凭证识别应用的作者信息等。在App的Debug模式活着Release模式中都可以进行应用签名，在调试模式中一般是android自动生成凭证给App签名，而在Release发布模式中则需要开发者自己生成凭证来给用户签名。<br/>
我们主要关注在Release中怎么给自己的应用签名，签名之后的应用才可以发布到各市场中，在Release时给App签名：</p>

<ol>
<li>Create a keystore. Keystore是一个包含一些private key的二进制文件，你必须把这个文件放在一个安全独立的地方。</li>
<li>Create a private key. Private key 代表App作者的信息，例如一个开发者或者公司。</li>
<li>Build a project. 编译你的工程，这时会生成一个未签名的APP。</li>
<li>Sign your app. 用你的private key来生成你签名版本的APK。</li>
</ol>


<p>这样的APK就能够发布到市场中供用户更新下载。</p>

<p>签名既可以通过IDE直接操作，也可以通过android提供的工具在命令行中进行签名。在IDE中能够简单的生成一个keystore（需要说明的是不同的IDE生成的keystore文件格式是不一样的，主要有.jks, .keystore, 无后缀）。这些keystore在首次创建后下次就可以直接使用了。keystore包含的是一些软件作者的一些信息，也是你更新软件等的重要凭据。通过IDE签名的APK文件都经过了<code>jarsigner, zipalign</code>等操作，所以我们也不需要做额外的事情。<br/>
如果通过命令行来进行签名，这样的好处是使用命令来自动部署，开发者可以把所有的步骤写在一个shell文件中，部署时只要简单的run这个命令就可以实现了，如果需要编译很多个针对不同市场的版本，通过命令的模式就能够大大节约发布APP的时间。</p>

<p>更多详细信息请参考<a href="http://developer.android.com/tools/publishing/app-signing.html">http://developer.android.com/tools/publishing/app-signing.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android SIP 网络通话]]></title>
    <link href="http://www.gongmingqm10.net/blog/2014/10/17/android-sip-wang-luo-tong-hua/"/>
    <updated>2014-10-17T09:49:35+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2014/10/17/android-sip-wang-luo-tong-hua</id>
    <content type="html"><![CDATA[<p>突发奇想，想研究一下Android的网络通话怎么实现，于是从Google搜到了相关的资料。原来Android下集成了SIP（Session Initiation Protocol）。SIP的账号可以通过SIP提供商免费申请，申请后即可以通过用户名实现网络通话。于是也找了网上的一些资料，写了个AndroidSIP的小demo，demo实现后大家可以实现互拨，目前界面很简单，但是通话的功能应该是可以实现的。请各位看官试用之。<br/>
整体效果看起来还是蛮酷的，这里我们申请了两个免费的账号，在设备上安装之后就可以进行Network Call了。</p>

<p>免费SIP账号申请：<a href="http://www.linphone.org/free-sip-service.html">http://www.linphone.org/free-sip-service.html</a></p>

<p>官方参考文档：<a href="http://developer.android.com/guide/topics/connectivity/sip.html">http://developer.android.com/guide/topics/connectivity/sip.html</a></p>

<p>项目代码下载：<a href="https://github.com/gongmingqm10/AndroidSIP">https://github.com/gongmingqm10/AndroidSIP</a></p>

<p>任何问题，欢迎大家fork，发pull/request。</p>
]]></content>
  </entry>
  
</feed>
