<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[gongmingqm10]]></title>
  <link href="http://www.gongmingqm10.net/atom.xml" rel="self"/>
  <link href="http://www.gongmingqm10.net/"/>
  <updated>2015-09-14T23:26:10+08:00</updated>
  <id>http://www.gongmingqm10.net/</id>
  <author>
    <name><![CDATA[Gong Ming]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[DevOps Session 1]]></title>
    <link href="http://www.gongmingqm10.net/blog/2015/09/10/devops-session-1/"/>
    <updated>2015-09-10T22:09:55+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2015/09/10/devops-session-1</id>
    <content type="html"><![CDATA[<p>最近公司在组织DevOps培训，于是就有个这个系列的文章，作为培训笔记，作为以后参考。如果你还不知道DevOps概念，请参考<a href="https://zh.wikipedia.org/wiki/DevOps">Wikipedia</a>。</p>

<blockquote><p>DevOps（英文Development和Operations的组合）是一组过程、方法与系统的统称，用于促进开发（应用程序/软件工程）、技术运营和质量保障（QA）部门之间的沟通、协作与整合。</p></blockquote>

<h2>课前准备</h2>

<p>因为需要使用一台Linux机器来作为测试主机，我们使用VirtualBox安装<a href="http://releases.ubuntu.com/15.04/ubuntu-15.04-server-amd64.iso">Ubuntu Server</a>。安装完成之后，我们能够登录这台“服务器”。</p>

<!-- more -->


<h2>课堂内容</h2>

<h3>磁盘管理</h3>

<p>主要学习磁盘相关的基础命令，能够查看磁盘使用情况，挂载新的磁盘等操作。参考文章：<a href="http://os.51cto.com/art/201012/240726_all.htm">Linux磁盘管理三板斧的使用心得</a>。</p>

<h4>df 命令</h4>

<p><code>df -h</code> 显示磁盘使用情况</p>

<h4>fdisk 命令</h4>

<p><code>sudo fdisk -l</code> 列出已知的分区类型</p>

<p><code>sudo fdisk /dev/sda1</code> 对/dev/sda1进行磁盘分区</p>

<h4>mkfs 命令</h4>

<p>mkfs 命令用于在设备上（通常为磁盘）创建 Linux文件系统。mkfs 本身并不执行建立文件系统的工作，而是去调用相关的程序来执行。</p>

<p><code>sudo mkfs -t ext4 /dev/sda1</code> 将 /dev/sda1 分区格式化为 ext4 格式</p>

<h4>partprobe 命令</h4>

<p>使用 partprobe 可以不用重启系统配合 fdisk 工具创建新的分区。</p>

<h4>mount 命令</h4>

<p>mount 命令用于挂载文件系统</p>

<h3>常用目录操作</h3>

<h4>特殊目录</h4>

<ul>
<li><code>.</code> 当前目录</li>
<li><code>..</code>父级目录</li>
<li><code>~</code> 当前用户的home目录</li>
<li><code>-</code> 前一个工作目录</li>
<li><code>~account</code> account 用户的 home 目录</li>
<li><code>.filename</code> 隐藏文件</li>
</ul>


<h4>操作目录</h4>

<ul>
<li><code>cd</code> 进入某个目录</li>
<li><code>ls</code> 列出某个目录的文件信息</li>
<li><code>ls -l</code> 列表展现目录下所有文件信息，显示目录权限、创建者、时间、文件大小等</li>
<li><code>ls －al</code> 列表展现目录下所有文件（包含隐藏文件）信息，显示目录权限、创建者、时间、文件大小等</li>
<li><code>pwd</code> 显示当前目录</li>
<li><code>mkdir</code> 创建目录</li>
<li><code>rmdir</code> 删除空目录（如果需要删除非空目录，请使用 <code>rm -r</code>）</li>
</ul>


<h3>常用文件操作</h3>

<ul>
<li><code>cat</code> 显示文件所有内容</li>
<li><code>tac</code> 从最后一行开始显示</li>
<li><code>echo "hello world" &gt; log.txt</code> 向 log.txt 中写入内容 &ldquo;hello world&#8221;， 将覆盖原来的文件内容</li>
<li><code>echo "hello world 1" &gt;&gt; log.txt</code> 向 log.txt 中附加内容 &ldquo;hello world1&#8221;，添加的内容会在文件最后一行。如果文件不存在，则会被创建。</li>
<li><code>nl log.txt</code> 输入带行号的文件内容</li>
<li><code>head log.txt</code> 只看文件前几行内容</li>
<li><code>tail log.txt</code> 只看最后几行</li>
<li><code>od</code> 以二进制方式显示档案内容</li>
<li><code>cp</code> 复制</li>
<li><code>mv</code> 移动</li>
<li><code>rm</code> 删除</li>
</ul>


<h3>查找命令</h3>

<h4>find 命令</h4>

<p>find 命令主要用来查找文件。更多使用方法请 Google 之。</p>

<p><code>find . -name "mysql*" -type f</code> 查找以“mysql”开头的所有文件(不是文件夹)</p>

<h4>which 命令</h4>

<p>在 PATH 变量指定的目录中，搜索某个系统命令的位置。同时也可以验证某个命令是否存在。</p>

<p><code>which grep</code></p>

<h2>总结</h2>

<p>第一节课主要了解了 Linux 下面一些基础的命令使用方法。这些命令都是比较常用的，当然还是需要多实战，才能够更好的理解并运用TA。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android 应用的持续交付]]></title>
    <link href="http://www.gongmingqm10.net/blog/2015/06/29/android-testing-practice/"/>
    <updated>2015-06-29T11:40:16+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2015/06/29/android-testing-practice</id>
    <content type="html"><![CDATA[<p>当我们谈软件质量时，我们一般会谈到测试。测试作为保障软件质量的重要手段正在被开发者逐渐认知。谈到测试时，大部分人都知道Web测试，对于前端JS或者后台，大部分“靠谱”的创业公司也都会用测试来保证软件质量。可是对于起步相对较晚的移动端测试，用的人并不多。</p>

<p>在测试方面，Android早期即存在UIAtomator和Monkey之类的测试，但是用起来实在不方便。2013年，Google开源了针对An ndroid平台的移动测试框架 &ndash; Espresso。Espresso可以针对每个页面(Activity)进行测试。开发者可以根据ID获取到页面元素，然后进行点击、长按等操作。结合Junit和Mock等工具，使得移动端测试成为可能。移动端拥有了测试框架的辅助，借助CI平台，持续交付也成为可能。</p>

<!-- more -->


<h2>Android测试的类别</h2>

<p>从开发者角度来看，通常的Web平台测试可以分为单元测试、集成测试以及功能测试。移动应用主要用来显示数据，显示框输入数据，相应用户的点击、滑动等操作。所以Android应用的开发工作大部分集中在UI上。因此，App测试大致可分为UI单元测试和功能测试。</p>

<p>UI单元测试覆盖界面显示以及用户与界面的交互。功能测试则是确保功能的正确性。</p>

<p>为了更好的说明App中UI测试和功能测试如何进行的，以一个Story举例如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Story-101
</span><span class='line'>Summary: 登录模块，用户能够使用用户名和密码登录App。
</span><span class='line'>Acceptance criterions:
</span><span class='line'>
</span><span class='line'>Given 作为用户，我打开App进入首页；
</span><span class='line'>When 我点击“登录”按钮；
</span><span class='line'>Then 我跳转到登录页面；
</span><span class='line'>
</span><span class='line'>Given 作为用户，我在登录页面
</span><span class='line'>When 我只输入用户名
</span><span class='line'>Then 登录按钮处于Disable状态
</span><span class='line'>When 我输入密码
</span><span class='line'>Then 登录按钮可以点击，点击之后，调用API
</span><span class='line'>
</span><span class='line'>Given 作为用户，我在登录页面
</span><span class='line'>When 我输入正确的用户名和密码，并登录
</span><span class='line'>Then 页面跳转到首页
</span><span class='line'>
</span><span class='line'>Given 作为用户，我在登录页面
</span><span class='line'>When 我输入错误的用户名和密码，并登录
</span><span class='line'>Then 页面上方显示“用户名或密码错误”提示
</span><span class='line'>And 密码被清空，登录按钮重新Disable
</span></code></pre></td></tr></table></div></figure>


<h3>UI单元测试</h3>

<p>UI(User interaction)测试又指界面测试。界面是软件与用户交互的最直接的部分，通过UI测试核实用户和软件拥有正常的交互。</p>

<p>UI测试的功能点比较简单：比如点击按钮的行为，按钮是否应该被禁用，页面文字、颜色等信息，是否弹框，点击弹框按钮应该跳转到什么页面等。</p>

<p>在登录页面中，假设登录页面的名字为LoginActivity，这是需要写的UI测试如下：</p>

<p>1.Test login button is not available until username and password are filled</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>usernameEditText.setText("gongmingqm10")
</span><span class='line'>assertThat(loginButton.isDisabled()).isTrue()
</span><span class='line'>
</span><span class='line'>passwordEditText.setText("password")
</span><span class='line'>assertThat(loginButton.isDisabled()).isFalse()</span></code></pre></td></tr></table></div></figure>


<p>2.Test should invoke Api when login button is clicked</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>usernameEditText.setText("gongmingqm10")
</span><span class='line'>passwordEditText.setText("password")
</span><span class='line'>
</span><span class='line'>loginButton.performClick()
</span><span class='line'>
</span><span class='line'>verify(loginApi).login(eq("gongmingqm10"), eq("encryptedpassword")
</span></code></pre></td></tr></table></div></figure>


<p>3.Test should show error dialog when login failed</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>usernameEditText.setText("gongmingqm10")
</span><span class='line'>passwordEditText.setText("wrongpassword")
</span><span class='line'>activity.loginFailed()
</span><span class='line'>assertThat(passwordEditText.getText().toString()).isEqualTo("")
</span><span class='line'>assertThat(errorText).isVisibile()
</span><span class='line'>assertThat(errorText.getText().toString()).isEuqalTo("用户名或密码错误")
</span></code></pre></td></tr></table></div></figure>


<p>4.Test should navigate to home page when login succeed</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>usernameEditText.setText("gongmingqm10")
</span><span class='line'>passwordEditText.setText("correctpassword")
</span><span class='line'>activity.loginSuccess()
</span><span class='line'>String actualPageName = getNextStartedActivity().getComponentName()
</span><span class='line'>assertThat(actualPageName).isEqualTo(HomeActivity.class.getName())</span></code></pre></td></tr></table></div></figure>


<p>观察上述几个测试，我们可以看到对UI的测试粒度相对较小。主要测试用户输入，按钮点击，服务器返回结果之后，界面应该如何反应。UI测试通常也包括简单的单元测试，Android中需要进行单元测试的内容较少，所以对于一些工具类的单元测试通常和UI测试放在同一个模块中。(PS: 上述测试代码的写法和你选取的测试框架有关)</p>

<h3>功能测试</h3>

<p>功能测试主要把测试对象看作一个黑盒子，测试者并不关注具体的功能实现逻辑，只需要关注输入产生期望的输出即可。Android的功能测试和Web的功能测试类似。在真机或模拟器中运行App，模拟输入、点击等操作，识别界面上是否存在某些期望的文字或行为。</p>

<p>功能测试不需要关注细节，只需要关注功能，对登录Story的功能测试如下：</p>

<p>1.With valid username and password, user can successfully login and navigate to home screen</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>tap_when_element_exists "android.widget.EditText hint:'Username'"
</span><span class='line'>keyboard_enter_text 'gongmingqm10'
</span><span class='line'>tap_when_element_exists "android.widget.EditText hint:'Password'"
</span><span class='line'>keyboard_enter_text 'some_correct_password'
</span><span class='line'>@home_page.wait_for_page_to_load
</span><span class='line'>welcome_message = @home_page.get_welcome_message
</span><span class='line'>raise 'Navigate to home page failed' if welcome_message.empty?</span></code></pre></td></tr></table></div></figure>


<p>2.With wrong username and password, user will see an error text</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>tap_when_element_exists "android.widget.EditText hint:'Username'"
</span><span class='line'>keyboard_enter_text 'gongmingqm10'
</span><span class='line'>tap_when_element_exists "android.widget.EditText hint:'Password'"
</span><span class='line'>keyboard_enter_text 'wrong_password'
</span><span class='line'>query "android.widget.TextView id: 'error_box' text:'用户名或者密码错误'"</span></code></pre></td></tr></table></div></figure>


<h2>Android常用测试框架</h2>

<h3>针对UI测试</h3>

<p>一般项目上都会采用<a href="http://robolectric.org/">Robolectric</a>框架，Robolectric运行过程中不需要启动模拟器，因此执行过程很快。</p>

<p>除了Robolectric，Google官方推荐使用Espresso来做UI测试。Espresso既可以作UI测试，也可以做简单的功能测试。</p>

<h3>针对功能测试</h3>

<p>可以做功能测试的框架也很多，包括Robotium, uiautomator, Espresso, Appium 和 Calabash。对比其主要区别如下：</p>

<p>真实项目过程中功能测试框架使用较多的是Appium和Calabash。这两个框架的优点是能够同时支持Android和iOS，并且不需要注入到工程中(即只需要编译后生成的安装包)，配合响应的测试脚本即可完成测试。</p>

<h2>Android持续交付</h2>

<p>CD(Continuous Dilivery)强调能够随时给客户交付有价值的产品。在Web开发上，我们通常运用CI平台持续部署网站到各个环境中。从而实现整个产品的持续交付。在Android平台上也是类似，唯一不同点是Android每发布一个版本需要用户手动更新手机上的App。</p>

<p><strong>1. 集成你的测试框架</strong></p>

<p>假定我们已经选定其他的技术栈，这时只需要集成UI测试和功能测试即可。UI单元测试框架我们选择Robolectric，而功能测试框架选择Calabash。参考<a href="http://robolectric.org/">Robolectric</a>和<a href="https://github.com/calabash/calabash-android">Calabash for Android</a>官方文档，集成测试框架并编写第一个Dummy Test。</p>

<p><strong>2. 通过你的第一个Dummy Test</strong></p>

<p>CI(Continuous Integration)平台，选择Jenkins。因为Jenkins有各种丰富的插件支持。选择Jenkins平台之后，最后能够有一台带界面的Mac Mini(虽然Android可以配置无界面运行，但是配置相对麻烦并且运行太慢)。在Mac Mini上搭建CI环境，配置Android运行环境。此步的目的是你的Dummy Test能够在Jenkins上运行</p>

<p><strong>3. 自动上传你的应用</strong></p>

<p>我们希望每次Push之后生成的包能够被QA测试，Showcase时候能够被客户测试。所以我们需要持续的发布新生成的包。我接触到的通常有两种做法：</p>

<ul>
<li>使用Dropbox自动同步上传：这种方法是最省成本的。每次打包新版本的时候只需要给文件带上不同的版本号，方便辨识。包生成之后，只需要存放到本地的Dropbox共享文件夹中。Dropbox会为我们自动上传。手机端则可以直接访问Dropbox下载，安装。</li>
<li>使用<a href="http://hockeyapp.net/features/">HockeyApp</a>管理版本：HockeyApp需要收费，但是可以很方便的通过部署脚本自动上传新生成的包。手机端只需要安装HockeyApp客户端，即可选择更新。</li>
</ul>


<p>类似的工具还有很多，选择适合自己的才是最好的。</p>

<h2>结语</h2>

<p>移动端测试虽然发展时间不长，但是却不断在完善中。我们以前习惯用邮件或U盘发布新版供他人测试。我们以前习惯开发App时不写测试。那些时代应该过去了。运用Robolectric，我们可以很轻松的测试驱动开发Android App；运用Calabash或Appium，我们可以更好的控制App质量，保证App功能；运用Jenkins等CI平台，我们的App可以持续交付啦!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Material Design Your Android App]]></title>
    <link href="http://www.gongmingqm10.net/blog/2015/06/25/material-design-your-android-app/"/>
    <updated>2015-06-25T15:22:27+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2015/06/25/material-design-your-android-app</id>
    <content type="html"><![CDATA[<p>14年6月26日的Google I/O大会上，Google推出了一门全新的设计语言Material Design。Material Design在随后的一年里被逐渐应用到Android, Web等平台中。Material Design的推出意味着Google对移动端和网页端设计的整合。固然没有引起轩然大波，但是Material Design却让Android开发者看到了一点福音。</p>

<p>虽然Android系统广受诟病，越来越多的用户投奔苹果的iOS系统。然而这阻挡不了Android的不断改进。14年Google I/O, Google推出了Android的5.0版本，代号Lollipop。5.0版本在设计上采用全新的Material Design，虽然这次升级对ROM生产商来说是道“过不去的坎儿”，但是对开发者群体而言却是一次很不错的升级。因为开发者可以凭借有些的设计资源打造出更好看的App。</p>

<!-- more -->


<h2>关于Material Design</h2>

<blockquote><p>Material design is a comprehensive guide for visual, motion, and interaction design across platforms and devices.</p></blockquote>

<p>这是Google官方给的解释， Material Design 中文直译为 “物质的设计”。可以简单理解为画面中的所有元素都可以看作是真实的物质，物质存在于空间中，并且存在光、影、运动等特征。所以Material Design的众多原则都是基于Material这个概念而提出的。</p>

<h3>Material Design基本原则</h3>

<p>Material Design作为设计与交互的一部分，由设计师来阐述更为专业。以下只是抛砖引玉的介绍，也许身边的设计师朋友会更专业的见解。</p>

<h4>Material is the metaphor</h4>

<blockquote><p>A material metaphor is the unifying theory of a rationalized space and a system of motion</p></blockquote>

<p>举例来说，在Android Lollipop系统中，当用户点击操作时，界面会反馈出水纹般的涟漪向周边散去，作为对用户点击操作的直接反馈。Material的设计都是基于现实，并在现实世界的基础上予以创新的。创新之处表现在元素之间整理运动的和谐。即使是在现实世界进行创新，最重要的是要Material Design不会破坏物理世界的规则。</p>

<h4>Bold, graphic, intentional</h4>

<blockquote><p>The foundational elements of print-based design—typography, grids, space, scale, color, and use of imagery—guide visual treatments.</p></blockquote>

<p>设计中的基本元素网格，空间，比例，字体，颜色等的结合能够给用户带来更好的体验，从而产生更大的价值。Material Design给我们指定了一些常见的搭配组合，比如颜色的组合、App中不同部分字体大小，组件之间的边距等。</p>

<h4>Motion provides meaning</h4>

<blockquote><p>Motion respects and reinforces the user as the prime mover. Primary user actions are inflection points that initiate motion, transforming the whole design.</p></blockquote>

<p>动画通常是App中最常见的交互，在Material Design出来之前，大部分App是很少有动画的。因为动画从设计到最后被用户使用，需要动画的设计以及开发，有时还会受限于平台。Material Design在动画方面有所加强，官方推出了许多默认的动作，页面各个元素之间的相互运动等。期望通过元素的运动向用户传达更为核心的价值和功能。</p>

<h3>为什么我们需要Material Design</h3>

<p>设计主要是为了提升用户体验，辅助产品功能，起到锦上添花的效果。Google推出Material Design也许希望对所有的Google产品进行设计上的统一化。</p>

<p>从Android平台来看，以前的Google Apps很难说有什么风格，其他厂商开发的App也是风格各异。Google希望通过Lollipop对App统一风格，所以在5.0＋平台上的Gmail, Youtube, Calender等都进行了风格的统一化，借此引导更多的设计师和开发者开发出更“接地气”的App。</p>

<p>Material Design强调跨平台设计，如果你遵从Material Design，你会发现将无论是宽屏平板设备、还是手机，你会发现你的应用可以很智能的进行展示。这将极大减轻适配平板带来的工作量。是不是有点类似于Web上的响应式设计呢？</p>

<p>当然选择是自由的，如果你觉得你的App不需要Material Design，那么TA真的不需要。</p>

<h2>如何Material Design App</h2>

<p>据个人观察，目前国内市场上大部分的App没有Material Design的概念。原因不得而知。但是遵循Material Design的应用在国外却比较常见。比如我个人常用的雅虎天气。</p>

<p>那么如何空手开发Material Design 应用呢？假定读到这里的你是个开发人员：</p>

<h3>1.合适的SDK版本和相关兼容包</h3>

<p>build.gradle</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>apply plugin: 'com.android.application'
</span><span class='line'>
</span><span class='line'>android {
</span><span class='line'>    compileSdkVersion 22
</span><span class='line'>    buildToolsVersion "22.0.1"
</span><span class='line'>
</span><span class='line'>    defaultConfig {
</span><span class='line'>        applicationId "net.gongmingqm10.training"
</span><span class='line'>        minSdkVersion 16
</span><span class='line'>        targetSdkVersion 22
</span><span class='line'>        versionCode 1
</span><span class='line'>        versionName "1.0"
</span><span class='line'>    }
</span><span class='line'>      ...
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>dependencies {
</span><span class='line'>    compile fileTree(dir: 'libs', include: ['*.jar'])
</span><span class='line'>  //required
</span><span class='line'>    compile 'com.android.support:appcompat-v7:22.2.0'
</span><span class='line'>    //optional for RecyclerView
</span><span class='line'>    compile 'com.android.support:recyclerview-v7:22.2.0'
</span><span class='line'>    //optional for GridLayout
</span><span class='line'>    compile 'com.android.support:gridlayout-v7:22.2.0'
</span><span class='line'>    //optional for CardView
</span><span class='line'>    compile 'com.android.support:cardview-v7:22.2.0'
</span><span class='line'>    //optional for some useful libraries
</span><span class='line'>    compile 'com.android.support:design:22.2.0'
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<h3>2.使用 Material theme</h3>

<p>values-v21/styles.xml</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;?xml version="1.0" encoding="utf-8"?&gt;
</span><span class='line'>&lt;resources&gt;
</span><span class='line'>    &lt;style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar"&gt;
</span><span class='line'>        &lt;!-- Main theme colors --&gt;
</span><span class='line'>        &lt;!--   your app branding color for the app bar --&gt;
</span><span class='line'>        &lt;item name="colorPrimary"&gt;@color/color_primary&lt;/item&gt;
</span><span class='line'>        &lt;!--   darker variant for the status bar and contextual app bars --&gt;
</span><span class='line'>        &lt;item name="colorPrimaryDark"&gt;@color/color_primary_dark&lt;/item&gt;
</span><span class='line'>        &lt;!--   theme UI controls like checkboxes and text fields --&gt;
</span><span class='line'>        &lt;item name="colorAccent"&gt;@color/color_accent&lt;/item&gt;
</span><span class='line'>
</span><span class='line'>    &lt;/style&gt;
</span><span class='line'>&lt;/resources&gt;
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>values/styles.xml</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;resources&gt;
</span><span class='line'>
</span><span class='line'>    &lt;!-- Base application theme. --&gt;
</span><span class='line'>    &lt;style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar"&gt;
</span><span class='line'>        &lt;!-- Customize your theme here. --&gt;
</span><span class='line'>        &lt;item name="android:actionBarStyle"&gt;@style/MyActionBar&lt;/item&gt;
</span><span class='line'>        &lt;!-- Support library compatibility --&gt;
</span><span class='line'>
</span><span class='line'>        &lt;item name="actionBarStyle"&gt;@style/MyActionBar&lt;/item&gt;
</span><span class='line'>    &lt;/style&gt;
</span><span class='line'>
</span><span class='line'>    &lt;style name="AppTheme.NoActionBar"&gt;
</span><span class='line'>        &lt;item name="windowActionBar"&gt;false&lt;/item&gt;
</span><span class='line'>        &lt;item name="windowNoTitle"&gt;true&lt;/item&gt;
</span><span class='line'>    &lt;/style&gt;
</span><span class='line'>
</span><span class='line'>    &lt;!-- ActionBar styles --&gt;
</span><span class='line'>    &lt;style name="MyActionBar"
</span><span class='line'>        parent="@style/Widget.AppCompat.Light.ActionBar.Solid.Inverse"&gt;
</span><span class='line'>        &lt;item name="android:background"&gt;@color/color_primary&lt;/item&gt;
</span><span class='line'>        &lt;item name="android:titleTextStyle"&gt;@style/MyActionBarTitleText&lt;/item&gt;
</span><span class='line'>
</span><span class='line'>        &lt;!-- Support library compatibility --&gt;
</span><span class='line'>        &lt;item name="background"&gt;@color/color_primary&lt;/item&gt;
</span><span class='line'>        &lt;item name="titleTextStyle"&gt;@style/MyActionBarTitleText&lt;/item&gt;
</span><span class='line'>    &lt;/style&gt;
</span><span class='line'>
</span><span class='line'>    &lt;style name="MyActionBarTitleText" parent="TextAppearance.AppCompat.Widget.ActionBar.Title"&gt;
</span><span class='line'>        &lt;item name="android:textColor"&gt;@color/white&lt;/item&gt;
</span><span class='line'>    &lt;/style&gt;
</span><span class='line'>
</span><span class='line'>&lt;/resources&gt;
</span></code></pre></td></tr></table></div></figure>


<p>使用你定义的AppTheme</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;application
</span><span class='line'>    android:name=".TrainingApp"
</span><span class='line'>    android:allowBackup="true"
</span><span class='line'>    android:icon="@mipmap/ic_launcher"
</span><span class='line'>    android:label="@string/app_name"
</span><span class='line'>    android:theme="@style/AppTheme" &gt;
</span><span class='line'>  ...
</span><span class='line'>&lt;/application&gt;</span></code></pre></td></tr></table></div></figure>


<h3>3.使用专为Material Design打造的Android控件</h3>

<p>你可以参考<a href="http://developer.android.com/training/material/index.html">Google Training Material Design</a>获取更多的Material Design组件的使用方法。</p>

<h4>Lists and Cards</h4>

<h5>RecyclerView</h5>

<p>引入RecyclerView到工程中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>compile 'com.android.support:recyclerview-v7:22.2.0'</span></code></pre></td></tr></table></div></figure>


<p>RecyclerView控件是ListView的更高效更灵活的版本。可以看作是对ListView更好的封装：</p>

<ul>
<li>解决ListView多列显示的难题；</li>
<li>不用担心开发人员没有复用View，因为它会强迫你这样做；</li>
<li>更方便的动画支持，移除中间某一项时，可以设置后面几项动画移动;</li>
</ul>


<h5>CardView</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>compile 'com.android.support:cardview-v7:22.2.0'</span></code></pre></td></tr></table></div></figure>


<p>卡片式布局，你的界面就是有导航和卡片组成的。卡片能够设置圆角和阴影。</p>

<h4>Design support library</h4>

<p>使用Design support包含的空间，需要引入Design support库：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>compile 'com.android.support:design:22.2.0'</span></code></pre></td></tr></table></div></figure>


<p>Design support提供了一些很常见很实用的控件。</p>

<h5>Navigation View</h5>

<p>Material Design推荐使用DrawerLayout抽屉式布局显示导航，所以Android一直没有为底部导航推出相应的控件。按照Google最新的设计，所有的导航都会被设置为抽屉显示，点击左上角菜单可以抽屉式弹出菜单项。</p>

<p>NavigationView就是和DrawerLayout搭配使用的神器。使用NavigationView只需要提供icon和title就可以生成专业的侧边导航。</p>

<h5>Floating Action Button</h5>

<p>Material Design引入了z轴，这个控件可以轻松制作出有阴影的悬浮圆形按钮。</p>

<h5>Snackbar</h5>

<p>底部栏消息提示控件，显示显示不再只有Toast和AlertDialog，还有Snackbar。</p>

<h5>Tabs</h5>

<p>在TabLayout出来之前，开发者通常手写Tab控件，并且需要手动控制UI。并且设计出来的Tab效果很一般。Google在2014年的iosched工程中推出了<a href="https://github.com/google/iosched/blob/master/android/src/main/java/com/google/samples/apps/iosched/ui/widget/SlidingTabLayout.java">SlidingTabLayout</a>，这个组件后来也在众多项目中被开发者用到。但是开发者还是得添加额外的代码来控制UI。</p>

<p>TabLayout帮助开发者创建符合界面风格的Tab，并且简单易用。</p>

<h5>CoordinatorLayout &amp; Collapse Toolbar</h5>

<p>更加优美的导航，导航可以相应页面滚动，也产生相应的滚动效果。可以参考Android 5.0版本默认的联系人应用。</p>

<h2>结语</h2>

<p>目前 Material Design 在国内潜伏了一年，也没引起太大的市场反馈。互联网泡沫下，决策者的心思都花在了如何推广如何吸引第一批用户上了，难以负担App重新设计带来的时间成本，更不行因为重设计造成现有用户的流失。</p>

<p>当然，如果某一天所有的国内手机都可以升级为5.0系统，是不是会有许多软件开发者考虑对App做Material Design呢？Android系统深度定制化依然成为5.0难以在国产手机中推广的重要阻碍。</p>

<p>Material Design作为Android App设计风格的趋势，尝试在你的App中使用新的风格，也许可以给你的产品带来不一样的体验。</p>

<p><strong>参考</strong></p>

<p><a href="https://www.google.com/design/spec/material-design/introduction.html">Google Materil Design</a></p>

<p><a href="http://developer.android.com/training/material/index.html">Material Design for Developers</a></p>

<p><a href="http://android-developers.blogspot.sg/2015/05/android-design-support-library.html">Android Design Support Library</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Design - Difference Between Px Sp and Dp]]></title>
    <link href="http://www.gongmingqm10.net/blog/2015/05/09/android-design-difference-between-px/"/>
    <updated>2015-05-09T11:32:59+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2015/05/09/android-design-difference-between-px</id>
    <content type="html"><![CDATA[<p>Android自兴起以来，开发者不断增加，与此同时市场上参差不齐的设备也不断增加，随之而来的则是开发者需要适配众多机型而带来的困扰与抱怨。并且随着不同厂家定制化不同的ROM，Android设备的碎片化现象日益严重。这篇文章主要讲述如何设计中严格遵从设计图标准的Android页面。</p>

<h2>1. px, dp, sp区别</h2>

<h3>什么是px</h3>

<p>px就是我们通常所说的像素的单位，在css里面，我们用px比较多。px主要指用户在屏幕上看到的事物的实际大小单位。</p>

<h3>什么是dp</h3>

<p>在看手机或者电脑参数时，我们经常说到一个关键词，屏幕分辨率(resolution)，分辨率被表示成每一个方向上的像素数量，比如800x480分辨率</p>

<!-- more -->


<p><img src="http://www.gongmingqm10.net/images/retina_one_screen.jpg" title="Mac retina resolution" ></p>

<p>上图中，我们可以看到15寸的retina pro分辨率是2880x1800，而60寸的HDTV分辨率却只有1920x1080。可见如果60寸的HDTV也要达到Retina的显示效果，其分辨率大概至少为11520x7200。</p>

<p>既然已经有了分辨率的概念，那么我们就可以了解 dpi(dot per inch)的概念了。dpi本意是每英寸点的数量，但是也经常和ppi(pixel per inch)混用。指每英寸的像素数量，也被我们称为屏幕密度，dpi越大，图像从视觉上看起来越清晰。</p>

<p>Google官方对dp的解释如下：</p>

<blockquote><p>A virtual pixel unit that you should use when defining UI layout, to express layout dimensions or position in a density-independent way.
The density-independent pixel is equivalent to one physical pixel on a 160 dpi screen, which is the baseline density assumed by the system for a &ldquo;medium&rdquo; density screen. At runtime, the system transparently handles any scaling of the dp units, as necessary, based on the actual density of the screen in use. The conversion of dp units to screen pixels is simple: px = dp * (dpi / 160). For example, on a 240 dpi screen, 1 dp equals 1.5 physical pixels. You should always use dp units when defining your application&rsquo;s UI, to ensure proper display of your UI on screens with different densities.</p></blockquote>

<p>有了密度的概念，我们可以更好的理解dp(density independent pixel)了。dp是Android中用来定义UI布局中表达元素尺寸或位置的一个虚拟的像素单位，dp的存在是为了页面元素位置不受屏幕密度所影响。以设计师设计一个APP页面为例，设计师希望用户视觉上看起来如此，也就是设计师设计时通常以px作为基础单位。而在其他不同屏幕密度的设备中，也希望能够进行一定的伸缩，类似于维持一个相对一致的百分比。所以开发者通常需要以dp为单位，以适应不同密度的屏幕。</p>

<p>所以dp和px之间有一套换算标准：<code>px = dp * (dpi / 160)</code>。假设在dpi为320的屏幕上，1dp = 2px。</p>

<h3>什么是sp</h3>

<p>sp是Android中专业为字体而设置的单位。使用sp作为字体单位不仅能够使字体大小受屏幕密度影响，并且能够使字体受用户系统设置的影响。Android提供字体大小的设置选项。一旦使用sp作为字体，根据用户设置字体的不同，App中的字体大小也会显示不同。但是在正常字体设置下，1dp ＝ 1sp。</p>

<h2>2. 设计师视角</h2>

<p>Android的多屏适配存在这么多的尺寸，自然需要设计师和工程师之间找到沟通的桥梁，设计师如何规范设计才能够更加符合Android的设计标准呢。设计师与工程师对于页面的尺寸需要有一个共识性的标准，测试人员才可能进行更有效的测试，才不致于因为不同机型显示不同效果而引起不必要的工作量。</p>

<p>首先我们需要选择一个相对通用的屏幕尺寸，可以参考现有的一些主流机型的尺寸。为了便于计算，我们选择Nexus 4作为设计图的原版标准。那么所有的页面都是基于Nexus4而产生的。Nexus4尺寸如下:</p>

<p><code>主屏尺寸4.7，主屏分辨率：1280x768像素，屏幕像素密度320ppi。</code></p>

<p>一般来说，我们选择市场上最常见的机型来设计，这里我们为了计算方便，选择320ppi的机型，设计图中尺寸将是标准图中的2倍。假设在设计图中，页面内边距为32px, 按钮的高度为96px, icon大小为48x48。</p>

<p>通过<code>px＝dp*(dpi/160)</code>的标准，设计师给开发者标注图时可标注页边距为16dp，按钮高度为48dp，icon则分别出四套mdpi, hdpi, xhdpi, xxhdpi标准。</p>

<h2>3. 开发者视角</h2>

<h3>margin, padding, height, width</h3>

<p>从开发者角度来看，对于控件的尺寸，高度等，只需要按照转化后的dp设置即可。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>android:layout_padding="16dp"
</span><span class='line'>
</span><span class='line'>android:layout_height="48dp"
</span></code></pre></td></tr></table></div></figure>


<p>以dp为单位能够保证不同分辨率屏幕上显示不同大小的字体。并且能够保持相对大小，这样也更符合设计的初衷。</p>

<h3>图片资源</h3>

<p>对于png制作出来的图片，一般大小固定，没办法像尺寸一样自动的伸缩。所以Android会存在至少4个资源文件夹。当App运行过程中，系统能够根据当前设备的屏幕密度，自动选择使用哪种尺寸的图片资源。</p>

<table>
<thead>
<tr>
<th>ldpi </th>
<th> mdpi </th>
<th> hdpi </th>
<th> xhdpi </th>
<th> xxhdpi </th>
<th> xxxhdpi</th>
</tr>
</thead>
<tbody>
<tr>
<td>0.75 </td>
<td> 1  </td>
<td> 1.5 </td>
<td> 2 </td>
<td> 3 </td>
<td> 4</td>
</tr>
<tr>
<td>120 </td>
<td> 160 </td>
<td> 240 </td>
<td> 320 </td>
<td> 480 </td>
<td> 640</td>
</tr>
<tr>
<td>18x18 </td>
<td> 24x24 </td>
<td> 36x36 </td>
<td> 48x48 </td>
<td> 72x72 </td>
<td> 96x96</td>
</tr>
</tbody>
</table>


<h2>4. 更多</h2>

<p>附上Android主流机型：</p>

<p>Android：主流机型主要为 480x800, 480x854, 540x960, 720x1280, 800x1280 这五种。
（非主流机型还包括：240x320, 320x480, 640x960 这三种，其中两种都与 iPhone 一致。）
iOS: 主流机型主要为 320x480, 640x960, 640x1136, 1024x768, 2048x1536, 这五种。
WP：主流机型主要为 480x800，720x1280, 768x1280 这三种</p>

<p>Photoshop制图时，字体大小通常是pt这个单位。pt是长度单位， 1pt = 1/72英寸， px = pt * dpi/72。</p>

<p>另附上豆瓣关于这些单位更<a href="http://www.douban.com/note/155032221/">具体的阐释</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setup Jenkins for Android Integration Using Docker]]></title>
    <link href="http://www.gongmingqm10.net/blog/2015/03/12/setup-jenkins-for-android-integration-using-docker/"/>
    <updated>2015-03-12T10:46:59+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2015/03/12/setup-jenkins-for-android-integration-using-docker</id>
    <content type="html"><![CDATA[<h2>About Docker</h2>

<p>什么Docker，为什么我们要折腾Docker，而不是直接在服务器上安装运行appilication所需的各种环境呢？</p>

<p>这个问题的产生和为什么需要虚拟机的理由差不多，我需要让我的代码运行在一个干净的无干扰的机器上，这样能够保证代码测试运行环境的一致性，降低其他不可知因素对代码的影响。而Docker和VM虚拟机相比又有其特点，比如启动速度快，可以单独将Docker保存为镜像，上传后能够让别人使用。甚至可以直接将自己的code放在Docker中，直接将环境和代码一起交付给客户。客户只需要安装这个Docker，运行后就可以直接使用这个application了。</p>

<blockquote><p>Develop, Ship and Run Any Application, Anywhere</p></blockquote>

<!-- more -->


<p>Docker is a platform for developers and sysadmins to develop, ship, and run applications. Docker lets you quickly assemble applications from components and eliminates the friction that can come when shipping code. Docker lets you get your code tested and deployed into production as fast as possible.</p>

<h3>Provision</h3>

<p>我的目标在于构建一个可以运行Android的CI服务器。出于省钱的目的，我使用本地的Vagrant启动Ubuntu虚拟机来代替真正的服务器。大致思路是：</p>

<ol>
<li>启动Ubuntu虚拟机，在Ubuntu上安装Docker；</li>
<li>通过Docker安装Jenkins Docker官方镜像；</li>
<li>在这个实例Docker中配置Jenkins并安装Android运行环境；</li>
<li>在Jenkins上搭建Android CI，使得Android单元测试和集成测试能够顺利通过；</li>
<li>上传这个具有Android CI功能的Jenkins镜像；</li>
<li>本地启动B虚拟机，下载镜像，访问B虚拟机的地址，查看Android Jenkins；</li>
</ol>


<h3>1. 启动Ubuntu虚拟机并安装Docker Jenkins</h3>

<p>在安装Docker之前，首先得有一个Linux的机器能够进入，如果你已经有一台干净的Linux服务器，直接进入安装Docker步骤。</p>

<p>Vagrant安装之前，你应该在电脑上安装VirtualBox虚拟机。VirtualBox安装完成之后请参考 <a href="http://docs.vagrantup.com/v2/installation/index.html">Vagrant Installation Guide</a>。</p>

<p>Vagrant成功安装后，<code>vagrant init ubuntu/trusty64</code> 能够帮你快速安装一台Ubuntu14.04的虚拟机，第一次安装的时候会稍微慢点，因为Vagrant会帮你生成Vagrantfile文件，并下载镜像。</p>

<p>Vagrantfile生成之后不要立即启动，因为我们想通过localhost访问Vagrant，然后通过Vagrant访问其中的Docker。由于Jenkins默认会使用8080端口，所以如果Vagrant的8080端口可以转发到Docker Container中的Jenkins。localhost:8080能够转发到Vagrant Ubuntu的8080端口，然后Vagrant的8080端口继续转发到Docker的8080端口，于是可以通过<code>localhost:8080</code>访问Jenkins了。所以Vagrantfile部分配置如下，添加端口转发。因为我本机的8080端口被其他程序占用，所以我将本地的8088端口转发到虚拟机的8080端口：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  # Create a forwarded port mapping which allows access to a specific port
</span><span class='line'>  # within the machine from a port on the host machine. In the example below,
</span><span class='line'>  # accessing "localhost:8080" will access port 80 on the guest machine.
</span><span class='line'>  #config.vm.network :forwarded_port, guest: 80, host: 8080
</span><span class='line'>  config.vm.network :forwarded_port, guest: 8080, host: 8088</span></code></pre></td></tr></table></div></figure>


<p>如果你之前已经启动了vagrant up, 然后更改了Vagrantfile想让forward_port生效，需要先<code>vagrant suspend</code>暂停vagrant，然后使用<code>vagrant reload</code>重新加载Vagrantfile使配置生效。</p>

<p>Vagrant Ubuntu 初始化完成之后，还是在这个有Vagrantfile的文件夹下，<code>vagrant up</code>能够直接启动这台Ubuntu服务器。</p>

<p>顺利的话我们可以进入通过<code>vagrant ssh</code>进入Ubuntu，随后需要在这台干净的Ubuntu机器上<a href="http://docs.docker.com/installation/ubuntulinux/">安装Docker</a>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo apt-get update
</span><span class='line'>$ sudo apt-get install docker.io
</span><span class='line'>$ source /etc/bash_completion.d/docker.io
</span><span class='line'>
</span><span class='line'>// 上述方法安装的Docker版本为1.0.1，如果你想使用较高版本Docker1.3.3
</span><span class='line'>
</span><span class='line'>$ echo deb http://get.docker.com/ubuntu docker main &gt; /etc/apt/sources.list.d/docker.list
</span><span class='line'>$ apt-key adv --keyserver pgp.mit.edu --recv-keys 36A1D7869245C8950F966E92D8576A8BA88D21E9
</span><span class='line'>$ apt-get update
</span><span class='line'>$ apt-get install -y lxc-docker-1.3.3
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>Note: <code>vagrant destroy</code>会关闭并重新格式化ubuntu机器，如果你只是想简单的停止机器，请使用<code>vagrant suspend</code></p>

<p>Docker成功安装后，直接启动Jenkins官方镜像：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker run --name androidJenkins -p 8080:8080 -v /var/jenkins_home jenkins</span></code></pre></td></tr></table></div></figure>


<p>安装完成后，访问 <code>http://localhost:8088/</code>，如果可以看到Jenkins界面，说明Jenkins已经安装成功。</p>

<p>进入后发现没有登录或者注册入口，然后就看到了stackoverflow上的<a href="http://stackoverflow.com/questions/10825614/how-can-i-add-a-username-and-password-to-jenkins">解决方案</a>: 系统管理 &ndash; Configure Global Security &ndash; 启用安全 — Jenkins专有用户数据库，允许用户注册 &ndash; 任何用户可以做任何事情。注册常用用户名和邮箱，然后就可以直接登录Jenkins。</p>

<h3>2. Jenkins Docker中安装Android 运行环境</h3>

<p>既然我们的Jenkins已经搭建完成，这一步我们则需要基于Jenkins安装Android的运行环境，如何在Ubuntu系统中通过命令行安装Android运行环境呢，主要参考<a href="https://www.digitalocean.com/community/tutorials/how-to-build-android-apps-with-jenkins">这篇文章</a>。</p>

<p>安装Android运行环境主要的流程为：</p>

<ol>
<li>下载Android SDK安装包 并设置环境变量.</li>
<li>下载platform-tools, Android SDK API, Android Build Tools.</li>
</ol>


<p>我这里安装Android SDK API版本为21，Build Tools版本号为21.1.2。</p>

<p>为了使Jenkins Android 环境能够在下次使用，我们通过新建 Dockerfile 的方式基于Jenkins来创建一个新的镜像，具体步骤如下：</p>

<ol>
<li><a href="https://registry.hub.docker.com/">Docker Hub</a>注册账号，用于存放自己的Repository。</li>
<li>新建Dockerfile文件，并添加配置信息。</li>
<li>运行Dockerfile，此时会执行Dockerfile中所配置的一系列命令。</li>
<li>提交Dockerfile生成的jenkins-android镜像。</li>
</ol>


<h4>配置Dockerfile</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>FROM jenkins
</span><span class='line'>MAINTAINER Ming Gong, gongmingqm10@gmail.com
</span><span class='line'>USER root
</span><span class='line'>RUN apt-get update && apt-get -y install libstdc++6 lib32z1 lib32stdc++6 expect
</span><span class='line'>
</span><span class='line'>RUN wget --progress=dot:giga http://dl.google.com/android/android-sdk_r24.1.2-linux.tgz
</span><span class='line'>RUN mv android-sdk_r24.1.2-linux.tgz /opt/
</span><span class='line'>RUN cd /opt && tar xzvf ./android-sdk_r24.1.2-linux.tgz
</span><span class='line'>ENV ANDROID_HOME /opt/android-sdk-linux/
</span><span class='line'>ENV PATH $ANDROID_HOME/tools:$ANDROID_HOME/platform-tools:$PATH
</span><span class='line'>RUN echo $PATH
</span><span class='line'>RUN echo "y" | android update sdk -u --filter platform-tools,android-21
</span><span class='line'>RUN echo "y" | android update sdk -u --all --filter 5
</span><span class='line'>RUN chmod -R 755 $ANDROID_HOME
</span><span class='line'>
</span><span class='line'>RUN apt-get install -y git-core
</span><span class='line'>RUN android update sdk --no-ui
</span></code></pre></td></tr></table></div></figure>


<p>其中 <code>android update sdk -u --all --filter 5</code> 主要用来更新build-tools。在有android环境的机器上运行&#8217;android list sdk &mdash;all&#8217;可以查看所有的SDK信息，找到最新版本的build-tools，然后通过提供的最新版本号即可。</p>

<p>Dockerfile配置成功后，我们首先在Vagrant虚拟机里面，<code>mkdir /var/jenkins_home</code>，并给予所有权限 <code>chmod 777 /var/jenkins_home</code>。/var/jenkins_home 能够映射到Docker中的jenkins_home目录，方便我们直接备份jenkins数据。</p>

<h4>Build Dockerfile</h4>

<p>准备工作完成之后，build Dockerfile，首先切换到Dockerfile所在的当前目录下，</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>vagrant@ubuntu-14: sudo docker build -t gongmingqm10/jenkins-android:latest .
</span><span class='line'>
</span><span class='line'>...
</span><span class='line'>
</span><span class='line'>Successfully built 184c7dad595a
</span></code></pre></td></tr></table></div></figure>


<h4>Push Image</h4>

<p>最后输出的信息就是我们通过Dockerfile生成的新的镜像ID。构建完成之后我们需要commit并push这个镜像到docker hub的repository上。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>vagrant@ubuntu-14:~/test$ sudo docker images
</span><span class='line'>REPOSITORY                     TAG                   IMAGE ID            CREATED             VIRTUAL SIZE
</span><span class='line'>gongmingqm10/jenkins-android       latest                184c7dad595a        11 minutes ago      188.3 MB
</span></code></pre></td></tr></table></div></figure>


<p>通过 docker images能够看到最新的镜像已经生成，这一步我们需要首先启动这个镜像，然后得到container ID，然后再PUSH 这个container。</p>

<p>首先启动镜像：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>vagrant@ubuntu-14:~/test$ sudo docker run -t -i -d gongmingqm10/jenkins-android:latest
</span><span class='line'>...
</span><span class='line'>
</span><span class='line'>vagrant@ubuntu-14:~/test$ sudo docker ps
</span><span class='line'>CONTAINER ID        IMAGE                              COMMAND                CREATED             STATUS              PORTS                               NAMES
</span><span class='line'>43fcce2388fc        gongmingqm10/jenkins-adnroid:latest    /bin/bash              17 seconds ago      Up 16 seconds                                           determined_lumiere
</span><span class='line'>vagrant@ubuntu-14:~/test$ sudo docker commit -m "Add Android Config" -a "Ming Gong" 43fcce2388fc gongmingqm10/jenkins-android:latest
</span><span class='line'>75f1b93aedc4b57426b75c96ce69170016b3c0b0b6283cda5562f8464bbfd2f4
</span><span class='line'>vagrant@ubuntu-14:~/test$ sudo docker push gongmingqm10/jenkins-android
</span></code></pre></td></tr></table></div></figure>


<p>首次push，可能会提示你输入自己的Docker Hub的用户名和密码。</p>

<h4>运行 jenkins-android</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo docker run --name jenkinsAndroid -p 8080:8080 -v /var/jenkins_home:/var/jenkins_home gongmingqm10/jenkins-android
</span></code></pre></td></tr></table></div></figure>


<p>我们使用jenkinsAndroid作为container的名字，注意这个名字也不能与已用的container 名字重复。运行一次之后，如果被自己停了，发现没有启动的话，可以使用 <code>sudo docker ps -a</code> 查看所有的container，然后找到 jenkinsAndroid这个名字的container对应的ID。启动之：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo docker start f6b88bdad68f
</span></code></pre></td></tr></table></div></figure>


<h4>访问 Jenkins</h4>

<p>在第一部分，我们直接使用Jenkins官方的Repository启动了Jenkins进行访问，经过这部分我们自己构建Dockerfile，添加了一些Android的运行环境，目的是给Android Test提供必要的运行环境。访问 <code>localhost:8088</code>可以访问这个具有Android环境的Jenkins。注册用户并登录，这一部分就完成了。</p>

<h3>4. Jenkins中配置Android Build</h3>

<p>通过访问<code>localhost:8088</code>，我们可以进入Jenkins控制台。为了使得Jenkins可以运行Android的单元测试和功能测试，主要安装如下插件：</p>

<p><code>git plugin</code>： 从 git repo 中 clone 代码</p>

<p><code>android emulator plugin</code>：Android运行功能测试时，能够帮助我们生成或者启动Android虚拟机</p>

<p><code>build monitor view</code>：全屏显示当前Build情况，适合投影到大屏幕上，方便所有人实时了解build情况</p>

<p>构建Functional test过程中，我希望通过android emulator pligin直接启动在container中已经新建的AVD。运行过程中却始终出错:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ /opt/android-sdk-linux/tools/emulator -no-boot-anim -ports 9731,9732 -avd Nexus_5_API_21 -no-snapshot-load -no-snapshot-save -no-window
</span><span class='line'>emulator: ERROR: Could not load OpenGLES emulation library: libX11.so.6: cannot open shared object file: No such file or directory
</span><span class='line'>emulator: WARNING: Could not initialize OpenglES emulation, using software renderer.
</span><span class='line'>emulator: warning: opening audio output failed
</span><span class='line'>
</span><span class='line'>$ /opt/android-sdk-linux/platform-tools/adb connect localhost:9732
</span><span class='line'>connected to localhost:9732
</span><span class='line'>[android] Waiting for emulator to finish booting...
</span><span class='line'>$ /opt/android-sdk-linux/platform-tools/adb -s localhost:9732 shell getprop init.svc.bootanim
</span><span class='line'>error: device offline
</span><span class='line'>$ /opt/android-sdk-linux/platform-tools/adb connect localhost:9732
</span><span class='line'>$ /opt/android-sdk-linux/platform-tools/adb -s localhost:9732 shell getprop init.svc.bootanim
</span><span class='line'>error: device offline
</span><span class='line'>$ /opt/android-sdk-linux/platform-tools/adb connect localhost:9732
</span><span class='line'>$ /opt/android-sdk-linux/platform-tools/adb -s localhost:9732 shell getprop init.svc.bootanim
</span><span class='line'>error: device offline
</span><span class='line'>$ /opt/android-sdk-linux/platform-tools/adb disconnect localhost:9732
</span><span class='line'>$ /opt/android-sdk-linux/platform-tools/adb connect localhost:9732
</span><span class='line'>$ /opt/android-sdk-linux/platform-tools/adb -s localhost:9732 shell getprop init.svc.bootanim
</span><span class='line'>error: device offline
</span><span class='line'>$ /opt/android-sdk-linux/platform-tools/adb connect localhost:9732
</span><span class='line'>$ /opt/android-sdk-linux/platform-tools/adb -s localhost:9732 shell getprop init.svc.bootanim
</span><span class='line'>error: device offline
</span><span class='line'>$ /opt/android-sdk-linux/platform-tools/adb connect localhost:9732
</span><span class='line'>$ /opt/android-sdk-linux/platform-tools/adb -s localhost:9732 shell getprop init.svc.bootanim
</span><span class='line'>error: device offline
</span><span class='line'>$ /opt/android-sdk-linux/platform-tools/adb disconnect localhost:9732
</span><span class='line'>$ /opt/android-sdk-linux/platform-tools/adb connect localhost:9732
</span><span class='line'>[android] Emulator was shut down before it finished booting
</span><span class='line'>$ /opt/android-sdk-linux/platform-tools/adb disconnect localhost:9732
</span><span class='line'>[android] Stopping Android emulator
</span><span class='line'>$ /opt/android-sdk-linux/platform-tools/adb kill-server
</span><span class='line'>Finished: NOT_BUILT
</span></code></pre></td></tr></table></div></figure>


<p>网上查了一下，主要是64位机器下运行32位emulator导致的一些问题。如果可以在一台都图形界面的机器上手动启动虚拟机，运行functional test的时候就应该不存在这个问题。此处先略过这个问题，后面会有专门的文章来研究这个问题。</p>

<p>在Jenkins中，建立的Build主要为 Android Unit Test &ndash; Android Functional Test &ndash; Android Deploy Hocky App.</p>

<p>通过Android的单元测试和功能测试基本可以保证App的功能处于正常状态；而Deploy到Hockey App则是为了持续集成的需要，我们要确保我们的App能够被实时生成，这样我们的产品就可以随时被测试并展示给客户，或者直接发布Hockey App 上某一个稳定的版本。</p>

<p>要想Jenkins能够直接将应用上传到HockeyApp上，我们只需要在Jenkins中安装<code>Hockey App Plugin</code>，然后通过注册Hockey App提供相应的API Token并进行简单配置，即可以直接通过Jenkins来上传发布我们的App。</p>

<h3>5. Android Flavor</h3>

<p>Android Flavor是为了Android在构建时使用不同的资源，类似于Ruby运行时可以设置不同的环境。</p>

<p>在app/build.gradle做如下配置：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>android {
</span><span class='line'>
</span><span class='line'>  defaultConfig{...}
</span><span class='line'>
</span><span class='line'>    productFlavors {
</span><span class='line'>        dev {
</span><span class='line'>            applicationId "com.tarcle.moment.dev"
</span><span class='line'>        }
</span><span class='line'>        qa {
</span><span class='line'>            applicationId "com.tarcle.moment.qa"
</span><span class='line'>        }
</span><span class='line'>        production {
</span><span class='line'>            applicationId "com.tarcle.moment"
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    signingConfigs {
</span><span class='line'>      release {...}
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    buildTypes {
</span><span class='line'>      release {...}
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    packageOptions {...}
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>通过上面的配置，我们给APP添加了三种环境变量，于是可以直接在app目录下面新建<code>dev, qa, production</code>等文件夹。通过IDE中选择不同的Build variables，便可以在当前工程中使用什么环境的配置。</p>

<p>通过<code>./gradlew clean build 任务</code>， 能够在 <code>app/build/outputs/apk</code>等目录下生成不同环境下的Debug和Release包。而这里面的Release包则可以用来Jenkins中上传到Hockey App中。</p>

<p>配置Jenkins Build和Hockey App可能用到如下插件。对于不同的Flavor，我们可以在Deploy HockeyApp 的配置中添加Build Parameters，构建时我们可以自己选择不同类型的包。从而发布不同环境下的版本。</p>

<p><code>Copy Artifact Plugin</code> 从其他的Build中直接拷贝已经生成的APK文件包。</p>

<p><code>Android Lint Plugin</code> 构建后发布Lint Report。</p>

<h3>Other</h3>

<p>关于如何直接在虚拟机中，不使用Docker构建Android Build, 将会在另一篇博文中阐述。</p>

<p>如下是我们可能用到的关于Docker 和 Android的常用命令：</p>

<p><code>android list avd</code> 查看所有当前设备。</p>

<p><code>android create avd -f -a -s 1080x1920 -n Nexus_5_API_21 -t android-21</code> 创建API-21名为Nexus_5_API_21的emulator。</p>

<p><code>emulator -avd Nexus_5_API_21</code> 运行已创建的名为 Nexus_5_API_21的emulator，注意运行时命令行会一直处于阻塞中，所以可以在末尾加上 <code>&amp;</code> 让其进入后台运行。</p>

<p><code>adb devices</code> List of devices attached。</p>

<p><code>sudo docker exec -i -t a45953b9f2fe bash</code> 进入运行中的container的控制台</p>

<p><code>echo 'y' | apt-get install libgl1-mesa-dev</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Continuous Integration]]></title>
    <link href="http://www.gongmingqm10.net/blog/2015/03/09/android-continuous-integration/"/>
    <updated>2015-03-09T12:39:35+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2015/03/09/android-continuous-integration</id>
    <content type="html"><![CDATA[<p>随着Android平台的逐渐成熟，伴随着一系列针对Android测试框架的推出，开发人员终于可以如愿以偿的在移动端的开发上进行单元测试，集成测试以及功能测试。在敏捷流程中从开发，到测试，到验收最终成为面向用户的Release版本，经历的是Story一个完整的生命周期。CI(Continuous Integration, 持续交付)在敏捷实践中也因此扮演了非常重要的角色。</p>

<p>如果说Web的持续集成，以及各类测试框架有一定的历史积淀了。那么Android的持续集成可以说是新鲜事物，大部分IT公司知道如何对服务器端或者Web端进行一系列自动化测试，保证其功能的正确性。而对于移动端的产品比较多的则是由测试人员组成的人肉测试。移动端的这种人工测试，无论是对测试人员，还是要经常打包并且来修复各种Bug的开发人员来说，其代价是巨大的。</p>

<!-- more -->


<p>从Android 2.3.3 版本就开始，我就成为了Android的开发者。从开发者的角度见证了Android的步步升级，也从普通用户的角度见证了Android在中低端市场上的统治权。虽然我对Apple的产品也很满意，但是我对Android的感情却也是无法割舍的。我庆幸自己终于能够在Android上也见证测试驱动开发的实践，也庆幸自己有机会去亲身实践，从零开始学习并了解Android的持续集成。</p>

<h3>前言</h3>

<p>本文主要是从零开始，以学习者的角色来探索如何构建可用的Android CI环境。最后的目标是，在Jenkins上从build单元测试，到功能测试的运行，最后通过一键部署编译出可供QA测试的QA版本，可供Release的Release版本，并借助HockeyApp，生成可下载的链接。</p>

<ol>
<li>构建出一个含有单元测试和集成测试简单的App原型。</li>
<li>通过vagrant在本地运行Ubuntu虚拟机，并安装Jenkins服务器，在Ubuntu上安装配置Android运行环境。</li>
<li>在Jenkins中创建Android Pipeline, Android Build &ndash;> Android Functional Test &ndash;> Android Deploy Hockey App。</li>
<li>在Android工程中创建不同的环境变量，使得构建时能够选择不同的构建变量，编译生成QA和Release等不同环境下的App。</li>
</ol>


<h3>1. 构建Android基础工程，本地运行测试</h3>

<p>这里的基础工程主要指的是能够运行测试的基础功能，我选择使用Robolectric做单元测试，使用espresso做继承测试（后面的文章也会探讨使用）。基础工程主要参考了<a href="https://github.com/robolectric/deckard-gradle">robolectric/decard-gradle</a>, 通过一些gradlew的配置，使我们的工程能够直接运行单元测试和集成测试。</p>

<p>运行单元测试:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>./gradlew test
</span></code></pre></td></tr></table></div></figure>


<p>运行espresso测试：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>./gradlew connectedAndroidTest</span></code></pre></td></tr></table></div></figure>


<p>一旦你这个实例运行成功，说明这一步其实已经完成。后面我们只需要通过jenkins来跑这几条命令，然后展示结果即可。</p>

<h3>2. 在虚拟机中安装Jenkins和Android环境</h3>

<p>为了从零开始，我选择了一台干净的Ubuntu/trusty机器，为了使构建从零开始，可以更好的模拟我们在EC2机器真实的情
形。从测试的角度来说，我选择使用<a href="https://www.vagrantup.com/">Vagrant</a>来启动虚拟机。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>XiaoMing:ci minggong$ vagrant init ubuntu/trusty64
</span><span class='line'>A `Vagrantfile` has been placed in this directory. You are now
</span><span class='line'>ready to `vagrant up` your first virtual environment! Please read
</span><span class='line'>the comments in the Vagrantfile as well as documentation on
</span><span class='line'>`vagrantup.com` for more information on using Vagrant.
</span><span class='line'>XiaoMing:ci minggong$ vagrant up
</span><span class='line'>Bringing machine 'default' up with 'virtualbox' provider...
</span><span class='line'>[default] Importing base box 'ubuntu/trusty64'...
</span><span class='line'>[default] Matching MAC address for NAT networking...
</span><span class='line'>[default] Setting the name of the VM...
</span><span class='line'>[default] Clearing any previously set forwarded ports...
</span><span class='line'>[default] Fixed port collision for 22 =&gt; 2222. Now on port 2200.
</span><span class='line'>[default] Creating shared folders metadata...
</span><span class='line'>[default] Clearing any previously set network interfaces...
</span><span class='line'>[default] Preparing network interfaces based on configuration...
</span><span class='line'>[default] Forwarding ports...
</span><span class='line'>[default] -- 22 =&gt; 2200 (adapter 1)
</span><span class='line'>[default] Booting VM...
</span><span class='line'>[default] Waiting for machine to boot. This may take a few minutes...
</span><span class='line'>[default] Machine booted and ready!
</span><span class='line'>[default] Mounting shared folders...
</span><span class='line'>[default] -- /vagrant
</span><span class='line'>XiaoMing:ci minggong$ vagrant ssh
</span><span class='line'>Welcome to Ubuntu 14.04 LTS (GNU/Linux 3.13.0-24-generic x86_64)
</span><span class='line'>
</span><span class='line'> * Documentation:  https://help.ubuntu.com/
</span><span class='line'>Last login: Tue Apr 22 19:47:09 2014 from 10.0.2.2</span></code></pre></td></tr></table></div></figure>


<p>如果在Vagrantfile中已经设置了静态IP，则可以直接通过IP登陆。vagrant默认用户名为 <code>vagrant</code>, 密码为<code>vagrant</code>。</p>

<p>使用 <code>vagrant ssh</code> 登录虚拟机之后，则开始安装各种环境：</p>

<ul>
<li>Java</li>
<li>Jenkins</li>
<li>Android Environment</li>
</ul>


<h4>2.1 安装Java</h4>

<p>apt-get直接安装jdk1.7:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>vagrant@ubuntu-14:~$ sudo apt-get update
</span><span class='line'>vagrant@ubuntu-14:~$ sudo apt-get install openjdk-7-jdk -y
</span><span class='line'>vagrant@ubuntu-14:~$ java -version
</span><span class='line'>java version "1.7.0_75"
</span><span class='line'>OpenJDK Runtime Environment (IcedTea 2.5.4) (7u75-2.5.4-1~trusty1)
</span><span class='line'>OpenJDK 64-Bit Server VM (build 24.75-b04, mixed mode)
</span></code></pre></td></tr></table></div></figure>


<h4>2.2 安装Jenkins</h4>

<p>参考<a href="https://wiki.jenkins-ci.org/display/JENKINS/Installing+Jenkins+on+Ubuntu">Jenkins官方教程</a>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>wget -q -O - https://jenkins-ci.org/debian/jenkins-ci.org.key | sudo apt-key add -
</span><span class='line'>sudo sh -c 'echo deb http://pkg.jenkins-ci.org/debian binary/ &gt; /etc/apt/sources.list.d/jenkins.list'
</span><span class='line'>sudo apt-get update
</span><span class='line'>sudo apt-get install jenkins -y
</span></code></pre></td></tr></table></div></figure>


<p>安装完Jenkins后，首先验证下Jenkins是否安装完毕, <code>curl http://localhost:8080</code>, 如果发现能够输出一堆HTML标签，那么证明Jenkins已经安装成功并已经启动了。Jenkins常见的使用命令如下，默认启动在8080端口：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>vagrant@ubuntu-14:~$ sudo /etc/init.d/jenkins -help
</span><span class='line'>Usage: /etc/init.d/jenkins {start|stop|status|restart|force-reload}</span></code></pre></td></tr></table></div></figure>


<p>Jenkins默认de配置文件为<code>/etc/default/jenkins</code>, 可以看到Jenkins_home定义的路径：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> #jenkins home location
</span><span class='line'> JENKINS_HOME=/var/lib/jenkins</span></code></pre></td></tr></table></div></figure>


<p>如果需要更改默认的Jenkins home 路径，需要更改 <code>/etc/default/jenkins</code>地址，然后重新启动jenkins即可生效。</p>

<h4>2.3 安装Android运行环境</h4>

<p>最后一步我们需要安装Android运行环境，这样我们的Jenkins才能够运行Android的相关测试。主要参考文章 <a href="https://www.digitalocean.com/community/tutorials/how-to-build-android-apps-with-jenkins">How to Build Apps with Jenkins</a></p>

<ul>
<li><a href="http://developer.android.com/sdk/index.html">Android SDK官网</a>找到最新的SDK安装包地址：<a href="http://dl.google.com/android/android-sdk_r24.1.2-linux.tgz,">http://dl.google.com/android/android-sdk_r24.1.2-linux.tgz,</a> 下载并解压：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cd /opt
</span><span class='line'>$ sudo wget http://dl.google.com/android/android-sdk_r24.1.2-linux.tgz
</span><span class='line'>$ sudo tar zxvf android-sdk_r24.1.2-linux.tgz
</span><span class='line'>$ sudo rm android-sdk_r24.1.2-linux.tgz
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>设置Android环境变量：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ vi /etc/profile.d/android.sh
</span></code></pre></td></tr></table></div></figure>


<p>Add the following to android.sh file</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>export ANDROID_HOME="/opt/android-sdk-linux"
</span><span class='line'>export PATH="$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools:$PATH"
</span></code></pre></td></tr></table></div></figure>


<p>然后 <code>source /etc/profile</code>， 使文件生效。</p>

<ul>
<li>配置 Android SDK</li>
</ul>


<p>最简单粗暴的方法是下载所有的SDK及相关的一系列工具，当然也可以挨个下载，具体参考上面提到的这篇文章。我采用直接更新全部的方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>android update sdk --no-ui
</span></code></pre></td></tr></table></div></figure>


<p>经过漫长的等待，下载完毕之后这部分的工作也基本完成。(这一步一般留在半夜自行下载)</p>

<h4>2.4 安装Git</h4>

<p>为了使Jenkins能够直接从Git Repository上下载代码，需要在Ubuntu中安装Git:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo apt-get update
</span><span class='line'>sudo apt-get install git -y
</span></code></pre></td></tr></table></div></figure>


<h4>2.5 配置Jenkins</h4>

<p>Jenkins启动后，首先注册登录用户，然后创建新的Build Project。构建就基本完成了。当然你也可以在前一篇博客 <a href="http://www.gongmingqm10.net/blog/2015/03/11/setup-jenkins-for-android-integration-using-docker/">Set up Jenkins for Android integration using Docker</a>中找到一些插件，通过这些插件能够更好的实现Android的持续集成，包括通过Hockey App 持续的发布新的版本。</p>

<p>具体安装细节，可以参考<a href="http://www.gongmingqm10.net/blog/2015/03/11/setup-jenkins-for-android-integration-using-docker/">Setup Android CI using Docker</a></p>

<p>粗略说来，安装插件: <code>Git plugin, Android emulator plugin, Copy artifact plugin, Android lint plugin, Hockey app plugin, Build monitor plugin</code></p>

<p>运行时发现jenkins用户对jenkins-home目录没有操作权限，需要通过chmod增加权限。在当前vagrant用户下，<code>su jenkins</code> 能够切换到jenkins目录下，但是需要提供密码。所以可以自行修改密码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>vagrant@ubuntu-14:/var/lib/jenkins$ sudo passwd jenkins
</span><span class='line'>Enter new UNIX password:
</span><span class='line'>Retype new UNIX password:
</span><span class='line'>passwd: password updated successfully
</span><span class='line'>vagrant@ubuntu-14:/var/lib/jenkins$ su jenkins
</span><span class='line'>Password:
</span><span class='line'>jenkins@ubuntu-14:~$</span></code></pre></td></tr></table></div></figure>


<p>权限设置成功后，再次运行测试，提示Android Build Tools没有安装成功：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ ./gradlew clean build
</span><span class='line'>
</span><span class='line'>FAILURE: Build failed with an exception.
</span><span class='line'>
</span><span class='line'>* What went wrong:
</span><span class='line'>A problem occurred configuring project ':app'.
</span><span class='line'>&gt; failed to find Build Tools revision 21.1.2
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>Android Build Tools的版本号是我们在app/build.gradle中指定的21.1.2。通过 <code>android list sdk --all</code>能够查看所有可以下载的sdk列表。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Packages available for installation or update: 138
</span><span class='line'>   1- Android SDK Tools, revision 24.1.2
</span><span class='line'>   2- Android SDK Platform-tools, revision 22
</span><span class='line'>   3- Android SDK Build-tools, revision 22.0.1
</span><span class='line'>   4- Android SDK Build-tools, revision 22 (Obsolete)
</span><span class='line'>   5- Android SDK Build-tools, revision 21.1.2
</span><span class='line'>   6- Android SDK Build-tools, revision 21.1.1 (Obsolete)
</span><span class='line'>   7- Android SDK Build-tools, revision 21.1 (Obsolete)
</span><span class='line'>   8- Android SDK Build-tools, revision 21.0.2 (Obsolete)
</span><span class='line'>   9- Android SDK Build-tools, revision 21.0.1 (Obsolete)
</span></code></pre></td></tr></table></div></figure>


<p>可以看到21.1.2的索引值是5，所以可以使用 <code>android update sdk -u --all --filter &lt;number&gt;</code>更新，发现出现权限问题。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Installing Archives:
</span><span class='line'>  Preparing to install archives
</span><span class='line'>  Downloading Android SDK Build-tools, revision 21.1.2
</span><span class='line'>  URL not found: /opt/android-sdk-linux/temp/build-tools_r21.1.2-linux.zip (Permission denied)
</span><span class='line'>  Done. Nothing was installed.</span></code></pre></td></tr></table></div></figure>


<p>可以直接在当前用户下给/opt/android-sdk-linux以及其子文件夹增加777权限。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo chmod -R 777 /opt/android-sdk-linux</span></code></pre></td></tr></table></div></figure>


<p>然后安装Android build tools 21.1.2, <code>android update sdk -u --all --filter 5</code>。安装完成后还可能会出现错误:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>:app:mergeDevDebugResources FAILED
</span><span class='line'>
</span><span class='line'>FAILURE: Build failed with an exception.
</span><span class='line'>
</span><span class='line'>* What went wrong:
</span><span class='line'>Execution failed for task ':app:mergeDevDebugResources'.
</span><span class='line'>&gt; Error: org.gradle.process.internal.ExecException: A problem occurred starting process 'command '/opt/android-sdk-linux/build-tools/22.0.1/aapt''</span></code></pre></td></tr></table></div></figure>


<p>Google了一番，才发现是Android在64为Linux机器上运行而产生的问题，需要安装<code>ia32-libs</code>, 但是通过apt安装确被告知ia32-libs不存在，无法安装。<a href="http://stackoverflow.com/questions/23182765/how-to-install-ia32-libs-in-ubuntu-14-04-lts-trusty-tahr">stackoverflow</a>解决办法如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo -i
</span><span class='line'>cd /etc/apt/sources.list.d
</span><span class='line'>echo "deb http://old-releases.ubuntu.com/ubuntu/ raring main restricted universe multiverse" &gt;ia32-libs-raring.list
</span><span class='line'>apt-get update
</span><span class='line'>apt-get install ia32-libs</span></code></pre></td></tr></table></div></figure>


<p>安装成功后，Android 单元测试即可成功运行。</p>

<p>单元测试之后，我们往往需要运行功能测试，功能测试的时候则需要打开模拟器。也就是 headless android emulator。首先在虚拟机中创建 avd, 然后启动运行模拟器。</p>

<p>运行之前需要先安装 API-21对应的 armeabi-v7a， 才能够创建虚拟机。通过查看<code>android list sdk --all</code>得知其对应的序列号是68，所以可以通过android update安装：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>android update sdk -u --all --filter 68</span></code></pre></td></tr></table></div></figure>


<p>安装完成后创建API-21虚拟机：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>android create avd -f -a -s 1080x1920 -n Nexus-21 -t android-21 --abi</span></code></pre></td></tr></table></div></figure>


<p>虚拟机创建成功后需要打开虚拟机：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>emulator -avd Nexus-21 -no-skin -no-audio -no-window</span></code></pre></td></tr></table></div></figure>


<p>顺利的话，到这里功能测试应该也能够运行了。但是在我的虚拟机里面却没办法启动android emulator。看来想构建真正的android功能测试，还是用一台配有显示器的Mac mini来运行比较的靠谱。</p>

<h3>3.Other</h3>

<p>如何在Android中配置不同的Flavor，如何上传构建好的App到HockeyApp中。欢迎查看我的<a href="http://www.gongmingqm10.net/blog/2015/03/11/setup-jenkins-for-android-integration-using-docker/">博客</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Work in Dallas]]></title>
    <link href="http://www.gongmingqm10.net/blog/2015/03/02/work-in-dallas/"/>
    <updated>2015-03-02T02:39:53+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2015/03/02/work-in-dallas</id>
    <content type="html"><![CDATA[<p>时光匆匆，算上实习期来ThoughtWorks工作已近一年。如果技术方面来看，我提升的主要是广度。但是从敏捷实践角度来看，我正在也将继续朝深度上提升。</p>

<p>敏捷这个词，大学期间或多或少听过，大体的印象是软件工程学的一些术语，之后在项目中才开始慢慢实践。我前后经历过三四个项目，虽然每个项目待的时间不长，但是却又想能够和不同的团队，面对不同的客户，也有幸能够在不同的国家体会不同文化下的敏捷实践的标准。</p>

<!-- more -->


<p>由于敏捷包含的方面很多，作为Developer的我，也会主要从Developer的角度，结合自己的想法来谈自己在这一年对敏捷的认识。此文不是软文，只是自己闲时的一点纪录。不喜求轻喷。</p>

<h3>开发驱动测试(DDT)</h3>

<p>加入TW，很长一段时间我一直都抱有这个想法。当时虽然已经在项目上工作，在Code Review的压力下也会偶尔用开发驱动测试(DDT)。因为别人告诉我<code>不写测试的程序员不是好程序员</code>，这个句式怎么听起来和<code>不想当将军的士兵不是好士兵</code>一个道理。听起来是很多道理，但是真正实施的时候呢，我开始犯难了。</p>

<p>测试的痛点在哪里？我常这样问自己，其实我有时也不知道痛点再哪里，只是不太会写。为什么不会写？因为我连怎么实现都不知道，怎么会写？通过这样反推过来也就是只有知道怎么实现，才知道怎么写测试。这个观点对吗？</p>

<blockquote><p>只有知道怎么实现，才会知道怎么写测试。写测试有点作秀的嫌疑</p></blockquote>

<p>这是我曾经的观点，先别批评我逻辑性或者对测试的理解有多差，因为这是我过去的想法。如果我现在来看这句话的话，我会套用那句很通用的 <code>It depends</code>。肯定有人会反驳，那到底取决于什么呢。</p>

<p>以我现在的认知来看，我之所以不知道在实现之前怎么写测试，往往是由于要测试的对象本身很大，很杂，一个方法要管的事情太多了，所以我不知道怎么测试。其实回过头来想想，当一个东西连测试都很难写的时候，是不是意味着我所要测试的函数做了太多的事情了呢。</p>

<ul>
<li>重构里的术语来讲，自己对类或者方法的设计不太合理，导致要测试的内容过多而不知从何下手。</li>
<li>另外一种角度来看，如果一个测试很难描述出测试对象的时候，为什么不可以多增加几个测试，循序渐进的去添加测试。</li>
<li>如果以上两种情况你都不属于，很不幸有可能你在动手之前应该查一下，确保自己清楚这个被测对象的职责，代码上基本的实现思路。</li>
</ul>


<p>当然对于某些情况，我确实可以先写测试再写实现。例如一个简单的计算器的加法，测试中我知道给函数两个输入值，我期望能够输出某种结果。在这种情形下我知道怎么写测试因为要测试的对象足够简单，负责的事情足够清楚。这种有结果输出的测试也是相对简单的。这时候我甚至完全不用操心别人究竟怎么实现的，我只需要用强有力的测试来验证结果即可。</p>

<p>知已知彼，百战不怠。你之所以知道怎么用测试驱动开发，因为你在测试之前已经在心中将这个函数设计和实现了一遍。如果你和我一样达不到这种境界，那可能就是对这块知识了解确实太少，意味着你该自己补补了。</p>

<h3>测试的价值</h3>

<p>测试到底有没有价值，得看你是怎么理解价值的。从科学的角度来看，肯定会有人用实验来证明写测试能够减少Bug发生率，虽然前期写测试花费时间，但在后期却能够节约时间。这种最常见的来证明敏捷实践标准的理论数见不鲜，但是有时却很难是刚入门的人信服。</p>

<p>从我经历过的项目来看，有测试或者没测试的项目都有接触过。对测试的价值也有自己的认识。先不管别人的研究结果如果，单从开发人员开发时间来考虑，测试的确会花费更多时间，相当于你要写两份代码，一份实现，一份保证已实现的功能不被后期修改破坏掉。当然测试的确可以提高产品质量。</p>

<p>什么时候我不会写测试，虽然我信奉测试是产品质量的保障，但是有时我不一定会写测试：</p>

<ol>
<li>交付周期过短的项目，并且是在没有引入测试的项目基础上开发。这种项目在国内客户中比较常见，多半是对原来的项目增加一个模块，并且之前的代码没有测试。这类项目的特点是周期短，功能相对较少。敏捷实践是敏捷实践，但是没必要固执的和自己死磕。因为也许客户并不在乎你有没有测试，只在乎产品能不能按期上线。</li>
<li>功能变化过快的互联网产品。一些初创型公司在做产品时往往信奉<code>天下武功，唯快不破</code>，特别是公司人手不够，功能较多，并且在每两周一次的迭代中功能变化过大的时候，维护测试变显得有点复杂。当然并不意味着任何的测试都是多余的。这里有个测试力度的问题，具体得靠自己的把握。</li>
</ol>


<p>什么时候我会在项目中引入测试呢？</p>

<ol>
<li>项目周期相对较长，客户经济上有能力承担多几个开发者带来的成本；</li>
<li>如果是在客户原有系统上开发，之前的系统就有一套测试体系，无疑我们在增加代码的时候应该增加测试。而且尽量沿用之前已经构建好的一整套测试体系。</li>
<li>一个从零开始的项目，并且有可能建立长期合作的客户。这是TW的核心竞争力，卓越软件质量的前提。客户不提，我们自己也应该做到。</li>
</ol>


<p>写测试是一种好习惯，至少作为一个合格的程序员，应该写测试。如果你是一个Github上代码贡献的活跃者，在为自己写代码的时候，请尽量为自己的代码加上测试。<a href="https://travis-ci.org/repositories">Travis</a>就是这样一个免费的提供CI服务的平台，如果你想为自己的代码加上测试但是又不想自己去搭建CI，可以试试Travis。</p>

<p>回归正题，测试的价值在于你多看重软件质量。测试有时会消耗一定的时间，但是有测试保障的软件在质量上的确可以提高好几个层次。是否写测试则需要结合你自己的项目实际情况以及客户本身而定。</p>

<p>如果你经历过国内客户和国外客户，那么你应该能够体会到他们对于软件质量的不同态度。当然所有人肯定都希望软件交付质量最高，时间最短。但是当两者需要权衡的时候，国内客户比较在乎的会是进度，国外客户比较在乎的是质量。所以质量和进度之间需要找到一个平衡点。</p>

<p>从国内外客户的差异，其实也可以联想到国内外软件开发者的差异。到美国这边与美国这边的同事办公之后发现，这边的同事对于测试的重视程度要远远高于国内的同事(不是黑ThoughtWorks China的同事们)。<code>You can not do anything when you write test. Test first</code>，这是美国这边一位senior的同事和我pair的时候说的。自己曾经那些不好的编程习惯到了这边是应该好好改改了。</p>

<p>在美国这边工作曾经有几天我对项目上的测试有点质疑了，因为有些地方实在测的太细，几乎是想用测试覆盖掉每一行代码，并且有些代码还被多个测试覆盖。后来偶然的聊天中，同事告诉我 <code>I think I don't write so much meaningful tests in our code, some tests seems to be useless. And Jered is more expereienced, he pointed out.</code>，虽然这是一种谦虚的说法。但是这却告诉我，写好测试才能真正体现测试的价值。</p>

<p>我姑且称那些永远不会fail，或者基本没有测任何有意义的东西的测试为<code>僵尸测试</code>，这种测试太多了直接影响整个测试的可阅读性。好的测试应该可以通过函数命名，测试输出结果的判断来提供文档的功能。所以不要用数量来堆砌测试，努力写好测试是关键。</p>

<h3>敏捷团队角色</h3>

<p>敏捷开发中很重要的一部分是团队角色。一个敏捷团队主要有应用开发工程师(Dev)，业务分析师(BA)，质量保障工程师(QA)等。在项目的Story估点之时，除了有BA和QA的参与，Dev的参与也是很重要的部分。BA和QA主要从业务上评估，Dev主要从技术上评估，这种多人参与过的估点才是有意义的。</p>

<p>同样一个Story制定的时候产品设计效果图和可验证的Scenario是很重要的。Scenario的制定其实考察的是BA/QA对业务以及实际使用场景的考验。这一点我在Mobile端体会尤其明显。因为Mobile端更重交互，对于用户可能有的行为，制定验收标准是就应该考虑清楚。所以这时候BA不仅仅承担一个业务分析的角色，还承担着用户的角色。</p>

<p>Dev和BA沟通Story的时候最简单的情形是以用户为媒介。无论业务分析还是开发实现，最终都是为了给终端用户一个具有某种功能的产品。</p>

<p>有时我会想如果让Dev转型当BA，那这个BA一定很能了解功能的实现者。后来发现这种想法本身存在一定的问题，因为不管这个BA懂不懂具体的实现，BA/QA应该懂的是用户，应该懂得是平台特性以及用户特性。无论是Mobile和Web，抑或是Android和IOS，无论是敏捷团队的何种角色，你都得尝试去了解这个平台的特性，了解终端用户，才能够做出更好的决策。</p>

<h3>结语</h3>

<p>作为ThoughtWorks咨询师，我们应该知道公司的核心竞争力是什么，我们也更应该尝试去影响客户，给客户带来价值。也希望新的一年里自己能够在敏捷实践上做得更好，能够帮助客户，影响客户。</p>

<blockquote><p>We think disruptively to deliver technology to address our clients&#8217; toughest challenges, all while seeking to revolutionize the IT industry and create positive social change.</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Travel to Dallas - Life]]></title>
    <link href="http://www.gongmingqm10.net/blog/2015/03/01/travel-to-dallas-life/"/>
    <updated>2015-03-01T11:44:57+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2015/03/01/travel-to-dallas-life</id>
    <content type="html"><![CDATA[<p>来达拉斯已过半月，从去年的十二月份开始规划，到二月中旬过来，再到过完这边最难熬的两个星期。生活工作渐入正轨，是时候来总结下这个特别的二月。</p>

<h3>出差</h3>

<!-- more -->


<p>“去美国出差”，第一次知道这条消息还是YueYue发我微信上的。看完这条消息的时候内心很激动，因为终于可以去大美利坚了。记得毕业的时候就特羡慕能够来美国念书的同学，心里想着以后有机会也去美国看一看，看一看外面的世界，见识下外面的风土人情。如今这个选择摆在我的面前，我不想像周星驰那句台词里说的那样，“曾经有一段很好的&hellip;摆在我面前，但是&hellip;”。</p>

<p>我要去美国，就是这种想法瞬间在自己的脑海中扎根。冷静之余，我开始想到生活，想过没办法回家过年，和女友又得继续分别数月，在武汉的生活好不容易走上正轨，又得开始去陌生的地方，与陌生的人共事。这种惶恐让人感觉到迷茫。坚定决心，开始和女朋友沟通，于是沟通了几个小时，两人差点闹得分手了。最终我还是说服了在电话那头涕不成声的女友，和父母的沟通稍微顺畅一点，父母支持我自己的决定，但是后来听姐姐说妈妈挂完电话后眼泪也流下来了&hellip;</p>

<p>这有点让我想起一些黑帮片里面的情形，走江湖的都基本无情无爱，了无牵挂，才能走得更远。当然现实生活中，事情远不是0和1的选择，很多事情可以协调的，终于把去美国出差的意向确定了。内心还是十分开心的。</p>

<blockquote><p>对某个城市有个情感的牵绊之后，无论出差到哪里，都只是在漂泊</p></blockquote>

<h3>签证顺利</h3>

<p>由于一直有公司出面，赴美签证，办得相当顺利。前提公司督促我提交各种材料，到2月初终于开始去美国使馆进行面前。除了之前转机在机场停留后，这其实是我第一次到北京，去的那边北京的天空还是挺蓝的。首都给我的印象挺好的，首都国际机场有直达市区的轻轨，这一点比其他二线城市方便多了。到北京后下午立即赶到北京，在Kun的指导下温习了一下次日使馆面试官可能会问我的问题。这种状态颇有大考来临之前老师教我们临阵磨枪的味道。晚上在宾馆停留一晚，第二天赶早去大使馆。</p>

<p>第二天一大早及其兴奋的到了大使馆，结果八点半的美国使馆门口已经是站满了人，几经周折，寄存了手机，抛弃了耳机之后终于来到了大厅。一位和善的面试官接待了我，不知道是太久没听英文了还是什么原因，我竟然基本听不懂面试官在说什么，面试官也估计很奇怪，英文这么差还去出差。但是面试官看我满脸疑惑的时候竟然给我充当了翻译。还好最后面试官对我说了&#8221;Have a good trip&#8221;，我赶紧的各种Thank you奉上。面试完之后，继续上楼缴费了500美元，看来我数月前办的全币信用卡瞬间奏效，出差或者旅游频繁还是要办一张可以刷外币的卡比较安全。</p>

<p>面签顺利通过，签证三日左右就可以拿到。于是我赶紧收拾收拾，返回武汉。</p>

<blockquote><p>面签顺利结束，北京之行太过匆匆</p></blockquote>

<h3>踏上旅途</h3>

<p>出发之前，必然少不了超市淘一批货带到美国。考虑到刚到的时候说不一定能够摸清周围超市状况，我自备牙膏牙刷等洗漱用品。饮食方面，带了我最爱的老干妈以及盐、鸡精等厨房调味品。中国菜不是哪里都有的。当然出发之前还特地买了几件稍微正式点的衣服，唯恐穿着方面给国人丢脸(事实证明想多了)。</p>

<p>临别晚上彻夜未眠，突然要匆匆离别时才觉得平平淡淡的生活竟是如此的宝贵。周围熟悉的一切竟是如此的让人留恋。早上五点半便踏上了去机场的旅程，天还是黑黑的，没有惊动室友。因为大家都是不舍离别的人。</p>

<p>紧接着便是武汉转香港，香港飞达拉斯的旅途。总共二十多个小时的旅途坐得跟以前的硬座火车感觉差不多。几乎昏睡的状态到达了达拉斯。第一感觉就是空旷，没有高耸如云的建筑物，天很蓝，空气真好。</p>

<p>匆忙的安排中没有找到接机的人，于是自己在机场拿起笔记本，找到了自己的地址。还好出口处便直接找到了Yellow cab（出租车），给师傅看了看地址，师傅娴熟的用Google地图来导航，四十余分钟，终于来到了自己的公寓。各种波折，最后终于跨进了自己的房间，放下行李。终于可以说一声：</p>

<blockquote><p>美国，我来了</p></blockquote>

<h3>如何生存</h3>

<p>陌生的环境中最重要的就是吃饭问题，正好趁上周末开始网上搜索附近的超市。最终找到了一家最近的超市，可以买到蔬菜水果和各种吃的。后来还探访到附近的Target专门卖生活用品的，以及Walmart会有更有的其他选择。赶紧的凑齐各种食材，终于在自己的努力下吃了自己在美帝国的第一顿饭，炒的菜有点水土不服，但是电饭煲蒸出来的饭全世界的味道都差不多。再加上周围的各种餐厅，吃饭的问题总算不用愁了。</p>

<p>出行，最初的设想是周末几天出去探访下这边的公共交通，后来发现这边的交通实在是少的可怜，并且在手机没网没发进行户外GPS导航的情况下，公共交通出行着实过于复杂，很容易弄丢。为了不耽误别人，我还是选择近距离在附近转悠。于是自己的活动半径基本就限制在公寓和超市之间。达拉斯在美国应该只能算是二线城市，所以没有这么多的公共交通，这边的人基本上都有自己的车，他们也确实用不上公交车。还好公司考虑到我这种情况，在热心同事的帮助下，总算是能够搭便车了。</p>

<p>刚来的这几天天气真是超好，整个一达拉斯的春天的感觉。再后来发现开始降雪。还好室友有保暖措施，所以室内温度总是很宜人。不过如果长时间待在外面，还是带件稍微厚点的衣服会比较靠谱一点。</p>

<p>医院，来这边没多久，眼睛麦粒肿就把我折腾到了要去看医生的境地。那么问题来了，医院在哪，怎么看医生？几番打探之后，发现附近走路一刻钟就可以找到一家CityDoc Urgent Care, 就诊时带上自己的护照就可以了。然后就是各种资料，填完后就开始等着医生喊我的名字，诊断之后就是去药房Pharmacy拿药。稍微看下医生就花了100多刀，美国的看病还真是不便宜。还好自己终于知道如何看病了。至少不会像以前那么的不安与紧张。</p>

<blockquote><p>衣食住行，生活的根本</p></blockquote>

<h3>SSN申请</h3>

<p>入境美国后，并且如果要长期待的话，SSN社会安全卡的申请自然少不了。公司负责人员会给我发一堆表格，填完之后我得自己去当地的社会安全组织办公室申请，在deadline去申请真不是一件明智的事情。首先，我没考虑到工到Social Security Administration的工作时间，导致差点错过这一天的申请。</p>

<p>申请的这边这天竟然也下着雪，出租车似乎都不怎么停。后来才知道我应该通过App或者电话预约才能够叫到出租车。还好我通过传统的招手的方式找到了出租车。详细描述了地址之后，出租车师傅终于把我带到了社会安全办公室。另外这边的出租车也应该给小费，但凡服务行业都应该给小费10%-20%。</p>

<p>申请通过之后，工作人员会给我一个单子，告诉我社会安全卡会在十个工作日之内寄过来。于是这次申请就完成了。</p>

<h3>结语</h3>

<p>来到TW后，生活发生了翻天覆地的变化，从前一个人在学校里面想去外面走走，现在发现在外面走走之后竟然想回去了。上次参加TWU的时候还有小伙伴陪着一起，这次竟然也就一个人踏上了这段旅途。一个人的旅途充满了各种挑战，一个人扛着一大包东西从超市往回提，一个人在国外度过春节，一个人冒着大雪在这个陌生的地方拦出租，却也一个人周末待在家里连续三天不出门。</p>

<p>我深信这是种经历，经历了异国的生活才能够更好的认识之前的生活。看到这边超市里各种人性化的设计，看到这边红绿灯路口的设计，遇见这边随时都会向你问好并且“Excuse me”的友善。这些都让我对我所生活的这个世界有了更清晰的认识。</p>

<p>美国的生活才过去半月，剩下的两个半月我希望能够认识更多，见识更多，增长更多。无论从工作还是生活，希望一切顺顺利利。</p>

<blockquote><p>Life is a journey, not a destination</p></blockquote>

<p><img src="http://www.gongmingqm10.net/images/dallas-redlight.jpg" title="红绿灯路口" ></p>

<p>行人通过红绿灯路口需要按下按钮，估计这边车多行人少的缘故</p>

<p><img src="http://www.gongmingqm10.net/images/dallas-target.jpg" title="Target百货店" ></p>

<p>这是Target百货店，我在这里找到了自己要买的电饭煲</p>

<p><img src="http://www.gongmingqm10.net/images/dallas-dfl.jpg" title="耸动的云" ></p>

<p>纯净的天空下那股耸动的云，如末日来临一样宏大的场面</p>

<p><img src="http://www.gongmingqm10.net/images/dallas-travis-street.jpg" title="Travis Street" ></p>

<p>自己生活的Travis Street, 天气晴好时外面还是很值得去的。视野一下子清新了不少</p>

<p><img src="http://www.gongmingqm10.net/images/dallas-snow.jpg" title="Dallas雪景" ></p>

<p>Dallas也是会下雪的，或者说是冻雨。路面全部结冰，上班出行困难。温度变化太快</p>

<p><img src="http://www.gongmingqm10.net/images/dallas-social-security-office.jpg" title="Dallas Social Security Office" ></p>

<p>办社会安全卡的地方，这里很少见高高的大楼</p>

<p><img src="http://www.gongmingqm10.net/images/dallas-laoganma.jpg" title="神器老干妈" ></p>

<p>老干妈，出行必备神器。美国亚马逊上直接购买</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2015 Annual Review]]></title>
    <link href="http://www.gongmingqm10.net/blog/2015/01/22/2015-annual-review/"/>
    <updated>2015-01-22T00:34:06+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2015/01/22/2015-annual-review</id>
    <content type="html"><![CDATA[<p>2015年悄然来临，算上实习期，在TW待的日子也将近一年。在Annual Review这个环节我也开始梳理自己走过的2014年，关于项目，关于团队，关于成长的那点苦与甜。按照惯例，我将从以下几个方面一一道来：</p>

<!-- more -->


<h2>Sponser Review</h2>

<h4>过去一年做得好的地方 (What did I do well during the last year) ?</h4>

<ul>
<li>工作中态度积极，项目中有足够的commitment，能够对团队产生价值；</li>
<li>能够主动参加郑大晔校为毕业生辅导，担任毕业生buddy，帮助毕业生成长；</li>
<li>自我驱动力强，除了项目中的技术栈，自己业余还会去学习了解其他新的技术，使得未来能够更好适应项目需要；</li>
</ul>


<h4>过去一年做得不太好的地方 (What did I do less well during the last year) ?</h4>

<ul>
<li>与客户的直接沟通不是太多，没有过多的去影响客户；</li>
<li>TDD，小步提交等敏捷实践技能还有待提升；</li>
</ul>


<h4>过去一年学到的东西 (What did I learn last year)?</h4>

<ul>
<li>技术方面的成长：重构能力，测试驱动开发，持续集成，ROR和Spring的熟练运用；</li>
<li>团队协作及沟通能力的提升：在团队中学会了如何和同事一起共事，如何进行有效沟通及反馈；</li>
<li>英文的提升：在TWU的学习，使得英文听说能力获得一定的提升；</li>
</ul>


<h4>预期/建议 (What will I do differently in the future)?</h4>

<ul>
<li>提升自己的英语表达，读写能力，能够与客户产生更多的沟通，影响客户；</li>
<li>在项目组内部承担更多的ownership，积极主动跟进项目，保证项目更良好的发展；</li>
<li>技术上，在mobile方面能够更深入一点，除了之前的android，能够学会ios开发；在移动测试方面有更多的实践；</li>
<li>影响力方面，能够在办公室内部比如郑大晔校，技术session中都能够有所产出，承担起更大的责任；</li>
</ul>


<h2>Self Review</h2>

<h3>Performance in role/roles</h3>

<p>项目无疑是我工作的核心，也是过去一年我对公司产生的价值的体现。这一年待过三个项目：LiveText MVP，西山居APP，UNICEF MICS。</p>

<h4>1. LiveText MVP</h4>

<p>这是我在ThoughtWorks西安实习时接触的第一个项目，也是我接触的第一个Web项目。刚上项目就晕晕乎乎的进入到Billable的状态，陌生的技术栈，全新的英语环境，敏捷的做事方式等瞬间向我袭来。开始是痛苦的，但是结局却是令人满意的。一个月的适应环境之后，在大家的帮助以及个人主动学习的作用下我了解了ROR和Angular技术栈，对团队产生价值才更有做事情的动力。后面两个月我都是在较好的状态中和大家pair做story。</p>

<p>过程中收获的不仅是技术，更是ThoughtWorks敏捷风格对我的熏陶。</p>

<h4>2. 西山居 Game APP</h4>

<p>这是Rebase武汉后的第一个项目，做这个项目的同时其实我已经在UNICEF MICS项目上。西山居项目周期短三周交付。Android端主要由我和谢威负责开发，难得在TW能够做回自己的老本行，高兴之余也希望能够实现自己的价值。通过自己安排一些part time的时间，我迅速整完了scope内的几块功能点，最后和谢威配合，还是很及时成功完成了项目的交付。</p>

<p>国内项目的周期短以及客户“不靠谱”还是给我留下了深刻印象，那种情况下只能靠自己，以及如何跟客户进行有效沟通，规避项目交付风险。</p>

<h4>3. UNICEF MICS</h4>

<p>由于在LiveText上有过ROR背景，自然而然上了同样技术栈的UNICEF项目。项目中，我能够利用之前的一些经验为项目部署、测试、前端CSS等贡献自己的力量。项目时间紧迫时我会保证足够的commitment，为整个项目组“减压”。这个项目中，我将自己定位为“老员工”，多主动承担一些前端工作。</p>

<p>这个项目让我对自己有了更大的信心，我可以在团队中产生很大作用。同时我深刻体会到与客户沟通的重要性，以及如何明确scope，降低项目风险。</p>

<h3>Customer Focus</h3>

<p>项目中能够有足够高的积极性，在西山居项目周期紧并且兼职在两个项目上时会贡献自己的下班时间和周末时间，使得项目能够按时给客户交付。
在UNICEF项目上，虽然没有直面客户，但是却勇于担起网站前端大部分工作，也经常为了项目贡献自己额外的休息时间。</p>

<h3>Impact</h3>

<p>影响力方面主要还是集中在团队内部，在公司内部以及影响客户方面还有待加强。</p>

<h3>Skill</h3>

<ul>
<li>Web方面，无论是ROR还是Java Spring相比于之前的零基础进步很大，但是还需要更多的项目经验才能更深入的提升相关开发技能；</li>
<li>Android移动开发方面，由于Android开发做过一段时间，对这块开发比较熟悉，过去的项目经验使得现在能够比较轻松的驾驭一个Mobile项目；</li>
<li>IOS开发，积极参加了一些基础的Workshop, 也通过自我学习开始了对Swift IOS 的入门，不过这块还需要更多的训练；</li>
<li>CI: 在AWS上了解使用了Jenkins, 能够自己独立的搭建CI以及自动化QA部署环境；</li>
<li>前端：主要了解并使用了AngularJS前端框架，CSS方面运用熟练，能够承担团队绝大部分前端工作；</li>
</ul>


<h3>Others</h3>

<ul>
<li>助力校招：积极参与到西安办公室秋招，在笔试现场担任监考官；</li>
<li>郑大晔校：在武汉地区2015届郑大晔校中，参与到晔校课堂中为2015届新同学答疑，并积极担任毕业生Buddy；</li>
<li>社招作业：在武汉办公室，积极协助HR团队，帮助评价候选人笔试作业；</li>
</ul>


<h3>Development Expectation</h3>

<ul>
<li>提升自己的英语表达，读写能力，能正常和客户沟通；</li>
<li>在项目中能够与客户进行更多的沟通，在项目非技术问题上能够承担起更多的ownship，主动去做一些事情；</li>
<li>技术上，在mobile方面能够更深入一点，除了之前的android，能够学会ios开发；</li>
<li>影响力方面，在郑大晔校，技术session中都能够有所产出；</li>
<li>项目安排上，希望能够尽可能多的参与Mobile项目；</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[常用的Linux Cmd]]></title>
    <link href="http://www.gongmingqm10.net/blog/2014/10/30/chang-yong-de-linux-cmd/"/>
    <updated>2014-10-30T15:47:40+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2014/10/30/chang-yong-de-linux-cmd</id>
    <content type="html"><![CDATA[<p>ls：查看目录下所有可见文件<br/>
ls -a ： 查看目录下所有文件，包括隐藏文件  <br/>
ls -l : 查看目录下可见文件的详细信息<br/>
ls -al 查看目录下所有文件的详细信息</p>

<!-- more -->


<p>cat file: 查看文件内容<br/>
cat -n file: 查看文件内容，并显示出行号<br/>
cat file1 file2 >> file3：将file1, file2的文件内容以此加到file3中，如果file3存在，则会在file3后面继续追加，不会覆盖file3原来的内容，如果file3不存在，则会自动创建。若需要强行覆盖，使用一个  > 即可</p>

<p>touch file: 新建文件，当文件存在时则会更新文件的时间戳</p>

<p>pwd: 查看当前目录<br/>
cd {path} : 进入目录</p>

<p>mkdir {directory}: 新建目录，若某子目录不存在则可能新建失败<br/>
mkdir -p {directory}: 新建目录，对于不存在的子目录可以一并创建</p>

<p>tree: 查看当前目录的文件树结构</p>

<p>cp file1 file1-copy: 复制file1到file1-copy<br/>
cp -r dir1 dir2: 复制文件夹dir1到dir2</p>

<p>mv: 移动文件，也可用来重命名文件，具体用法和cp一样</p>

<p>rmdir directory1: 移除一个空的文件夹<br/>
rm file: 移除文件<br/>
rm -r directory1: 移除文件夹</p>

<p>chmod：修改文件的权限
u : user, g : Group, o : others    增加权限“＋”，删除权限“－”   r (Read), w (Write), x (Execute).<br/>
chmod u+x file1, 给当前用户增加对file1的执行权限</p>

<p>wc -l file1: 计算file1的行数<br/>
wc -w file1: 计算file1单词的个数<br/>
wc -c file1: 计算file1中字符的个数</p>

<p>history: 查看历史命令纪录<br/>
!-1 : 执行倒数第一条命令<br/>
!345: 执行第345条命令</p>

<p>cat file1 | grep A : 从file1中找到带有‘A’的行<br/>
find . -name *.png 在当前文件夹下查找后缀名为.png的文件，子文件夹中的文件也可以被找出。</p>

<p>更多命令，欢迎大家一起总结与补充</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android电话监听]]></title>
    <link href="http://www.gongmingqm10.net/blog/2014/10/29/androiddian-hua-jian-ting/"/>
    <updated>2014-10-29T11:11:48+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2014/10/29/androiddian-hua-jian-ting</id>
    <content type="html"><![CDATA[<p>看题名，本篇博文似乎是关于怎么监听别人的电话。其实不然，这里我主要做的是监听自己的电话。监听自己电话的场景来源如下：<br/>
我最近在换手机，当然也在换号。于是面对两个号码两部手机，特别是一些捆绑了银行卡活着以前的快递等情况下，我必须得带两部手机出门，防止旧手机上重要的电话漏接。最开始是想直接进行通过转接，但是面对电信和移动间的通话转移，我放弃了这个想法。于是开始想着用软件提醒。<br/>
在老手机上安装APP，这个APP的作用是监听来电，来电挂断之后会自动给你设定的新手机上发送短信，告诉你谁给你打来了一个未接电话，这样你在新手机上看到短信来电提醒，于是可以直接在新手机上进行回复了。虽然不能直接解决通话的问题，但是确解决了我的问题。考虑到老手机上每个月的短信套餐，发现其实成本也几乎为零。</p>

<!-- more -->


<p>实现部分主要注册一个CallReceiver，并给我们的Receiver监听电话，发送短信，开机重启等权限。编译通过后便可以安装在手机上使用了。贴出主要代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>package net.gongmingqm10.callwatcher;
</span><span class='line'>
</span><span class='line'>import android.app.Service;
</span><span class='line'>import android.content.BroadcastReceiver;
</span><span class='line'>import android.content.Context;
</span><span class='line'>import android.content.Intent;
</span><span class='line'>import android.telephony.SmsManager;
</span><span class='line'>import android.telephony.TelephonyManager;
</span><span class='line'>import android.util.Log;
</span><span class='line'>
</span><span class='line'>public class CallReceiver extends BroadcastReceiver {
</span><span class='line'>
</span><span class='line'>    private final static String NUMBER = "Your Phone number"; //我的新手机号
</span><span class='line'>    @Override
</span><span class='line'>    public void onReceive(Context context, Intent intent) {
</span><span class='line'>        if (intent.getAction().equals(Intent.ACTION_NEW_OUTGOING_CALL)) return;
</span><span class='line'>        TelephonyManager tm = (TelephonyManager) context.getSystemService(Service.TELEPHONY_SERVICE);
</span><span class='line'>        SmsManager sms = SmsManager.getDefault();
</span><span class='line'>        Log.i("state", "state = " + tm.getCallState());
</span><span class='line'>        if (tm.getCallState() == TelephonyManager.CALL_STATE_IDLE) {
</span><span class='line'>            String incomingNumber = intent.getStringExtra("incoming_number");
</span><span class='line'>            try {
</span><span class='line'>                Thread.sleep(5000);
</span><span class='line'>            } catch (InterruptedException e) {
</span><span class='line'>                e.printStackTrace();
</span><span class='line'>            }
</span><span class='line'>            sms.sendTextMessage(NUMBER, "", "主人，有人给你附属机打电话了：" + incomingNumber, null, null);
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;?xml version="1.0" encoding="utf-8"?&gt;
</span><span class='line'>&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"
</span><span class='line'>    package="net.gongmingqm10.callwatcher" &gt;
</span><span class='line'>
</span><span class='line'>    &lt;uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"/&gt;
</span><span class='line'>    &lt;uses-permission android:name="android.permission.READ_PHONE_STATE"/&gt;
</span><span class='line'>    &lt;uses-permission android:name="android.permission.PROCESS_OUTGOING_CALLS"/&gt;
</span><span class='line'>    &lt;uses-permission android:name="android.permission.SEND_SMS"/&gt;
</span><span class='line'>
</span><span class='line'>    &lt;application
</span><span class='line'>        android:allowBackup="true"
</span><span class='line'>        android:icon="@drawable/ic_launcher"
</span><span class='line'>        android:label="@string/app_name"
</span><span class='line'>        android:theme="@style/AppTheme" &gt;
</span><span class='line'>        &lt;activity
</span><span class='line'>            android:name=".MainActivity"
</span><span class='line'>            android:label="@string/app_name" &gt;
</span><span class='line'>            &lt;intent-filter&gt;
</span><span class='line'>                &lt;action android:name="android.intent.action.MAIN" /&gt;
</span><span class='line'>
</span><span class='line'>                &lt;category android:name="android.intent.category.LAUNCHER" /&gt;
</span><span class='line'>            &lt;/intent-filter&gt;
</span><span class='line'>        &lt;/activity&gt;
</span><span class='line'>        &lt;receiver android:name=".CallReceiver"&gt;
</span><span class='line'>            &lt;intent-filter&gt;
</span><span class='line'>                &lt;action android:name="android.intent.action.BOOT_COMPLETED"/&gt;
</span><span class='line'>                &lt;action android:name="android.intent.action.PHONE_STATE"/&gt;
</span><span class='line'>                &lt;action android:name="android.intent.action.NEW_OUTGOING_CALL"/&gt;
</span><span class='line'>            &lt;/intent-filter&gt;
</span><span class='line'>        &lt;/receiver&gt;
</span><span class='line'>    &lt;/application&gt;
</span><span class='line'>
</span><span class='line'>&lt;/manifest&gt;
</span></code></pre></td></tr></table></div></figure>


<p>主界面几乎没任何交互。主要实现功能，想更多交互的话可以继续～</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Data Cache]]></title>
    <link href="http://www.gongmingqm10.net/blog/2014/10/28/android-data-cache/"/>
    <updated>2014-10-28T17:11:26+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2014/10/28/android-data-cache</id>
    <content type="html"><![CDATA[<p>Android APP开发过程中，我们通常会加入缓存模块。缓存即在本地保存APP的一些数据，大部分是将网络请求的数据进行本地保存，这样在缓存数据有效期内就可以直接使用缓存数据，降低了APP和服务器的压力，也极大提升了用户体验。Android数据缓存既可以以数据表的形式进行保存，也可以以文件的形式进行缓存。这里我主要通过缓存文件存储数据，并在APP下一次启动时读取。</p>

<!-- more -->


<h3>Usage</h3>

<p>整个Cache模块的设计思想很简单，每个缓存数据都对应一个key，每个缓存数据又会被存到以此key命名的文件中，需要时直接读取。关键类分别为<code>CacheData</code>, <code>CacheManager</code>, <code>CacheUtils</code>。</p>

<ul>
<li>CacheData：数据封装类，所有欲缓存的数据都通过CacheData封装，CacheData中能够定义缓存有效期，并可以通过getData()直接获取真实的缓存数据。</li>
<li>CacheManager: 缓存管理类，单例模式设计，负责缓存的存储和读取。</li>
<li>CacheUtils: 缓存常用类，所有的缓存Key都应该在这个类中定义，此类还定义了一些时间常量，缓存有效期中可以使用。</li>
</ul>


<p>使用方法如下：</p>

<ul>
<li>step1: <code>CacheManager.init(Context context)</code>, 在APP加载时就应该对CacheManager初始化。</li>
<li>step2: 自定义的Model需要实现序列化，使用CacheData进行包装，然后使用CacheManager进行存储和读取。</li>
</ul>


<h3>Code Download</h3>

<p>项目代码托管在<a href="https://github.com/gongmingqm10/AndroidUikit/tree/master/library/src/main/java/org/gongming/common/cache">Github Repo</a>中，欢迎star和fork。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hack 京东Lebook]]></title>
    <link href="http://www.gongmingqm10.net/blog/2014/10/26/hack-jing-dong-lebook/"/>
    <updated>2014-10-26T22:46:18+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2014/10/26/hack-jing-dong-lebook</id>
    <content type="html"><![CDATA[<p>adb devices : 列出所有的设备</p>

<p>adb -s XXXX shell: 进入指定的shell</p>

<p>adb shell: 进入唯一的shell</p>

<p>在terminal中直接： adb pull /data/data/com.jingdong.app.reader/files/epub/3690098/534543.jeb <br/>
~/Desktop/test.epub。可以直接拿到epub文件</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vagrant 搭建本地虚拟机]]></title>
    <link href="http://www.gongmingqm10.net/blog/2014/10/21/vagrant-da-jian-ben-di-xu-ni-ji/"/>
    <updated>2014-10-21T11:06:42+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2014/10/21/vagrant-da-jian-ben-di-xu-ni-ji</id>
    <content type="html"><![CDATA[<p>多数情况下，为了模拟服务器环境，我们经常使用虚拟机，通过虚拟机，我们可以轻松模拟出真实的服务器环境，从而对我们代码的部署等进行模拟，当然也可以当作自己练手的好工具。把Linux虚拟机当作是真实的服务器，然后通过内网访问虚拟机上的服务器资源。<br/>
虚拟机除了大家熟知的界面化的VirtualBox外，其实还有一个神器叫做<a href="https://www.vagrantup.com/">Vagrant</a>，Vagrant是依赖于VirtualBox的，但是其好处是提供命令行式的操作，我们直接通过命令行控制虚拟机的运行状态，并可以通过ssh命令直接连接到虚拟机中，命令行操作一切，还是相当方面的。</p>

<!-- more -->


<p>安装过程见官方文档：<a href="https://www.vagrantup.com/downloads.html">https://www.vagrantup.com/downloads.html</a>。</p>

<h3>1. vagrant init</h3>

<p>安装完成后，Vagrant就可以直接在我们的命令行中使用。首先我们在选定的文件夹中执行<code>vagrant init</code>，这时我们可以看到此文件夹下自动生成了一个<code>Vagrantfile</code>文件:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># -*- mode: ruby -*-
</span><span class='line'># vi: set ft=ruby :
</span><span class='line'>
</span><span class='line'>Vagrant.configure("2") do |config|
</span><span class='line'>  # All Vagrant configuration is done here. The most common configuration
</span><span class='line'>  # options are documented and commented below. For a complete reference,
</span><span class='line'>  # please see the online documentation at vagrantup.com.
</span><span class='line'>
</span><span class='line'>  # Every Vagrant virtual environment requires a box to build off of.
</span><span class='line'>  config.vm.box = "base"
</span><span class='line'>
</span><span class='line'>  # The url from where the 'config.vm.box' box will be fetched if it
</span><span class='line'>  # doesn't already exist on the user's system.
</span><span class='line'>  # config.vm.box_url = "http://domain.com/path/to/above.box"
</span><span class='line'>
</span><span class='line'>  # Create a forwarded port mapping which allows access to a specific port
</span><span class='line'>  # within the machine from a port on the host machine. In the example below,
</span><span class='line'>  # accessing "localhost:8080" will access port 80 on the guest machine.
</span><span class='line'>  # config.vm.network :forwarded_port, guest: 80, host: 8080
</span><span class='line'>
</span><span class='line'>  # Create a private network, which allows host-only access to the machine
</span><span class='line'>  # using a specific IP.
</span><span class='line'>  # config.vm.network :private_network, ip: "192.168.33.10"
</span><span class='line'>
</span><span class='line'>  # Create a public network, which generally matched to bridged network.
</span><span class='line'>  # Bridged networks make the machine appear as another physical device on
</span><span class='line'>  # your network.
</span><span class='line'>  # config.vm.network :public_network
</span><span class='line'>
</span><span class='line'>  # Share an additional folder to the guest VM. The first argument is
</span><span class='line'>  # the path on the host to the actual folder. The second argument is
</span><span class='line'>  # the path on the guest to mount the folder. And the optional third
</span><span class='line'>  # argument is a set of non-required options.
</span><span class='line'>  # config.vm.synced_folder "../data", "/vagrant_data"
</span><span class='line'>
</span><span class='line'>  # Provider-specific configuration so you can fine-tune various
</span><span class='line'>  # backing providers for Vagrant. These expose provider-specific options.
</span><span class='line'>  # Example for VirtualBox:
</span><span class='line'>  #
</span><span class='line'>  # config.vm.provider :virtualbox do |vb|
</span><span class='line'>  #   # Don't boot with headless mode
</span><span class='line'>  #   vb.gui = true
</span><span class='line'>  #
</span><span class='line'>  #   # Use VBoxManage to customize the VM. For example to change memory:
</span><span class='line'>  #   vb.customize ["modifyvm", :id, "--memory", "1024"]
</span><span class='line'>  # end
</span><span class='line'>  #
</span><span class='line'>  # View the documentation for the provider you're using for more
</span><span class='line'>  # information on available options.
</span><span class='line'>
</span><span class='line'>  # Enable provisioning with Puppet stand alone.  Puppet manifests
</span><span class='line'>  # are contained in a directory path relative to this Vagrantfile.
</span><span class='line'>  # You will need to create the manifests directory and a manifest in
</span><span class='line'>  # the file base.pp in the manifests_path directory.
</span><span class='line'>  #
</span><span class='line'>  # An example Puppet manifest to provision the message of the day:
</span><span class='line'>  #
</span><span class='line'>  # # group { "puppet":
</span><span class='line'>  # #   ensure =&gt; "present",
</span><span class='line'>  # # }
</span><span class='line'>  # #
</span><span class='line'>  # # File { owner =&gt; 0, group =&gt; 0, mode =&gt; 0644 }
</span><span class='line'>  # #
</span><span class='line'>  # # file { '/etc/motd':
</span><span class='line'>  # #   content =&gt; "Welcome to your Vagrant-built virtual machine!
</span><span class='line'>  # #               Managed by Puppet.\n"
</span><span class='line'>  # # }
</span><span class='line'>  #
</span><span class='line'>  # config.vm.provision :puppet do |puppet|
</span><span class='line'>  #   puppet.manifests_path = "manifests"
</span><span class='line'>  #   puppet.manifest_file  = "init.pp"
</span><span class='line'>  # end
</span><span class='line'>
</span><span class='line'>  # Enable provisioning with chef solo, specifying a cookbooks path, roles
</span><span class='line'>  # path, and data_bags path (all relative to this Vagrantfile), and adding
</span><span class='line'>  # some recipes and/or roles.
</span><span class='line'>  #
</span><span class='line'>  # config.vm.provision :chef_solo do |chef|
</span><span class='line'>  #   chef.cookbooks_path = "../my-recipes/cookbooks"
</span><span class='line'>  #   chef.roles_path = "../my-recipes/roles"
</span><span class='line'>  #   chef.data_bags_path = "../my-recipes/data_bags"
</span><span class='line'>  #   chef.add_recipe "mysql"
</span><span class='line'>  #   chef.add_role "web"
</span><span class='line'>  #
</span><span class='line'>  #   # You may also specify custom JSON attributes:
</span><span class='line'>  #   chef.json = { :mysql_password =&gt; "foo" }
</span><span class='line'>  # end
</span><span class='line'>
</span><span class='line'>  # Enable provisioning with chef server, specifying the chef server URL,
</span><span class='line'>  # and the path to the validation key (relative to this Vagrantfile).
</span><span class='line'>  #
</span><span class='line'>  # The Opscode Platform uses HTTPS. Substitute your organization for
</span><span class='line'>  # ORGNAME in the URL and validation key.
</span><span class='line'>  #
</span><span class='line'>  # If you have your own Chef Server, use the appropriate URL, which may be
</span><span class='line'>  # HTTP instead of HTTPS depending on your configuration. Also change the
</span><span class='line'>  # validation key to validation.pem.
</span><span class='line'>  #
</span><span class='line'>  # config.vm.provision :chef_client do |chef|
</span><span class='line'>  #   chef.chef_server_url = "https://api.opscode.com/organizations/ORGNAME"
</span><span class='line'>  #   chef.validation_key_path = "ORGNAME-validator.pem"
</span><span class='line'>  # end
</span><span class='line'>  #
</span><span class='line'>  # If you're using the Opscode platform, your validator client is
</span><span class='line'>  # ORGNAME-validator, replacing ORGNAME with your organization name.
</span><span class='line'>  #
</span><span class='line'>  # If you have your own Chef Server, the default validation client name is
</span><span class='line'>  # chef-validator, unless you changed the configuration.
</span><span class='line'>  #
</span><span class='line'>  #   chef.validation_client_name = "ORGNAME-validator"
</span><span class='line'>end
</span></code></pre></td></tr></table></div></figure>


<p>上面几乎有所有的配置说明，我们可以根据自己需要进行命令的配置，我根据自己的需要进行了如下配置：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>VAGRANTFILE_API_VERSION = "2"
</span><span class='line'>
</span><span class='line'>Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|
</span><span class='line'>  config.vm.box = "base"
</span><span class='line'>  config.vm.box = 'centos-6.4'
</span><span class='line'>  config.vm.box_url = 'https://github.com/2creatives/vagrant-centos/releases/download/v6.5.1/centos65-x86_64-20131205.box'
</span><span class='line'>  config.vm.network :private_network, ip:'192.168.3.10'
</span><span class='line'>  config.vm.network :forwarded_port, guest: 27017, host: 8888
</span><span class='line'>end
</span></code></pre></td></tr></table></div></figure>


<p>根据配置名字可以知道各项的具体作用，包括此系统的下载地址，系统的类型及版本号，虚拟机的内网IP，虚拟机的端口转发等。注意这里的host端口默认为27017，但是这个端口被我电脑中的mongodb占用，所以我修改成另外一个闲置的端口。<br/>
配置完成后，我们的工作基本完成。</p>

<h3>2. vagrant up</h3>

<p><code>vagrant up</code>用于启动虚拟机。文件配置完成之后在此文件夹中运行<code>vagrant up</code>，将加载此文件夹中的Vagrantfile，首次加载时需要下载虚拟机系统，所以耗时会略长。下载完成之后你会看到成功的提示。</p>

<h3>3. ssh connect virtual machine</h3>

<p>虚拟机成功启动后，我们只需要在terminal中通过<code>ssh</code>就可以连接到虚拟机设备上。然后就想在远程服务器中来操作就可以了。vagrant启动的地址是我们配置文件中的<code>192.168.3.10</code>，其默认的用户名为root，初始密码为 vagrant。所以我们使用如下命令登陆：<code>ssh root@192.168.3.10</code>，提示密码时输入<code>vagrant</code>，最后我们可以成功登陆。</p>

<p>登陆完成后，如果我们想停下虚拟机，可以使用<code>vagrant destroy</code>关闭虚拟机。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Openfire - Android IM 框架使用]]></title>
    <link href="http://www.gongmingqm10.net/blog/2014/10/21/openfire-android-im-kuang-jia-shi-yong/"/>
    <updated>2014-10-21T10:02:58+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2014/10/21/openfire-android-im-kuang-jia-shi-yong</id>
    <content type="html"><![CDATA[<p>IM(Instant Messaging)在Android中可谓运用广泛。QQ，Wechat，陌陌等应用都可以看作IM实时通讯APP，实时通讯在社交类APP中运用范围较广，其功能看起来也是比较cool的。今天我们将研究一下android IM软件是如何实现的。像IM这种实施通讯软件，除非公司有比较大的实力和精力，才会自己去整这么一套框架。对于广大中小软件开发者来说，想到比较多的就是开源框架。Opensource对于开发者来说简直就是福音，对于整个软件行业也起到了不小的推动性的作用。<br/>
Openfire在这种环境下应运而生，而且作为实时通讯类开源框架迅速走红，下面我们就一起来学习这样一款拯救宇宙的开源框架，文章的最后会运用Openfire做出一个可以实时通讯的AndroidAPP，如果结合上地理位置再多点UI和交互上的设计提升，这不就是陌陌吗？YY了一会，觉得挺有趣，那么 <code>Just do it</code>。</p>

<!-- more -->


<p>Openfire概念性介绍请点击：<a href="http://blog.csdn.net/ithomer/article/details/7192257">http://blog.csdn.net/ithomer/article/details/7192257</a><br/>
Openfire官网：<a href="http://www.igniterealtime.org/">http://www.igniterealtime.org/</a><br/>
Openfire安装文档：<a href="http://www.igniterealtime.org/builds/openfire/docs/latest/documentation/install-guide.html">http://www.igniterealtime.org/builds/openfire/docs/latest/documentation/install-guide.html</a></p>

<h3>1. 选择服务器</h3>

<p>对于实时通讯软件，除了我们的客户端，服务器端更是关键。因为服务器是连接两个会话的桥梁。根据安装文档中，Openfire提供了多个平台的安装版本。Windows, Linux/Unix。所以支持还是很丰富的。至于服务器的选择我们可以选择自己的ECS，本地PC，或者Linux虚拟机。选择本机安装的请略过此步骤。<br/>
为了更加符合真实的安装环境，我选择本地的Linux虚拟机作为服务器环境。方便以后部署到真实的服务器环境中。  <br/>
在进行下一步之前请先在server上安装mysql和java。</p>

<h3>2. Install openfire</h3>

<p>从官网上下载对应的版本，我这里选择<a href="http://www.igniterealtime.org/downloads/index.jsp">Openfire_3.9.3 Linux版本</a>，登陆服务器后直接使用wget下载</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>wget http://www.igniterealtime.org/downloadServlet?filename=openfire/openfire-3.9.3-1.i386.rpm
</span><span class='line'>
</span><span class='line'>//下载完成后使用rpm进行安装
</span><span class='line'>
</span><span class='line'>rpm -ivh openfire-3.9.3-1.i386.rpm
</span></code></pre></td></tr></table></div></figure>


<p>Openfire安装完成后会在/opt目录下生成openfire/目录。
安装完成后就需要进行数据库的配置，按照官方文档：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Make sure that you are using MySQL 4.1.18 or later (5.x recommended) ¹.
</span><span class='line'>Create a database for the Openfire tables:
</span><span class='line'>mysqladmin create [databaseName]
</span><span class='line'>(note: "databaseName" can be something like 'openfire')
</span><span class='line'>Import the schema file from the resources/database directory of the installation folder:
</span><span class='line'>Unix/Linux: cat openfire_mysql.sql | mysql [databaseName];
</span><span class='line'>Windows: type openfire_mysql.sql | mysql [databaseName];
</span><span class='line'>Start the Openfire setup tool, and use the appropriate JDBC connection settings.
</span></code></pre></td></tr></table></div></figure>


<p>首先使用<code>mysqladmin create openfire</code>创建名为openfire的数据库, <code>cd /opt/openfire/resources/database</code>进入openfire的数据库资源目录，使用<code>cat openfire_mysql.sql | mysql openfire</code>导入openfire的schema数据库文件。</p>

<h3>3. 启动Openfire服务</h3>

<p>使用rpm安装完成后的openfire会在/etc/init.d/中自动生成openfire 文件，可以直接在这里打开服务.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Usage /etc/init.d/openfire {start|stop|restart|status|condrestart|reload}
</span></code></pre></td></tr></table></div></figure>


<p>运行openfire服务：<code>/etc/init.d/openfire start</code>，运行<code>/etc/init.d/openfire status</code>显示没有成功运行。<br/>
查看log <code>cat /opt/openfire/logs</code>，显示<code>nohup: cannot run command /opt/openfire/jre/bin/java: No such file or directory</code>，看来openfire找不到java，所以不能成功启动，但是我们的系统的确已经安装了java，所以可以通过软链解决：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd /opt/openfire/jre/bin
</span><span class='line'>cp java java.bak
</span><span class='line'>rm java
</span><span class='line'>ln -s /usr/bin/java java
</span><span class='line'>service openfire start
</span></code></pre></td></tr></table></div></figure>


<p>软链完成之后，再次开启openfire服务：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[root@iZ23572i0rtZ bin]# /etc/init.d/openfire status
</span><span class='line'>openfire is not running
</span><span class='line'>[root@iZ23572i0rtZ bin]# /etc/init.d/openfire start
</span><span class='line'>Starting openfire:
</span><span class='line'>[root@iZ23572i0rtZ bin]# /etc/init.d/openfire status
</span><span class='line'>openfire is running
</span></code></pre></td></tr></table></div></figure>


<p>status显示openfire已经成功启动。通过虚拟机ip访问9090端口，这时会跳转到setup界面，只需要通过setup便可以完成相关配置。</p>

<p>配置完成之后即可以登录自己的管理控制台。</p>

<h3>4. Integrate to Android</h3>

<p>既然服务器安装完成，那我们可以着手我们的APP。与Openfire关联的客户端XMPP协议库是smack。摸索一番之后发现，要在Android中使用Smack必须使用ASmack库。<a href="http://asmack.freakempire.de/">ASmack下载地址</a>。<br/>
以实例为主，通过smack实现两个客户端之间的即时通信。<a href="https://github.com/gongmingqm10/SmackDemo">下载地址</a></p>

<h4>Attention</h4>

<ul>
<li>在AndroidManifest中必须添加Internet permission,否则连接失败。<code>&lt;uses-permission android:name="android.permission.INTERNET"/&gt;</code>.</li>
<li>客户端对客户端创建聊天时，SID为 username@XXXX, XXXX表示的是服务器名字，我这里是ECS主机名。</li>
</ul>


<h3>5. Github Repository</h3>

<p><a href="https://github.com/gongmingqm10/SmackDemo">https://github.com/gongmingqm10/SmackDemo</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Deploy Your App]]></title>
    <link href="http://www.gongmingqm10.net/blog/2014/10/17/android-deploy-your-app/"/>
    <updated>2014-10-17T12:56:13+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2014/10/17/android-deploy-your-app</id>
    <content type="html"><![CDATA[<p>发布Android APP说通俗点就是“打包”，大部分情况下我们可以直接通过IDE进行签名打包，打包好的apk文件就可以上传到各大应用市场啦。今天项目开发过程中突然遇到需要更换debug.keystore的问题了，于是突然想好好研究一下Android打包的全过程，以及各个文件的作用。说做就做，how to publish your app?</p>

<!-- more -->


<h3>Proguard－代码混淆</h3>

<p>我们经常在js库中看到各种代码混淆，代码混淆主要是对你的代码的类名，方法名以及字段名进行命名，并删除一些无用的换行空格等。让你的代码变得难以读懂，这样能够防止别人反编译你的代码后窃取你的内容。<br/>
android中代码混淆主要使用IDE自动生成的文件，并通过一些简单的配置就可以实现。中间的混淆步骤则不需要我们关系，android编译过程中自身会处理这些内部的逻辑。我们只需要配置文件就可以。<br/>
通过官网提供的资料，<a href="http://developer.android.com/tools/help/proguard.html">http://developer.android.com/tools/help/proguard.html</a>，以及网上的大部分资料都是过时的，目前的AndroidStudio0.89中生成project时候只会生成proguard.cfg文件，要想启用proguard代码混淆，我们只需要在app的build.gradle中添加下述配置：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>android {
</span><span class='line'>    buildTypes {
</span><span class='line'>        release {
</span><span class='line'>            runProguard true
</span><span class='line'>            proguardFile getDefaultProguardFile('proguard-android.txt')
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>而这个proguard-android.txt则在<code>{sdk.dir}/tools/proguard/proguard-android.txt</code>中，这时proguard混淆时默认的文件，不过我们的sdk目录下却没有。Google君终于帮我们找到了：<a href="https://android.googlesource.com/platform/sdk/+/master/files/proguard-android.txt">https://android.googlesource.com/platform/sdk/+/master/files/proguard-android.txt</a>。于是简单粗暴的在tools/目录下新建proguard/proguard-android.txt文件。这时候android就可以使用默认文件进行混淆啦。</p>

<h3>Signing your application</h3>

<p>Android需要所有的应用在安装之前被数字签名，Android通过签名凭证识别应用的作者信息等。在App的Debug模式活着Release模式中都可以进行应用签名，在调试模式中一般是android自动生成凭证给App签名，而在Release发布模式中则需要开发者自己生成凭证来给用户签名。<br/>
我们主要关注在Release中怎么给自己的应用签名，签名之后的应用才可以发布到各市场中，在Release时给App签名：</p>

<ol>
<li>Create a keystore. Keystore是一个包含一些private key的二进制文件，你必须把这个文件放在一个安全独立的地方。</li>
<li>Create a private key. Private key 代表App作者的信息，例如一个开发者或者公司。</li>
<li>Build a project. 编译你的工程，这时会生成一个未签名的APP。</li>
<li>Sign your app. 用你的private key来生成你签名版本的APK。</li>
</ol>


<p>这样的APK就能够发布到市场中供用户更新下载。</p>

<p>签名既可以通过IDE直接操作，也可以通过android提供的工具在命令行中进行签名。在IDE中能够简单的生成一个keystore（需要说明的是不同的IDE生成的keystore文件格式是不一样的，主要有.jks, .keystore, 无后缀）。这些keystore在首次创建后下次就可以直接使用了。keystore包含的是一些软件作者的一些信息，也是你更新软件等的重要凭据。通过IDE签名的APK文件都经过了<code>jarsigner, zipalign</code>等操作，所以我们也不需要做额外的事情。<br/>
如果通过命令行来进行签名，这样的好处是使用命令来自动部署，开发者可以把所有的步骤写在一个shell文件中，部署时只要简单的run这个命令就可以实现了，如果需要编译很多个针对不同市场的版本，通过命令的模式就能够大大节约发布APP的时间。</p>

<p>更多详细信息请参考<a href="http://developer.android.com/tools/publishing/app-signing.html">http://developer.android.com/tools/publishing/app-signing.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android SIP 网络通话]]></title>
    <link href="http://www.gongmingqm10.net/blog/2014/10/17/android-sip-wang-luo-tong-hua/"/>
    <updated>2014-10-17T09:49:35+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2014/10/17/android-sip-wang-luo-tong-hua</id>
    <content type="html"><![CDATA[<p>突发奇想，想研究一下Android的网络通话怎么实现，于是从Google搜到了相关的资料。原来Android下集成了SIP（Session Initiation Protocol）。SIP的账号可以通过SIP提供商免费申请，申请后即可以通过用户名实现网络通话。于是也找了网上的一些资料，写了个AndroidSIP的小demo，demo实现后大家可以实现互拨，目前界面很简单，但是通话的功能应该是可以实现的。请各位看官试用之。<br/>
整体效果看起来还是蛮酷的，这里我们申请了两个免费的账号，在设备上安装之后就可以进行Network Call了。</p>

<p>免费SIP账号申请：<a href="http://www.linphone.org/free-sip-service.html">http://www.linphone.org/free-sip-service.html</a></p>

<p>官方参考文档：<a href="http://developer.android.com/guide/topics/connectivity/sip.html">http://developer.android.com/guide/topics/connectivity/sip.html</a></p>

<p>项目代码下载：<a href="https://github.com/gongmingqm10/AndroidSIP">https://github.com/gongmingqm10/AndroidSIP</a></p>

<p>任何问题，欢迎大家fork，发pull/request。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git Daemon 建立本地Git服务器]]></title>
    <link href="http://www.gongmingqm10.net/blog/2014/10/14/git-daemon-jian-li-ben-di-gitfu-wu-qi/"/>
    <updated>2014-10-14T10:51:41+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2014/10/14/git-daemon-jian-li-ben-di-gitfu-wu-qi</id>
    <content type="html"><![CDATA[<p>平时项目中我们常遇到这样的需求，需要在自己电脑上clone台式机上的git代码，从而省略了向Github远程服务器上传代码的过程。免除了一些授权Access问题。幸好有Git Daemon神器：</p>

<p><strong>前提</strong></p>

<p>代码是通过Git托管的，如果使用SVN的话，多增加一个Git repo也是可以的。</p>

<p><strong>Step by Step</strong></p>

<ol>
<li><p>进入到自己工程所在的目录下，以Users/mingong/project/Sheldon为例：<code>cd  project/Sheldon</code></p></li>
<li><p>在Git项目根目录下开启Daemon服务器  <code>git daemon --base-path=. --export-all --reuseaddr --informative-errors  —verbose</code></p></li>
<li><p>使用ifconfig查看本机电脑内网IP地址：<code>ifconfig</code>，以我的电脑为例，查看到的IP地址为 <code>10.113.241.150</code></p></li>
</ol>


<!-- more -->


<ol>
<li><p><code>clone/pull</code>代码到另外一台电脑（两台电脑需在同一个内网下即可），为模拟需要，直接到我的Downloads目录下面模拟进行后续步骤。<br/>
首先我需要在Doanloads文件夹中<code>clone project: git clone git://10.113.241.150/sheldon</code> ，
ls可以看到我的Downloads中已经成功clone了sheldon工程，clone了工程的下一步就是pull, 当A电脑上的代码变动之后，我需要直接更新代码，首先进入sheldon根目录中：<code>git pull git://10.113.241.150/</code></p></li>
<li><p>增加push权限<br/>
在B电脑上clone代码后，B电脑上的伙伴修改完代码会需要将代码push回A电脑的工程中，
在第2步中开启的git daemon给可访问的客户端read权限，在需要开启write权限时，我们需要给git daemon增加 <code>—enable=receive-pack</code>，执行命令如下，  <br/>
<code>git daemon --base-path=. --export-all --enable=receive-pack --reuseaddr --informative-errors  —verbose</code><br/>
There is one quirk: client can’t push into your active git branch. Before pushing, user on the server should change the branch, if client wants to push to this branch.<br/>
客户端B不能直接提交master到当前活跃分支，所以可以在B新建一个分支，只要提交分支到A的repo中即可，由A决定是否进行分支merge.</p></li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git checkout -b sharing
</span><span class='line'># made some changes ...
</span><span class='line'>$ git commit -am "add sharing feature"
</span><span class='line'>$ git push -u origin sharing
</span><span class='line'>...
</span><span class='line'>* [new branch]      sharing -&gt; sharing
</span><span class='line'>...
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p><strong>在服务器端merge分支</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git checkout master
</span><span class='line'>$ git merge sharing
</span></code></pre></td></tr></table></div></figure>


<p>至此，push工作也就基本完成了。Git 还是很强大的。</p>

<p>参考网址： <a href="http://railsware.com/blog/2013/09/19/taming-the-git-daemon-to-quickly-share-git-repository/">taming-the-git-daemon-to-quickly-share-git-repository</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Quiz Questions]]></title>
    <link href="http://www.gongmingqm10.net/blog/2014/10/13/android-quiz-questions/"/>
    <updated>2014-10-13T17:19:22+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2014/10/13/android-quiz-questions</id>
    <content type="html"><![CDATA[<p>关于Android的几个常见的问题，记录如下，小问题看到本质也可以了解很多原理性的东西。</p>

<hr />

<p><strong>Q: Android中Activity的生命周期？</strong></p>

<p>A: onCreate() &ndash;> onStart() &ndash;> onResume() &ndash;> onPause() &ndash;> onStop() &ndash;>onDestroy().</p>

<!-- more -->


<hr />

<p><strong>Q：Activity的onCreate()等函数必须Override吗？如果没有onCreate()，Activity能否运行？</strong></p>

<p>A: 答案显然是Override不是必须的，没有onCreate()的Activity还是可以运行的，那么究竟会运行成什么样子呢。<br/>
实例中试一试，从MainActivity中打开没有Override任何Method的Activity，发现界面上会出现一个白底界面的Activity，说明我们的Activity最终还是运行了的。只不过界面上没有任何元素，因为我们没有指定contentView。</p>

<hr />

<p><strong>Q: onStop()等在生命周期中是否一定会被调用?</strong></p>

<p>A: onStart(), onResume(), onPause(), onStop()都可以不被调用。因为一旦在onCreate()中我们直接手动调用finish()，相当于告诉Activity结束，于是系统会直接调用onDestroy()来销毁当前的Activity。</p>

<hr />

<p><strong>Q: onCreate()中的参数savedInstanceState意义是什么，会在什么情况下用到？</strong></p>

<p>A：按照官方的解释：</p>

<blockquote><pre><code> * @param savedInstanceState If the activity is being re-initialized after
 *     previously being shut down then this Bundle contains the data it most
 *     recently supplied in {@link #onSaveInstanceState}.  &lt;b&gt;&lt;i&gt;Note: Otherwise it is null.&lt;/i&gt;&lt;/b&gt;
 *
</code></pre></blockquote>

<p>savedInstanceState表示当Activity在前一个关闭再度初始化的时候会保存的信息。举例来讲，在我们的APP运行时，如果系统内存不足，系统会把Activity栈中一些比较古老的Activity给终结掉，此时系统会调用<code>onSaveInstanceState()</code>方法，此方法默认保存此Intent的一些信息，当这个Activity再次被调用时，这些保存的信息会传递到onCreate的savedInstanceState中。我们如果需要自定义的保存某些很重要的信息，可以复写<code>onSaveInstanceState()</code>方法把某些重要信息放到bundle中，也可以把那些信息写到本地文件中或者数据库中进行保存。方便下次进入时能够获取到。</p>

<hr />

<p><strong>Q: Activity与Fragment的区别</strong></p>

<p>A: Activity相信大家都不陌生，其实可以简单的看着一个页面，跳转到另外一个页面一般就进入新的Activity。那么Android从API11开始使用Fragment的原因呢？其实主要是为了适配Android的多屏（特别是手机与平板）问题。一般情况下，如果按照普通的设计思路，我们会同时维护两份代码，并且UI上会有比较大的区别。对于快速升级的互联网产品而言，简直就是一个灾难。这时Google想了一个好的办法，在代码中引入Fragment，Fragment相当于一个module，我们所有的UI可以以模块的形式放到Fragment中。这时候的Fragment能够被多个Activity复用，我们的Activity此时做的事情就是组装这些Fragment。在平板中，我可以在ActivityA中放入FragmentA和FragmentB；在手机中，我则会在ActivityA中放入FragmentA，而在ActivityB中放入FragmentB。所以平板和手机的适配问题变成了简单的组装。从而我们的View不需要进行各种大的变动。这能够为开发者节省很多时间。<br/>
具体参考：<a href="http://developer.android.com/guide/components/fragments.html">Android Fragment Component</a></p>

<hr />

<p><strong>Q: UI线程你知道多少？</strong></p>

<p>A：UI线程就是我们常说的主线程，UI线程负责着与用户的交互操作，会处理用户的触摸滑动点击等事件，并把这些事件分发给相应的组件来处理。如果我们尝试在UI线程中进行一个耗时的操作，那么我们的APP会出现ANR（Application not responsing）异常。在UI线程中直接进行耗时操作就会造成主线程阻塞，阻塞到达一定时间则会产生ANR。<br/>
为了防止这种UI错误，我们进行的处理是将耗时操作放到另外一个线程中处理，耗时操作完成后，我们不能在非UI线程中进行UI的操作，这样是不安全的。因为我们可以借助Handler把更新的消息发给主线程，然后在主线程中更新UI操作。下面是几种耗时操作后更新UI线程的方法：</p>

<ul>
<li>View.post(Runnable runnable)</li>
<li>Activity.runOnUiThread(Runnable runnable)</li>
<li>AsyncTask</li>
<li>Hanlder + Thread</li>
</ul>


<p>事实上前面三种都是使用java封装好的其他线程中操作UI线程的方法，这些方法都是为了方便开发人员而进行的一些处理。具体用法，大家可以Google之。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Deploy App to Remote Server —— 网站部署篇]]></title>
    <link href="http://www.gongmingqm10.net/blog/2014/10/12/deploy-app-to-remote-server/"/>
    <updated>2014-10-12T11:14:37+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2014/10/12/deploy-app-to-remote-server</id>
    <content type="html"><![CDATA[<p>网站开发完毕之后，下一步的任务就是部署了。我们从最简单的入手，如何将本地开发的webapp部署到远程服务器上（这里我们用的是阿里的ECS）。部署是一件很有意思的事情，因为我们可以让本地开发的网站被外界所访问，所以还是很多成就感的。这里的工程采用的是Spring MVC 框架。</p>

<h3>1. Requirement</h3>

<ul>
<li>一个能够在本地运行的Web程序</li>
<li>一个远程服务器主机</li>
<li>Mac或者Linux系统的机器</li>
</ul>


<!-- more -->


<h3>2. 打包Webapp为war文件</h3>

<p>不同的工程可以使用不同的工具进行打包，我们项目工程采用gradle + jetty构建的，因此在打包时还是使用gradle自带的方式进行打包。本项目build.gradle配置如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>apply plugin: 'idea'
</span><span class='line'>apply plugin: 'war'
</span><span class='line'>apply plugin: 'jetty'
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>tasks.withType(Compile) {
</span><span class='line'>    options.encoding = "UTF-8"
</span><span class='line'>}
</span><span class='line'>repositories {
</span><span class='line'>    mavenCentral()
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>dependencies {
</span><span class='line'>    providedCompile 'javax.servlet:servlet-api:2.5'
</span><span class='line'>
</span><span class='line'>    def springFrameworkVersion = '3.2.2.RELEASE'
</span><span class='line'>
</span><span class='line'>    compile "org.springframework:spring-web:${springFrameworkVersion}",
</span><span class='line'>            "org.springframework:spring-webmvc:${springFrameworkVersion}",
</span><span class='line'>            "org.springframework:spring-beans:${springFrameworkVersion}",
</span><span class='line'>            "org.springframework:spring-context:${springFrameworkVersion}",
</span><span class='line'>            "org.springframework:spring-jdbc:${springFrameworkVersion}"
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    compile "aopalliance:aopalliance:1.0"
</span><span class='line'>    compile "org.codehaus.jackson:jackson-mapper-asl:1.9.+"
</span><span class='line'>    compile "org.mybatis:mybatis:3.2.3"
</span><span class='line'>    compile 'org.apache.commons:commons-lang3:3.1'
</span><span class='line'>    compile 'commons-fileupload:commons-fileupload:1.2.2'
</span><span class='line'>    compile 'commons-io:commons-io:1.3.2'
</span><span class='line'>
</span><span class='line'>    runtime "commons-pool:commons-pool:1.3",
</span><span class='line'>            "commons-dbcp:commons-dbcp:1.2.2",
</span><span class='line'>            "commons-collections:commons-collections:3.2",
</span><span class='line'>            'javax.servlet:jstl:1.2',
</span><span class='line'>            "org.slf4j:slf4j-log4j12:1.6.0",
</span><span class='line'>            "mysql:mysql-connector-java:5.1.5",
</span><span class='line'>            'log4j:log4j:1.2.16'
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>根目录下直接使用 <code>gradle war</code>就可以快速打包完成。打包完成后我们在 <code>build/libs/</code> 目录下可以看到工程的war包, demo.war</p>

<h3>3. 服务器上安装java7, mysql, tomcat7</h3>

<p>服务器中要安装的环境主要根据我们项目中所需的环境。安装好环境之后，我们的webapp才可能服务器中正常运行。java7和mysql我们前面已经介绍过，所有这些安装问题其实都可以google找到解答。下面主要介绍tomcat7的安装过程：  <br/>
首先通过<code>ssh root@121.40.97.118</code>连接到ECS上：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd /tmp  
</span><span class='line'>wget http://mirrors.hust.edu.cn/apache/tomcat/tomcat-7/v7.0.56/bin/apache-tomcat-7.0.56.tar.gz
</span><span class='line'>tar xzf apache-tomcat-7.0.56.tar.gz
</span><span class='line'>mv apache-tomcat-7.0.57 /usr/local/tomcat7
</span></code></pre></td></tr></table></div></figure>


<p>安装完成后，通过 <code>cd /usr/lcoal/tomcat7</code>进入到tomcat根目录下，<code>./bin/startup.sh</code>运行tomcat服务器，本机浏览器中访问 <code>121.40.97.118:8080</code>，如果成功出现tomcat的配置页面，则tomcat7安装完成。当然我们业可以通过 <code>/usr/local/tomcat7/conf/tomcat-users.xml</code>来配置tomcat的管理员角色，具体请参考apache tomcat 官网。</p>

<h3>4. 复制war文件到tomcat7/webapps目录中</h3>

<p>我们需要将第2步生成的demo.war复制到服务器的webapp目录中，直接在terminal中使用<code>scp</code>命令：<br/>
<code>scp demo.war root@121.40.97.118:/usr/local/tomcat7/webapps/demo.war</code>，复制过程完成后，文件开始存在于服务器的webapps文件夹下面，war包能够被tomcat自动解析。访问<code>121.40.97.118:8080/demo</code>，我们可以看到自己的app终于可以访问了。</p>

<h3>5. More</h3>

<p>到第4步，其实基本完成了部署过程。<br/>
我们自己访问时必须加上8080端口号看的也是略不爽。此时可以通过<code>/usr/local/tomcat7/conf/server.xml</code>对里面默认的8080端口进行修改，改为80端口。这次我们直接访问<code>121.40.97.118/demo</code>，发现可以访问成功了。  <br/>
再看看，我们地址后面还需要加上demo，看起来业有点不爽。我想让这台主机默认直接访问demo工程。通过观察webapps看到里面有个ROOT目录，先备份ROOT目录，然后把我们的demo.war改称ROOT.war再看看效果:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>mv ROOT root.backup  
</span><span class='line'>mv demo.war ROOT.war
</span></code></pre></td></tr></table></div></figure>


<p>再次访问<code>121.40.97.118</code>，这时候我们可以直接看到我们的web应用了。</p>

<p>如果你还嫌不够酷的话，可以增加一个域名来转到这个网站。我在自己的域名管理中增加了一个二级域名<code>demo.gongmingqm10.net</code>映射到<code>121.40.97.118</code>，再次访问<code>demo.gongmingqm10.net</code>，但是事情没有预料的那么好，显示网站没有备案，好吧。其实下一步我可以去备案了～～</p>

<hr />

<p>此博客主要用于自己学习的记录过程，小弟才疏学浅，如有纰漏的地方请各位看官多多指正，共同进步。</p>
]]></content>
  </entry>
  
</feed>
