<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[gongmingqm10]]></title>
  <link href="http://www.gongmingqm10.net/atom.xml" rel="self"/>
  <link href="http://www.gongmingqm10.net/"/>
  <updated>2016-04-20T21:24:01+08:00</updated>
  <id>http://www.gongmingqm10.net/</id>
  <author>
    <name><![CDATA[Gong Ming]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[张家界所见]]></title>
    <link href="http://www.gongmingqm10.net/blog/2016/04/03/zhangjiajie-travel-perception/"/>
    <updated>2016-04-03T13:12:43+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2016/04/03/zhangjiajie-travel-perception</id>
    <content type="html"><![CDATA[<p><img src="http://7xj9js.com1.z0.glb.clouddn.com/DSC00261.jpg" height="400" alt="张家界" /></p>

<p>计划了许久的旅行在四月份如期进行了，由于时间原因，这次的旅行并没有女生的参与。只是三个纯爷们的一次“放空”。上次的旅行还是14年大学毕业那会儿，掐指算来，两年一次的旅行似乎也并不过分。于是我们心安理得的去了。我们的主要游览地是张家界森林公园，返程特地路过湖南，体验下湖南的美食。</p>

<h2>旅行社的利益链</h2>

<p>我们每次都是想做计划的，但是对于张家界这种景点诸多的地方，我们刚开始的计划似乎不奏效了。所以三个人都是糊里糊涂的去了张家界。</p>

<p>对于旅行社，一开始我们甚至是拒绝的，所以我们一开始就没有在网站上提前报团，因为我们希望来一场轰轰烈烈的自由行。然而等我们到达张家界，走进汽车站的那一刻，我们注定要被旅行社牵着鼻子走。</p>

<!-- More -->


<h3>憨厚的司机</h3>

<p>张家界汽车站就在火车站旁边，这种设计还是相当体贴的。我们很轻松的找到了汽车站到张家界国家森林公园的班车。一路上，班车司机告诉我们千万不要跟着那些举着牌子的人走，如果需要可以找“官方旅行社”咨询形成住宿等。(⊙o⊙)哦，原来张家界还设有官方的指引，只是贴心。让我对张家界好感倍增。看着张家界这座城市觉得分外美丽。汽车开了约半个多小时，在一家看起来很正规的旅行社门口停车，憨厚的司机师傅让我们下车去旅行社咨询，会有人帮我们旅行建议等。我们感激的下车了。</p>

<h3>贴心的旅行社大姐</h3>

<p>看到我们走过来，负责接待的旅行社大姐面露喜色，给我们介绍起了张家界的种种名胜，关怀备至的询问我们各种情况。然后大姐贴心的给我们计划三日两晚的形成，安排住宿，托运行李。张家界看来民风淳朴。</p>

<p>“看你们长得像学生，给你们学生假吧！只要980，只要980&hellip;”，大姐说出这句话的时候，我们充满感激。庆幸原来可以冒充一次学生了。大姐给我们介绍了好多经典，什么森林氧吧，金鞭溪，索道&hellip; 关键还包乘车费用。我们竟然被打动了。</p>

<p>我们真想给这位大姐一个大大的赞，面对980元的巨款，虽然有过迟疑，但想着既然是官方的旅行社，应该很良心。这个钱花的值。所以我们最终还是刷卡了，并随便瞅了一眼合同书，就签字了。</p>

<h3>段子手导游</h3>

<p>一切准备完毕之后，贴心大姐给我们安排了专门的导游，杨导。简单寒暄后，我们就坐车出发了。第一站就来到了森林公园售票处。原来森林公园售票处在这里，这里停了许多汽车，看起来憨厚司机的汽车也停在这里。我们似乎明白了点啥。但是事已至此，不如继续。免得毁坏了游玩的心情。</p>

<p>导游看起来像是个爽快人，一路上（黄）段子不断。面对路过的女性一定评头论足一番，不时还打趣下我们。虽然我们自称是刚毕业的学生，导游丝毫不在意带坏祖国的花朵&hellip;BBBBBBBB&hellip; 导游一路上不曾间断。我们只好跟着偶尔赔笑一下，但是真想甩了导游&hellip;</p>

<h3>被忽视的旅行社合同</h3>

<p>我不得不说这个合同真是太厉害了。只可惜经验不足，没咋细看。合同最重要的几个部分：费用，包含部分，不包含部分。</p>

<p>费用：费用部分不用我细说，一般玩不出什么猫腻。明码标价，毕竟没有到强买强卖的地步。</p>

<p>包含部分：包含部分一般列举了具体内容。嗯，看起来我们景点挺多的，森林公园，金鞭溪，杨家界，袁家界，天子山，十里画廊。其实来过的人都知道，这些全部是张家界里面的景点。也就是一张250元左右的森林公园门票都可以搞定。当然包含部分里面还包括车票，但是其实景区内汽车票本来就是免费的。</p>

<p>不包含部分：索道，十里画廊的小火车。旅行社很机智的把这些可能花钱的地方都告诉你了，但是没来过的我们还真没有太察觉这些东西，只是听听而已。</p>

<p>住宿：我们三日两晚的旅游还包括住宿。恩，第一晚的住宿是普通民俗客栈；第二晚的住宿是普通宾馆。定义的还真是到位。有个这个定义后，导游可以随便把我们带到任何宾馆或客栈，因为我们的级别是“普通”。我们住了之后，感受真实非凡，刷新了对普通酒店的认识&hellip;</p>

<h3>钱都花哪了</h3>

<p>段子手导游看我们最后有点不太高兴，就帮我们算了笔明白账。980元 = 500元(住宿+门票) + 100元(旅行社赚取) + 300元(导游费) + 100元(司机回扣)。原来钱是这样被花掉了。我们多花200元买个经验，嗯，经验教训。</p>

<h2>其他</h2>

<ol>
<li>导游把你安排到某家旅馆，导游一般可以拿回扣的；（张家界导游的地位感觉非常的高。到酒店都是免费的好吃好喝供着，关系到客栈的客源）</li>
<li>导游把你安排在某餐厅吃法，导游可以拿到每人10元的回扣；（我们自己跑出去吃饭，导游除了不高兴还是不高兴，感谢导游不杀之恩）</li>
<li>旅游景点里面购物，导游也是可以拿回扣的；（据说我们每次购物，导游都可以拿到回扣）</li>
<li>即使旅行社合同上标注包车费，最好是定义为“包往返车费”；（好吧，最后一日的游玩导游拿这个来坑我们）</li>
<li>陌生的旅游景点，相信自己，不要相信任何人；（我承认世上也有好人，但是还是景区这种地方，大家都挤破头皮想挣钱，还是多自己思考下）</li>
<li>时间较短的旅行，尽量背包搞定。行李箱带过去大部分东西是用不上的；（拖个大箱子，比较累，实在要带，记得提前找好住宿，找好托运）</li>
<li>旅游景点的特产一般很贵，并且品质很差；（从张家界买回来的吃的特产果然是不能吃的）</li>
</ol>


<h2>结尾</h2>

<ul>
<li>张家界的美景还是很不错的；</li>
<li>文中的旅行社是张家界中旅国际旅行社；</li>
<li>出门旅行最好带个靠谱认路的人，不需要导游，比如长了经验的我；</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[App 本地化解决方案]]></title>
    <link href="http://www.gongmingqm10.net/blog/2016/03/19/app-localisation-solution/"/>
    <updated>2016-03-19T13:38:10+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2016/03/19/app-localisation-solution</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>“本地化” 这个词对大家而言并不陌生，文艺点的解释大概就是 “入乡随俗” 吧。当然我们这里的本地化主要指的软件产品的本地化。对于某个国外应用，如果需要投放到中国市场，需要注意哪些问题呢？本文主要从开发的视角来探讨应用本地化的问题。</p>

<!-- More -->


<h2>本地化</h2>

<p>本地化(Localisation)主要是提升软件对于不同地区不同环境的用户的用户体验问题。从语言角度来说，我们需要给 App 支持中文。但是翻译就是本地化的全部吗？</p>

<p>谈到体验问题，语言只是用户体验的一部分。为了提升用户体验，本地化除了语言翻译之外，还包括许多内容。本地化大体受语言、网络、文化等因素的影响。</p>

<p><strong>1.语言</strong></p>

<p>语言关系着用户能否使用你的App，是否理解App的核心价值。所以在移动开发中，开发人员能够轻易的创建出针对不同语言的字符串资源文件，App运行时会根据当前设备的语言设置加载对应的字符串资源。这是Android和iOS框架本身所支持的。所以语言是本地化最直接的一部分，也是最容易做的一部分。</p>

<p><strong>2.网络</strong></p>

<p>网络意味着连通性，决定着App中的各项服务能否正常使用。比如某跑步软件中，内嵌 Google 地图来记录用户的位置以及轨迹，当一个中国用户下载这个用户时并不能正常使用。因为应用没有考虑到中国用户对 Google 服务访问受限。网络问题在中国本地化中尤其突出，因为你需要时刻考虑&#8221;防火长城&#8221;对软件中各服务模块的影响。</p>

<p><strong>3.文化</strong></p>

<p>本地化方面文化的成分虽然不多，但是却是最值得挖掘的地方。以文本方向为例：Arabic文字是从右到左的方向，Android4.2版本开始全面支持Right to Left布局，iOS也在WWDC2015中宣布全面支持右到左的文字布局。除了文本方向之外，文化还包括用户行为偏好。比如美国用户可以喜欢用运动相机拍摄极限视频。但是中国用户却更喜欢用运动相机自拍，然后分享朋友圈。不同的用户习惯决定着产品差异化的定位。</p>

<p>有了上述对本地化的理解。那我们可以来比较一下 翻译、本地化、国际化的异同点。下面我们可以了解下主要区别：</p>

<p><img src="http://rack.2.mshcdn.com/media/ZgkyMDEyLzAyLzEzLzE3XzAyXzUyXzgzM19maWxlCnAJdGh1bWIJMTIwMHg5NjAwPg/00de5e48" alt="本地化比较" /></p>

<h2>实践与坑</h2>

<p>了解了本地化之后，那么在整个的项目实践中，我们有哪些需要注意的地方呢？</p>

<h3>翻译</h3>

<p>在本地化翻译过程中，我们一般需要先进行翻译相关文本。然后给客户验证反馈。翻译过程中需要提前确认，特别是对于法律性质的长文本翻译，可能还要和客户的法务部门打交道，敦促他们尽快完成翻译校对服务。当然，如果你自己没办法翻译一些服务条款等，可以把翻译服务委托给其他翻译机构。</p>

<p>翻译的沟通和确认可以直接使用 Google Excel 在线协作编辑，当然也可以使用 <a href="http://transfix.io/">Transfix</a> 平台协作翻译。</p>

<h3>代码管理</h3>

<p>对于本地化项目，我们一般推荐客户在同一份代码库上进行开发。这样对于后期发布新功能将很有帮助。如果一开始就采用两套不同的代码库来做本地化，那以后英文版上增加了新功能，再复制到现在的版本上，将增加很多不必要的工作量，并带来诸多不一致性。</p>

<p>当然如果你综合考虑之后，觉得中文版的App和英文版的App将有很大差异化，客户想直接做一个“具有中国特色的本地化”App，那就勇敢的重新开始吧。</p>

<p>在现实情况中，如果你能够给客户做中国的本地化，那么未来可能的业务也许是其他语言的本地化。这时候在代码管理的时候如果可以多考虑一点，也许可以带来新的商机。</p>

<h3>国内媒体分享</h3>

<p>国内媒体分享可以说是本地化中一个很重要的方面。美国的社交平台主要是 Facebook, Twitter, Pinterest, youtube 等，但是在中国这些分享平台将是 微信朋友圈，QQ 空间，新浪微博, youku等。</p>

<p>如果选择做国内媒体分享，需要确定是使用系统默认(Android系统默认的分享方式支持QQ, Wechat等； iOS不支持国内的渠道分享)分享组件，还是使用各社交平台的SDK进行集成。工作量是不一样的，所以要根据项目的进度安排进行合适的计划。</p>

<p>如果你已经决定要集成各大社交平台 SDK 进行分享，那么我们应该尽快提交审核，申请相关的key和 secret。因为我们要预防审核过程中的各种问题。</p>

<h3>网络-GFW</h3>

<p>网络可用性这个问题估计只有在做 APP 汉化的时候才会遇到。具体来说，中国市场Google服务(包括Google Map, Google Analytics, Google Cloud Messaging, Google Plus)等处于不可用(或者不稳定)状态。因此，除了App的文字资源需要汉化之外，App中使用的系列Google服务也应该更换为在国内可以使用的服务。</p>

<p>由于Google服务不可用的情况，很多国产Android手机将手机中的Google服务给移除掉了，所以国内的 App应用请慎用Google服务(组件)，毕竟网络是个很大的问题。</p>

<p>除了Google服务之外，对于其他的服务也需要考虑稳定性等。因为有些国外的服务虽然不是Google的，但是在国内也很难访问。</p>

<p>App中常见的服务：</p>

<ol>
<li>地图：Google Map不可用，国内可以替代为高德地图服务；</li>
<li>社会化分享/登录: Google plus登录，Facebook和Twitter分享；</li>
<li>App统计：Google Analytics不稳定；国内可以替换为Umeng或者Flurry；</li>
<li>消息推送：Google Cloud Messaging不稳定；国内可以用个推或 JPush；</li>
</ol>


<p>当我们在对应用做服务选择的时候，除了需要考虑网络易用性之外，也需要考虑所选框架的文档是否适合客户的后期维护。因为我们的项目一般结束之后，要让客户能够快速接手，如果选择一些文档不全后期支持很差的服务，那团队解散之后。客户将很难维护这份代码。</p>

<h3>应用分发</h3>

<p>应用开发完成之后，离发布还有一步。你需要将App分发到应用市场中，才能够真正让用户使用App。这里的应用分发指Android应用的分发。对于iOS的应用分发，按照官方流程走，应该不会出现太多意外。</p>

<p>Android 应用市场分发，在中国尤其繁琐。由于Google Play Store在国内的Android手机中基本不可用，从而给了其他应用商店很多机会，比如：腾讯应用宝、百度市场、豌豆荚、安卓市场、360市场以及小米市场等。</p>

<p>在我们给某客户分发应用的时候，发现Android应用市场一般会自动爬取Google Play上的应用，于是我们的英文版就被官方市场收录，当时我们提交开发完成的中文版应用的时候，我们被告知应用侵权无法上架。最后经过复杂的邮件沟通，版权证明，应用认领等来解决这些版权问题。而这种特定的应用审核问题是没有提前预知的。这种问题也使得整个上线时间推迟了半个月左右。</p>

<p>所以在应用分发之前，我们应该提前在应用上线之前进行试水。避免这种应用审核可能带来的风险。</p>

<h2>写在后面</h2>

<p>App本地化不再是字符串的本地化，包括影响软件可用性的服务的本地化。有效且全面的本地化才能够真正构建出一款易用“接地气”的App。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[再见 2015， 你好 2016]]></title>
    <link href="http://www.gongmingqm10.net/blog/2015/12/27/say-hi-to-2016/"/>
    <updated>2015-12-27T22:57:02+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2015/12/27/say-hi-to-2016</id>
    <content type="html"><![CDATA[<p>前天刚完成公司的 Annual Review，通过 Annual Review 也回顾了自己 2015 年工作中的所有事情。我并不是个擅长书写的人，于是我也很担心写着写着就跑题了。但是还是想总结一些过去的一年，当作回忆吧。</p>

<h2>工作</h2>

<p>2015年的工作上还是过得比较精彩的，至少比2014年精彩。2015年算做我在公司的第二个年头，但是在武汉这个年轻的集体里面，我们这一届俨然也成为了公司的“老人”。老人就应该有老人的作风，比如带新人，比如承担办公司的一些事情，比如逐渐在项目中承担重要角色，也比如深化自己的知识。</p>

<p>从工作上来看，今年前后经历了三四个项目，我在项目中的角色都是 Android 开发。难得我几年的 Android 开发经验终于还是没有荒废，似乎还真派上了点用场。不过真心的，和以前相比，虽然在 TW 并没有太多的 Mobile 项目机会，但是那些少量的机会如果抓住了，的确可以使人收获颇丰。以前比较偏使用，现在为了能够给别人讲清楚，只好去了解事情的本质。于是开始慢慢习惯通过源码、资料等接触事务的本质，并做相应的总结分享。</p>

<!-- More -->


<p>当然在我司，分享文化是极其重要的。明知道无法避免，只好坦然接受。于是今年竟然可以在办公室内部给大家做分享了，也可以走出公司，到 Open Party 上演讲话题。在项目组内部，我也尝试把自己作为利益相关者，将项目的交付当作自己的责任，于是开始关注风险，关注代码质量，关注团队的能力培养，关注新人的成长。带新人不是一件麻烦的事情，但是却是一件重要的事情。</p>

<h2>技术</h2>

<p>技术上似乎没有更多突破，比较开心的是在 Android 测试，持续集成上了解的更多了，也基本可以独当一面作为 Android 项目的 Tech Lead 来把控项目的整体架构设计了。除了技术本身之外，我也越来越喜欢开源带给我的成就感。这应该称作个人影响力吧。当然就我目前的水平而言，还很难积累出自己的粉丝。但是我已经努力在经营维护自己的博客啦。当然期间也尝试过在 Github 贡献一些代码库，但是并没有产生任何价值。</p>

<p>对于技术，还是应该扬长补短吧。对于擅长的部分，我还是会继续输出成为能力，对于欠缺的地方，则应该在自己还有精力的时候努力补拙。我庆幸自己能够在 TW 这样的环境中成长了两年，我也可以很自信的说 TDD，CI／CD，代码质量，重构等已经比较熟练。下一步就是继续向外界输出这些能力。武汉办公室的移动端开发人员太少，我也应该起到带头作用，和办公室一起成长。当然最开心的是，我也可以做简单的 iOS 开发了。虽然只是皮毛，但是 Swift 带给我的兴趣还是远胜于 ObjC 的。只是缺少 iOS 的项目锻炼，看来 2016 年是应该主动争取这些项目机会了。</p>

<h2>生活</h2>

<p>2015年的生活还是挺精彩的，在国外的几个月喜欢上了国外的天空，喜欢呼吸国外的空气。回来后，在武汉也是挺舒服的。毕竟都是熟悉的城市，和熟悉的人。喜欢上了这种平淡、慵懒、惬意。也很骄傲的成为了一名垂钓者。不过似乎垂钓的收成不加，不过对于我这个兴趣爱好太少的人来说，钓鱼还真是一件让我能够开心的事情。</p>

<p>当然 2015 年也帮朋友做过几个外包，但是似乎付出和收获并不成正比，所以以后接外包还是应该找靠谱的。要不然付出了时间又没有收获，还是非常可惜的。当然为什么做外包，其实还是为了钱，因为工资难以维持生计时，必然得想办法创造额外的收入。</p>

<p>2015 除了宅在家里做外包，也尝试参加了一些和编程相关的活动。比如 Open Party, Rails Girls, Hack Day 等。参加活动的好处是认识一批比自己牛叉的人，以及让牛叉的人知道有我这个人的存在。人脉关系的积累是个漫长的过程，不过好像多参加这些活动，多认识一些圈子内的人，以后即使要换工作也会容易很多。武汉没有北上广那样的创业氛围，但是今年自己的观察来看，确实有那么些创业公司。有很多也都是 huster，所以还是感觉相当佩服的。等哪天我不被生活所迫，我也想尝试去创业，去做自己的产品，因为我其实是个很不安分的人。</p>

<h2>展望</h2>

<p>2015即将结束，2016悄然来临。希望新的一年中，我能够在更大的项目中磨练，能够承担更大的角色吧。不过我知道，承担更大的角色意味着更多的不确定甚至是痛苦，但是不经历痛苦怎能在阵痛中成长呢。2015年下半年我在舒适区中待的太久了，所以希望2016年能够在压力区中待一段时间。压力往往能够催生出人更强大的意志。</p>

<p>Hello, 2015. I&rsquo;m coming!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android 转屏那些事儿]]></title>
    <link href="http://www.gongmingqm10.net/blog/2015/12/16/you-should-know-about-android-rotate/"/>
    <updated>2015-12-16T15:39:43+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2015/12/16/you-should-know-about-android-rotate</id>
    <content type="html"><![CDATA[<p>在 Android 开发或面试过程中，屏幕旋转是一个容易让人忽视的知识点。在我之前经历的项目中，App 通常是为竖屏状态设置的，所以通常我们会对每个页面都设置竖屏方向，这时候我们不需要考虑旋转屏问题。但是最近项目中，我们的 App 是为平板设计的，而横竖屏旋转是属于客户的一个需求，当然平板上横竖屏的确比较常用。所以就借此机会研究了下 Android 横竖屏问题。</p>

<p><img src="http://7xj9js.com1.z0.glb.clouddn.com/portrait_landscape.png" width="500" alt="Android 横竖屏" /></p>

<!-- More -->


<p>横竖屏之所以需要引起开发者的注意，是因为 App 在横竖屏切换的过程中，页面会重绘，那么页面上已有的数据（比如登录页面已经输入的用户名）如何保存成为了一个问题。按照官方的推荐，Activity本身的确有处理旋转屏事件的函数，但是当一个页面中需要保存的数据很多的时候（比如很多 EditText），还是手工处理，就显得有些繁琐了。下面我们将循序渐进地探索 Android 屏幕旋转之最佳实践。</p>

<h2>Activity 旋转中的保存与恢复</h2>

<p>在解决问题或者探索最佳实践的时候，我们可以从简单的问题入手，慢慢衍生至复杂的情形，最后再抽象出一些比较通用的解决方案。这一步我们单纯的探索一个 Activity（没有 Fragment）的数据保存与恢复。</p>

<h3>Activity 的生命周期</h3>

<p>Activity 从创建到呈现在用户面前到消亡，有着自己完整的生命周期：</p>

<p><img src="http://7xj9js.com1.z0.glb.clouddn.com/activity_lifecycle.png" width="500" alt="Activity 生命周期" /></p>

<p>旋转屏幕时，打印相关 Log 如下：</p>

<p><img src="http://7xj9js.com1.z0.glb.clouddn.com/activity_rotate_cycle.png" width="600" alt="Activity 旋转中的生命周期" /></p>

<p>从 Log 可以看到，在屏幕旋转时，原来的 Activity 调用了 onDestroy，随后重新实例化了一个 MainActivity。重新实例化的 MainActivity 也会经历 “onCreate &ndash;> onStart &ndash;> onResume” 的生命周期。</p>

<h3>Activity 中窗口保存与恢复</h3>

<p>为了进一步探索 Activity 在旋转屏过程中的数据保存及恢复的逻辑，我们构造了一个具有用户名和密码的登录界面。当用户在用户名中输入用户名时，这时候旋转屏幕，此时期望的操作应该是输入的用户名仍然能够保留：</p>

<p><img src="http://7xj9js.com1.z0.glb.clouddn.com/activity_login.png" width="400" alt="Activity Login 页面" /></p>

<p>在不添加任何额外代码的情况下，我们可以看到输入框中的数据在旋转屏后仍然能够保留，这些控件基本状态的值是如何被保留的呢？</p>

<p>Activity 中方法 <code>protected void onSaveInstanceState(Bundle outState) {...}</code> 主要做状态保存相关的处理，如果我们有需要特地保存的变量等，我们可以在 <code>onSaveInstanceState</code> 中保存，保存后的 bundle 以 outState Bundle 的格式保存。当 Activity 再次被初始化时，<code>onCreate(Bundle savedInstanceState)</code> 会将保存的 bundle 传递给 Activity 主页面，Activity 主页面接收到这些状态保存的数据后，能够根据保存中的控件的ID信息，状态数据等对页面进行自动的初始化。当我们转屏时，会主动触发 <code>onSaveInstanceState</code> 被调用。Log 打印如下：</p>

<p><img src="http://7xj9js.com1.z0.glb.clouddn.com/activity_onrestore_data.png" width="600" alt="Activity onSaveInstanceState &amp; onRestoreInstanceState" /></p>

<p>根据 Log 很明确看出在旋转屏之后，随着 onPause 的执行，<code>onSaveInstanceState</code> 也被执行。当 Activity 再次初始化时，<code>onCreate(Bundle savedInstanceState)</code> 会传递回一个非空的 savedInstanceState（而当 Activity 第一次初始化时此值为空），同时 <code>onRestoreInstanceState</code> 也会被调用，用来将保存的窗口状态信息重新应用：</p>

<p>生命周期：<code>onCreate</code> &ndash;> <code>onStart</code> &ndash;> <code>onResume</code> &ndash;> Running 转屏 &ndash;> <code>onPause</code> &ndash;> <code>onSaveInstanceState</code> &ndash;> <code>onStop</code> &ndash;> <code>onDestroy</code> &ndash;> <code>onCreate</code> &ndash;> <code>onStart</code> &ndash;> <code>onRestoreInstanceState</code> &ndash;> <code>onResume</code>;</p>

<p><img src="http://7xj9js.com1.z0.glb.clouddn.com/activity_savedInstanceState.png" width="600" alt="Android savedInstanceState" /></p>

<p>通过对 <code>savedInstanceState</code> 的查看，发现 savedInstanceState 中包含有 Key 为 <code>android:viewHierarchyState</code> 的 bundle 数据，此 bundle 数据具体内容如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Bundle[{android:views={
</span><span class='line'>      16908290=android.view.AbsSavedState$1@347440f8,         2131492927=android.view.AbsSavedState$1@347440f8,       2131492928=android.view.AbsSavedState$1@347440f8,       2131492929=android.support.v7.widget.Toolbar$SavedState@391b69d1,       2131492930=android.view.AbsSavedState$1@347440f8,       2131492944=TextView.SavedState{138fec36 start=8 end=8 text=gongming},       2131492945=TextView.SavedState{16043737 start=0 end=0 text=},       2131492946=android.view.AbsSavedState$1@347440f8
</span><span class='line'>  },
</span><span class='line'>  android:focusedViewId=2131492944}
</span><span class='line'>]</span></code></pre></td></tr></table></div></figure>


<p>可以看到 username 的输入框 EditText，其 ID 以及当前的值都已经保存至 savedInstanceState 中。</p>

<p>那么，对于 Activity.java 的而言，最重要的保存数据和恢复数据的源代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>private static final String WINDOW_HIERARCHY_TAG = "android:viewHierarchyState";
</span><span class='line'>
</span><span class='line'>protected void onSaveInstanceState(Bundle outState) {
</span><span class='line'>    outState.putBundle(WINDOW_HIERARCHY_TAG, mWindow.saveHierarchyState());
</span><span class='line'>    Parcelable p = mFragments.saveAllState();
</span><span class='line'>    if (p != null) {
</span><span class='line'>        outState.putParcelable(FRAGMENTS_TAG, p);
</span><span class='line'>    }
</span><span class='line'>    getApplication().dispatchActivitySaveInstanceState(this, outState);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>protected void onRestoreInstanceState(Bundle savedInstanceState) {
</span><span class='line'>    if (mWindow != null) {
</span><span class='line'>        Bundle windowState = savedInstanceState.getBundle(WINDOW_HIERARCHY_TAG);
</span><span class='line'>        if (windowState != null) {
</span><span class='line'>            mWindow.restoreHierarchyState(windowState);
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>这就是为什么我们没有做过多的处理却可以让 App 在旋转屏幕时仍然自动保存恢复输入框中的文字。</p>

<h3>Activity 中数据保存与恢复</h3>

<p>既然 Activity 本身对窗口（控件）的状态信息进行了保存及恢复处理。那么我们在屏幕切换时最应该关心的就是页面数据的保存与恢复。页面数据主要有两种：</p>

<ul>
<li>API 请求的数据：在横竖屏切换时对API数据进行保存及恢复能够防止 API 的重复调用；</li>
<li>页面中的状态值：在 Activity 运行过程中被改变的状态值，在恢复时需要手动保存及恢复，以便不影响状态值相关的页面逻辑；</li>
</ul>


<p>在 Activity 中进行变量的存储及读取时，使用 <code>onSaveInstanceState</code> 进行数据的存储，使用 <code>onRestoreInstanceState</code> 进行数据的读取：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>private boolean shouldSaveData = false;
</span><span class='line'>
</span><span class='line'>private static final String KEY_SHOULD_SAVE_DATA = "save_data_key";
</span><span class='line'>
</span><span class='line'>@Override
</span><span class='line'>protected void onSaveInstanceState(Bundle outState) {
</span><span class='line'>    outState.putBoolean(KEY_SHOULD_SAVE_DATA, shouldSaveData);
</span><span class='line'>    super.onSaveInstanceState(outState);
</span><span class='line'>
</span><span class='line'>    Log.i(TAG, "@@Activity onSaveInstanceState@@" + this.toString());
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@Override
</span><span class='line'>protected void onRestoreInstanceState(Bundle savedInstanceState) {
</span><span class='line'>    super.onRestoreInstanceState(savedInstanceState);
</span><span class='line'>    shouldSaveData = savedInstanceState.getBoolean(KEY_SHOULD_SAVE_DATA);
</span><span class='line'>    Log.i(TAG, "@@Activity onRestoreInstanceState@@" + this.toString());
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>Activity 中弹框的状态保存及恢复</h3>

<p>在 Activity 中经常会遇到 Dialog，甚至像下面具有输入框的 Dialog：</p>

<p><img src="http://7xj9js.com1.z0.glb.clouddn.com/activity_signature_dialog.png" width="400" alt="Android Dialog" /></p>

<p>当用户点击 Login 按钮，弹出弹框需要用户签名，这时如果屏幕不小心进行了一次旋转，那么这个弹出的 Dialog 便消失，随之消失的还有用户输入了一半的输入框文字。Activity 在旋转过程中对于 Dialog 自身的生命周期进行很好的管理，如果为了达到更好的用户体验，转屏时也需要保存输入框状态，那么此处我们强烈推荐用户使用 <a href="http://developer.android.com/reference/android/app/DialogFragment.html">DialogFragment</a> 代替 Dialog。</p>

<p>由于 Fragment 也具有生命周期，使用 DialogFragment 之后，我们结合 Activity 与 Fragment 的生命周期，查看整个过程经历了哪些流程。</p>

<p><img src="http://7xj9js.com1.z0.glb.clouddn.com/fragment_lifecycle.png" width="300" alt="Frgament 生命周期" /></p>

<p>结合 DialogFragment 在 Activity 中旋转的重新初始化及数据恢复，我们可以看到执行顺序如下：</p>

<p><img src="http://7xj9js.com1.z0.glb.clouddn.com/activity_fragment_rotate.png" width="500" alt="Android Fragment 执行顺序" /></p>

<p>在转屏时，Activity 和 Fragment 都会重新实例化，并且都通过 <code>onSaveInstanceState</code> 进行状态保存。值得注意的是不同于 Activity, Fragment 并没有 <code>onRestoreInstanceState</code> 方法，Fragment 的状态恢复在 <code>onActivityCreated</code> 方法中。查看 DialogFragment 源码，我们可以看到如下调用：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Override
</span><span class='line'>public void onActivityCreated(Bundle savedInstanceState) {
</span><span class='line'>    super.onActivityCreated(savedInstanceState);
</span><span class='line'>  ...
</span><span class='line'>    if (savedInstanceState != null) {
</span><span class='line'>        Bundle dialogState = savedInstanceState.getBundle(SAVED_DIALOG_STATE_TAG);
</span><span class='line'>        if (dialogState != null) {
</span><span class='line'>            mDialog.onRestoreInstanceState(dialogState);
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>...
</span><span class='line'>
</span><span class='line'>@Override
</span><span class='line'>public void onSaveInstanceState(Bundle outState) {
</span><span class='line'>    super.onSaveInstanceState(outState);
</span><span class='line'>    if (mDialog != null) {
</span><span class='line'>        Bundle dialogState = mDialog.onSaveInstanceState();
</span><span class='line'>        if (dialogState != null) {
</span><span class='line'>            outState.putBundle(SAVED_DIALOG_STATE_TAG, dialogState);
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>  ...
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>由于 DialogFragment 其实就是展示一个 Dialog，而 DialogFragment 对 Dialog 的状态保存及恢复使得 Dialog 的状态得以保存。</p>

<h2>Fragment 状态的保存及恢复</h2>

<p>有了上面对 DialogFragment 转屏时状态保存及恢复的研究，那么在一个普通的 Fragment(DialogFragment 是一种特殊的 Fragment) 中状态保存及恢复又是怎样的呢？</p>

<p>实际上通过 DialogFragment 我们可以知道保存状态值还是通过 <code>onSaveInstanceState</code> 方法，而 <code>onActivityCreated</code> 中则可以获取状态值。</p>

<p>在转屏时，我们会有很多特殊的考虑。所以如果你的 App 需要支持横竖屏切换，你可以留意如下几点：</p>

<h3>1. Dialog 转屏消失问题</h3>

<p>Dialog 转屏消失在现实中是一个很常见的情形，对应的解决方案就是利用 DialogFragment 来替代 Dialog。这样旋转屏幕时弹起的 Dialog 就不会消失。</p>

<h3>2. Fragment 保存组件信息的坑</h3>

<p>最近在项目中发现，有时候放置在 Fragment 中的 ListView 转屏后不能自动回到转屏之前的位置。后来发现导致原因是 Activity 的 Layout 在添加 Fragment 时候没有指定 id 或 tag。于是该 Fragment 在 Activity 重绘时不能被系统当作 “同一个” Fragment，所以旋转时控件的一些基本状态信息没办法恢复。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;?xml version="1.0" encoding="utf-8"?&gt;
</span><span class='line'>&lt;fragment xmlns:android="http://schemas.android.com/apk/res/android"
</span><span class='line'>    android:id="@+id/home_fragment"
</span><span class='line'>    android:layout_width="match_parent"
</span><span class='line'>    android:layout_height="match_parent" android:paddingLeft="@dimen/activity_horizontal_margin"
</span><span class='line'>    android:paddingRight="@dimen/activity_horizontal_margin"
</span><span class='line'>    android:paddingTop="@dimen/activity_vertical_margin"
</span><span class='line'>    android:paddingBottom="@dimen/activity_vertical_margin"
</span><span class='line'>    android:name="net.gongmingqm10.androidrotate.HomeFragment" /&gt;</span></code></pre></td></tr></table></div></figure>


<p>其中的 <code>android:id="@+id/home_fragment"</code> 是重点。一旦 Fragment 的状态保存出现问题，可先确认 Fragment 是不是设置了 id 或 tag。</p>

<h3>3. 使用 setRetainInstance</h3>

<p>关于 Fragment，我们发现 <code>setRetainInstance</code> 方法经常被用到，那么这个方法的作用是什么呢？我们看看官方的解释：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> * Control whether a fragment instance is retained across Activity
</span><span class='line'> * re-creation (such as from a configuration change).  This can only
</span><span class='line'> * be used with fragments not in the back stack.  If set, the fragment
</span><span class='line'> * lifecycle will be slightly different when an activity is recreated:
</span><span class='line'> * &lt;ul&gt;
</span><span class='line'> * &lt;li&gt; {@link #onDestroy()} will not be called (but {@link #onDetach()} still
</span><span class='line'> * will be, because the fragment is being detached from its current activity).
</span><span class='line'> * &lt;li&gt; {@link #onCreate(Bundle)} will not be called since the fragment
</span><span class='line'> * is not being re-created.
</span><span class='line'> * &lt;li&gt; {@link #onAttach(Activity)} and {@link #onActivityCreated(Bundle)} &lt;b&gt;will&lt;/b&gt;
</span><span class='line'> * still be called.
</span><span class='line'> * &lt;/ul&gt;
</span><span class='line'> */</span></code></pre></td></tr></table></div></figure>


<p>结合方法名以及方法的解释，可以知道一旦我们设置 <code>setRetainInstance(true)</code>，意味着在 Activity 重绘时，我们的 Fragment 不会被重复绘制，也就是它会被“保留”。为了验证其作用，我们发现在设置为 <code>true</code> 状态时，旋转屏幕，Fragment 依然是之前的 Fragment。而如果将它设置为默认的 false，那么旋转屏幕时 Fragment 会被销毁，然后重新创建出另外一个 fragment 实例。并且如官方所说，如果 Fragment 不重复创建，意味着 Fragment 的 <code>onCreate</code> 和 <code>onDestroy</code> 方法不会被重复调用。所以在旋转屏 Fragment 中，我们经常会设置 <code>setRetainInstance(true)</code>，这样旋转时 Fragment 不需要重新创建。</p>

<p>如果你的 App 恰好可以不做转屏，那么你可以很省事的在 Manifest 文件中添加标注，强制所有页面使用竖屏/横屏。如果你的页面不幸的需要支持横竖屏切换，那么你在预估工作量或者给客户报价时一定要考虑到。虽然加入转屏支持不会导致工作量翻倍，但是却有可能引起许多问题。尤其当页面有很多业务逻辑，有状态值的时候。所以我们在项目开发过程中，应该知道什么时候需要考虑状态保存，当状态保存出现问题时，应该怎么解决之。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android 新手成长计划]]></title>
    <link href="http://www.gongmingqm10.net/blog/2015/11/30/android-xin-shou-jiao-cheng/"/>
    <updated>2015-11-30T21:17:42+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2015/11/30/android-xin-shou-jiao-cheng</id>
    <content type="html"><![CDATA[<p><img src="http://www.webmastergrade.com/wp-content/uploads/2011/04/Android-VS-Apple.jpg" width="500" alt="Android starter" /></p>

<p>最近在公司里开始遇到了新人培养的问题，新人被 assign 到 Android 项目上，为了让他能够很快有所产出，于是我们得思考怎么样快速锻炼一个新人并让他对 Android 开发产生兴趣并持续做下去呢？当然也会有一时兴起的同事会想着学习 Android，Android 入门门槛不高，但是要想真正的熟练驾驭，确实是一件道阻且长的事情，需要付出额外的努力。</p>

<!-- more -->


<h2>兴趣驱动法则</h2>

<p>其实“兴趣”不只是在 Android 开发上体现的重要，兴趣在任何地方都是最重要的。之前接触过一些朋友，某次会突然告诉我想学习 Android，但是往往一个 Hello World 都可以将之难倒。这时候学习者明显缺少兴趣驱动。Android 开发好玩的一点是我们开发的应用都可以很简单的在手机上安装使用。所以你可以尽情尝试各种新奇的点子。</p>

<p>当然，兴趣并不是本文讨论的重点，我们假设真心想学习的人都是出于兴趣。</p>

<h2>循序渐进的练习计划</h2>

<p>有了兴趣远远还不够，兴趣只能促使你完成一个 Hello World，要想真正做出东西还应该有循序渐进的计划来配合。我当时学习 Android 的方法就是每周一个任务。把学习新知识当作升级打怪，这样子你还会松懈吗？</p>

<h3>你应该掌握的 Android 开发知识</h3>

<p>Android 开发的入门门槛不高，但是细节知识真心不少。作为初学者，我们可以先了解广度，然后了解深度。刚开始可以接触尝试了解一点远离性的知识，然后直接运用一些流行的框架。快速迭代完成一个 App。那么对于新手而言，应该掌握的 Android 开发知识有哪些呢？</p>

<h4>1. Hello Android</h4>

<p>开发调试基础看起来比较模糊，具体一点是完成一个 Hello World，让此应用运行在你的手机或者模拟器中。借此了解各个文件夹模块的作用以及 App 运行的基础原理。涵盖知识点如下：</p>

<ul>
<li>搭建 Android 开发环境： Java + Android Studio + SDK；</li>
<li>熟悉项目结构：src, res, assets, values, layouts, drawable/mipmap, styles, AndroidManifest.xml, Activity；</li>
<li>解读 Hello World 运行机制：项目从哪里运行，Activity 与 layout 的关联，Activity 中如何找到布局中的实例化控件，Activity 的生命周期；</li>
</ul>


<h4>2. 计算器</h4>

<p>计算器的经典程度不亚于 Hello World，Android 计算器能够让初学者迅速建立信心，同时作为一个单纯的无网络交互的应用，计算器主要处理布局，点击事件，计算逻辑。因此在了解了 Hello World 之后做计算器，再合适不过了。计算器最终效果图如下：</p>

<p><img src="http://7xj9js.com1.z0.glb.clouddn.com/calculator.png" width="300" alt="计算器" /></p>

<p>那么对于计算器这个 demo 的要求如下：</p>

<ul>
<li>界面效果如上图，并且能够进行简单的整数运算：<code>1+1, 4*2, 6/3, 1-10</code> 等；</li>
<li>异常处理，除数为 0 时界面提示 <code>Error</code>；</li>
<li>小数点以及连续运算的支持；</li>
<li>继承 Robolectric 添加单元测试；</li>
<li>每次打开 App 结果栏会自动显示上一次的运算结果；</li>
<li>添加<code>History</code>菜单，点击列表显示历史计算表达式以及结果；</li>
</ul>


<p>通过这些要求，涵盖的知识点如下：</p>

<ul>
<li>布局管理器的了解及使用：RelativeLayout, LinearLayout；</li>
<li>Android 控件添加点击事件，TextView 动态设值；</li>
<li>Android 项目集成 Robolectric，添加简单的单元测试；</li>
<li>Android 数据持久化保存 &ndash; SharedPreferences；</li>
<li>Android 数据持久化存储 &ndash; Sqlite 数据库；</li>
<li>Android ListView 列表及数据绑定；</li>
<li>Android Activity 跳转 &ndash; Intent；</li>
<li>添加 <a href="http://jakewharton.github.io/butterknife/">ButterKnife</a> 框架，重构项目；</li>
<li>添加 <a href="http://greenrobot.org/greendao/">GreenDao</a> 框架，重构数据库数据存储及读取；</li>
</ul>


<h4>3. 豆瓣图书列表 &ndash; 图片缓存</h4>

<p>豆瓣图书列表最初起源于公司内部的一次 Android 培训，由于对 Android 初学者而言，还比较有意义，于是设置为专题的形式供大家练习。需求很简单，将给定的图书列表数据(JSON 格式)显示到界面上。包括图书信息在列表中展示，网络图片的加载以及缓存。JSON 数据<a href="http://7xj9js.com1.z0.glb.clouddn.com/douban-books.json">点击此处</a>查看。完成之后效果图如下：</p>

<p><img src="http://7xj9js.com1.z0.glb.clouddn.com/douban-reading.png" width="300" alt="Douban Books" /></p>

<p>具体要求如下：</p>

<ul>
<li>列表显示图书信息：图书图片，名称，作者／出版社／出版年份，评价，简介；</li>
<li>多次滑动列表，保证文字以及图片显示不会发生错位，并且始终流畅（有列表控件重用）；</li>
<li>添加图片缓存：图片加载成功后，断开网络，退出 App，打开应用仍然能够正确显示图片；</li>
</ul>


<p>通过这些要求我们期望初学者掌握的技能点如下：</p>

<ul>
<li>Android ListView 自定义列表样式；</li>
<li>Android Adapter 使用 ViewHolder 进行控件复用；</li>
<li>Android 主线程（UI线程）的概念，主线程阻塞的解决方案，Handler 的概念以及使用方法；</li>
<li>图片缓存的应用，内存级别的缓存以及磁盘级别的缓存；</li>
<li>使用 <a href="http://square.github.io/picasso/">Picasso</a>/<a href="https://github.com/nostra13/Android-Universal-Image-Loader">ImageLoader</a> 图片加载及缓存框架，简化开发；</li>
</ul>


<p>如果你对图片缓存部分的实现有任何疑惑，请参考工程 <a href="https://github.com/gongmingqm10/AndroidWorkshop/tree/2nd-step4">AndroidWorkShop</a>。图片磁盘缓存部分参考了 Android 官方教程。</p>

<h4>4. 豆瓣图书列表 &ndash; 网络请求</h4>

<p>这个任务其实是对第 3 条任务的改造。不同之处在于，本次任务侧重于让初学者了解如何快速构建出一个有网络请求模块的 App。我们的效果图和上一条任务的相同，不同点在于本次我们会使用真实的网络API数据。并且会对 API 请求回来的数据进行缓存。具体要求如下：</p>

<ul>
<li>推荐使用 <a href="http://square.github.io/retrofit/">Retrofit</a> 框架，从豆瓣读书 API 网络获取<a href="https://api.douban.com/v2/book/search?q=Java">图书列表</a>及<a href="http://api.douban.com/v2/book/2130190">图书详情</a>。详情参见<a href="http://developers.douban.com/wiki/?title=guide">豆瓣API</a>；</li>
<li>列表显示豆瓣图书列表，图片显示可直接使用 Picasso；</li>
<li>点击 Item 跳转至图书详情界面，显示该书籍详细信息；</li>
<li>缓存此 API 的搜索结果 (文件或者数据库Key-Value的形式缓存JSON数据)；</li>
<li>使用 SwipeRefreshLayout 添加下拉刷新功能，下拉刷新时重新添加请求数据并更新缓存；</li>
</ul>


<p>此任务我们期望初学者掌握的知识点：</p>

<ul>
<li>Retrofit 框架的使用；</li>
<li>Android 数据缓存的简易实现方案（数据库／文件形式）；</li>
<li>简单的列表点击事件，页面跳转等；</li>
<li><a href="http://android-developers.blogspot.com/2015/05/android-design-support-library.html">Android Design Support Library</a> 中常用的组件及使用；</li>
</ul>


<h4>5. 设计并实现你自己的 App</h4>

<p>如果你顺利完成了上述四条任务，那么这一步你应该已经具备了完成一个简单的 App 的技能，这一步可以按照个人兴趣完成自己的创意点子。在开始编码之前，可以先制作出一套 UI 交互图，然后整理 API 并开始编码。</p>

<h3>Android 学习常用的链接</h3>

<p>Android 拥有全面的官方学习教程以及各种丰富的开源库。我们初学时可以多浏览官方教程学习一些好的实现，下面列举了一些很常用的链接：</p>

<ol>
<li><a href="developer.android.com/training/index.html">Android 官方文档</a></li>
<li><a href="http://android-developers.blogspot.com/">Android 官方博客</a></li>
<li><a href="www.google.com/design/spec/style/color.html#">Google Material Design</a></li>
<li><a href="http://square.github.io/">Square Open Source</a></li>
<li><a href="http://jakewharton.com/">Jake Wharton 的博客</a></li>
</ol>


<p>全文很多观点都是一家之言，更多的是结合自己的项目经验以及学习经验总结而成，如有谬误及不当之处，请读者不吝赐教。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Adapter notifyDataSetChanged Not Working]]></title>
    <link href="http://www.gongmingqm10.net/blog/2015/11/29/android-adapter-notifydatasetchanged-not-working/"/>
    <updated>2015-11-29T11:30:39+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2015/11/29/android-adapter-notifydatasetchanged-not-working</id>
    <content type="html"><![CDATA[<p>刚开发 Android 开发时，总是遇到一个看似很简单的问题 “Android Adapter notifyDataSetChanegd 不生效”，而每次解决这个问题的方法总是简单粗暴，直接了当。大概是以前的时候做事以结果导向，所以对于这些奇怪的问题也总是没有深究。刚好最近在项目中再次遇到了这个问题，决心深究一下。</p>

<p><img src="http://7xj9js.com1.z0.glb.clouddn.com/Its_not_working_anymore.png" width="500" alt="notifyDataSetChanged not working" /></p>

<!-- more -->


<h3>Adapter notifyDataSetChanged 做了什么事</h3>

<p>要弄清楚 <code>adapter.notifyDataSetChanged</code> 为什么不工作，还是应该首先弄清楚它究竟做了什么事情。根据函数名的描述，主要是通知 “数据源改变”，从而刷新页面，这样新改变的数据就呈现在用户面前了。</p>

<p>Android Adapter 使用了观察者模式，每一个 ListView 可以实例化出一个 Observer，而每个 Adapter 则会实例化出一个 Subject。在 ListView setAdapter 的时候，Adapter 会将 ListView 中实例化的 Observer 注册入观察者列表中。当 Adapter 通过观察者更新时，则会调用 Observer 的 notifyChanged() 方法，如此重新刷新 ListView 的界面。</p>

<p>这个通知者模式的 UML 关系图大致可以描述如下：</p>

<p><img src="http://7xj9js.com1.z0.glb.clouddn.com/adapter%20obervable%20pattern.png" width="500" alt="notifyDataSetChanged not working" /></p>

<p>继续查看 ListView.setAdapter 方法，可以看到在设置 Adapter 的时候，ListView 会将自己的 Observer 注册入 Subject:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Override
</span><span class='line'>public void setAdapter(ListAdapter adapter) {
</span><span class='line'>    if (mAdapter != null && mDataSetObserver != null) {
</span><span class='line'>        mAdapter.unregisterDataSetObserver(mDataSetObserver);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>  ...
</span><span class='line'>
</span><span class='line'>    super.setAdapter(adapter);
</span><span class='line'>
</span><span class='line'>    if (mAdapter != null) {
</span><span class='line'>      ...
</span><span class='line'>        mDataSetObserver = new AdapterDataSetObserver();
</span><span class='line'>        mAdapter.registerDataSetObserver(mDataSetObserver);
</span><span class='line'>
</span><span class='line'>      ...
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    ...
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<h3>为什么 notifyDataSetChanged 生效</h3>

<p>既然 <code>notifyDataSetChanged</code> 能够促使 ListView 重绘界面，那么让其生效的方式就是保证 Adapter 中的数据源生效，这样在 ListView 重绘时才能使用新的数据刷新界面。看下面一段失效的 ListView 更新失效的问题。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>    ListView itemList = (ListView) findViewById(android.R.id.list);
</span><span class='line'>    data = new ArrayList&lt;&gt;();
</span><span class='line'>    data.addAll(Arrays.asList("Item 1", "Item 2", "Item 3"));
</span><span class='line'>    adapter = new ItemListAdapter(data);
</span><span class='line'>    itemList.setAdapter(adapter);
</span><span class='line'>
</span><span class='line'>    findViewById(R.id.fab).setOnClickListener(new View.OnClickListener() {
</span><span class='line'>        @Override
</span><span class='line'>        public void onClick(View view) {
</span><span class='line'>            // 模拟请求 API 刷新重新获得数据
</span><span class='line'>            data = new ArrayList&lt;&gt;();
</span><span class='line'>            data.addAll(Arrays.asList("Item 1", "Item 2", "Item 3", "Item 4"));
</span><span class='line'>            adapter.notifyDataSetChanged();
</span><span class='line'>        }
</span><span class='line'>    });</span></code></pre></td></tr></table></div></figure>


<p>让我们分析失效的原因，首先将 ArrayList data 设置为 Adapter 的数据源，而 Java 是引用传值，所以在 onClick() 回调函数中，当我们对 data 重新赋值时，重新赋值后的 data 并不能和 Adapter 中的数据源产生关联。因此 Adapter 中的数据源还是 “Item 1”, “Item 2”, &ldquo;Item 3&#8221;。所以这里无论怎样调用 notifyDataSetChanged 都是不能生效的。</p>

<h3>如何让 notifyDataSetChanged 生效</h3>

<p>让更新生效的方式是，让你的 Adapter 保持最新数据源。就上述例子来看，当 data 更新新值时，我们可以通过 List.add() 来更新 Adapter 中引用对应的值。实现代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>        ListView itemList = (ListView) findViewById(android.R.id.list);
</span><span class='line'>        data = new ArrayList&lt;&gt;();
</span><span class='line'>        data.addAll(Arrays.asList("Item 1", "Item 2", "Item 3"));
</span><span class='line'>        adapter = new ItemListAdapter(data);
</span><span class='line'>        itemList.setAdapter(adapter);
</span><span class='line'>
</span><span class='line'>        findViewById(R.id.fab).setOnClickListener(new View.OnClickListener() {
</span><span class='line'>            @Override
</span><span class='line'>            public void onClick(View view) {
</span><span class='line'>                data.add("New Item " + view.toString());
</span><span class='line'>                adapter.notifyDataSetChanged();
</span><span class='line'>            }
</span><span class='line'>        });</span></code></pre></td></tr></table></div></figure>


<h3>End</h3>

<p>Android 中有很多优秀的设计，当我们出现问题时，可以通过阅读源码的方式探索，并结合 Google 的相关资料，了解事物的根源，方能设计出更优秀的代码。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OWASP Top 10 Training]]></title>
    <link href="http://www.gongmingqm10.net/blog/2015/11/17/owasp-top-10-training/"/>
    <updated>2015-11-17T12:04:05+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2015/11/17/owasp-top-10-training</id>
    <content type="html"><![CDATA[<h2>环境配置及安装</h2>

<p>我们使用 DVWA 工程来学习 OWASP TOP10 安全问题。本节的目的是搭建好这一个易受攻击的 PHP/Mysql 应用，以实例的方式学习这十大安全问题。</p>

<h3>启动 Vagrant 虚拟机</h3>

<p><em>如果你决定直接在本地电脑上安装 XAMPP，请自动忽略此步。</em></p>

<p>为了营造一个安全纯净无干扰的环境，我们选择 Vagrant 启动虚拟机，在虚拟机中安装 XAMPP 环境， Vagrantfile 配置如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>VAGRANTFILE_API_VERSION = "2"
</span><span class='line'>
</span><span class='line'>Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|
</span><span class='line'>  config.vm.box = "ubuntu/trusty64"
</span><span class='line'>  config.vm.network :private_network, ip: "192.168.33.10"
</span><span class='line'>end
</span></code></pre></td></tr></table></div></figure>


<p>从配置文件中，可以看出我们使用 ubunt 14.04 系统，并且给虚拟机设置了一个内网 IP， 意味着在主机中可以通过 IP 直接访问虚拟机中的网页。</p>

<p><code>Vagrant up</code> 启动该虚拟机，并通过 <code>Vagrant ssh</code> 登录虚拟机。</p>

<h3>安装 XAMPP</h3>

<p>XAMPP(Apache + MariaDB + PHP + Perl)，为了安装 DVWA Training 的实例，我们需要先安装相应的环境。</p>

<p>XAMPP 有针对 Linux/Windows/Mac的安装包，下载地址参考<a href="https://www.apachefriends.org/index.html">官方地址</a>. 由于本次试验的在 ubuntu/trusty 虚拟机中，因此使用命令行安装，大致安装过程如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>wget https://www.apachefriends.org/xampp-files/5.6.14/xampp-linux-x64-5.6.14-3-installer.run
</span><span class='line'>
</span><span class='line'>sudo chmod +x xampp-linux-x64-5.6.14-3-installer.run
</span><span class='line'>sudo ./xampp-linux-x64-5.6.14-3-installer.run
</span></code></pre></td></tr></table></div></figure>


<p><img src="http://7xj9js.com1.z0.glb.clouddn.com/xampp-snapshots.png" width="400" alt="XAMPP 首页" /></p>

<p>安装完成后，使用 <code>sudo /opt/lampp/lampp start</code> 打开 lmapp 服务，这时候你应该能够访问 <code>192.168.33.10/xampp</code>。<a href="http://ubuntuportal.com/2013/12/how-to-install-xampp-1-8-3-for-linux-in-ubuntu-desktop.html">详细请参考</a></p>

<h3>安装 DVWA</h3>

<p>如果你已经能够访问 xampp 默认的主页，那么你几乎快成功了。XAMPP 中提供了 Apache 服务器，那么我们只需要将 DVWA 的包放在相应的 Web 目录下面，DVWA 项目就能够运行了。</p>

<p>DVWA 官网：<a href="http://www.dvwa.co.uk/">http://www.dvwa.co.uk/</a>.</p>

<p>DVWA Github 地址：<a href="https://github.com/RandomStorm/DVWA">https://github.com/RandomStorm/DVWA</a>.</p>

<p>开始从命令行安装：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>wget https://github.com/RandomStorm/DVWA/archive/v1.9.tar.gz
</span><span class='line'>tar -xzvf v1.9.tar.gz
</span><span class='line'>mv DVWA-1.9 /opt/lampp/htdocs/DVWA
</span></code></pre></td></tr></table></div></figure>


<p>访问 <code>192.168.33.10/DVWA</code>，自动跳转到 setup 界面，这时我们只需要按照提示就可以完成对应的初始化操作。如果你没有预先设置数据库用户名和密码，那么你会看到不能连接到 Mysql 数据库，根据提示重新设置数据库用户名和密码以继续操作。</p>

<p><img src="http://7xj9js.com1.z0.glb.clouddn.com/DVWA%20Setup.png" width="400" alt="DVWA Setup" /></p>

<p>按照 <a href="https://github.com/RandomStorm/DVWA">DVWA README</a> 中进行更改，试验过程中如果发现 <code>allow_url_include</code> 始终 Disable, 无法修改成功。请尝试在 <code>/opt/lampp/etc/php.ini</code> 中将原来的 <code>allow_url_include = Off</code> 修改为 <code>allow_url_include = on</code>。</p>

<p>将 PHP 相关的配置修改完成后，注意需要将 XMAPP 中 mysql root 用户默认的密码更改为<code>p@ssw0rd</code>，这个密码在 <code>/opt/lampp/htdocs/DVWA/config/config.inc.php</code> 中可以找到。当然也可以将此配置中的数据库密码更改为默认的空。</p>

<p>更改完成后，点击 <code>Create / Reset Database</code> 能够创建初始数据，随后访问 <code>192.168.33.10/DVWA</code> 即可跳转至登录界面。使用默认的 admin/password 可以登录此系统。登录成功之后，意味着我们可以通过实例学习 OWASP TOP10 的安全问题啦。</p>

<p><img src="http://7xj9js.com1.z0.glb.clouddn.com/DVWA%20Index.png" width="400" alt="DVWA index" /></p>

<h2>DVWA Practice</h2>

<p>DVWA 安装成功之后，我们开始学习相关的安全问题。DVWA 所培训的例子和 OWASP Top 10 安全问题并不完全一致，但是我们可以先学习 DVWA 上列举的安全问题，然后再逐步学习 Top 10 安全问题。</p>

<h3>Brute Force</h3>

<p>密码暴力破解，根据理解就是根据一个用户名密码字典进行试错。</p>

<p>通过以下链接找到适合你的 Brute Force 的工具：<a href="http://resources.infosecinstitute.com/10-popular-password-cracking-tools/?dl=true">http://resources.infosecinstitute.com/10-popular-password-cracking-tools/?dl=true</a></p>

<p>在 Mac 下面我使用 <a href="https://github.com/zaproxy/zaproxy/wiki/Downloads?tm=2">ZAP</a> 进行暴力破解。ZAP 有适用于 Mac 版本的安装包。</p>

<p>几种不同的授权方式：</p>

<ul>
<li>基础验证: Basic Access Authentication;</li>
<li>摘要验证: Digest Access Authentication;</li>
<li>Https验证: HTTPS Client Authentication;</li>
<li>表单验证: Form Based Authentication;</li>
</ul>


<p><a href="http://java.boot.by/wcd-guide/ch05s03.html">http://java.boot.by/wcd-guide/ch05s03.html</a></p>

<p><a href="https://www.owasp.org/index.php/Testing_for_Brute_Force_">https://www.owasp.org/index.php/Testing_for_Brute_Force_</a>(OWASP-AT-004)</p>

<p>&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DevOps Session 2]]></title>
    <link href="http://www.gongmingqm10.net/blog/2015/09/16/devops-session-2/"/>
    <updated>2015-09-16T14:24:51+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2015/09/16/devops-session-2</id>
    <content type="html"><![CDATA[<p>本次课主要学习用户权限概念，为了保证系统的安全性，把所有用户赋予最高权限是极不安全的做法。特别是安装 Tomcat 和 Jenkins 时，使用 sudo 用户来安装很容易被黑客攻击。</p>

<h2>课前准备</h2>

<p>课前准备阶段，我们需要完成简单的作业：</p>

<ol>
<li>使用 tomcat 用户安装 tomcat7 服务器；</li>
<li>使用 jenkins 用户安装 jenkins，jenkins 可以放在tomcat7中运行；</li>
<li>从本机浏览器中访问 jenkins 主页；</li>
</ol>


<!-- more -->


<p><img src="http://7xj9js.com1.z0.glb.clouddn.com/tomcat.png" width="500" alt="Tomcat" /></p>

<h3>创建用户</h3>

<p>我们需要分别创建<code>jenkins</code>和<code>tomcat</code>用户。出于安全的考虑，这两个用户不应该有管理员权限。创建用户命令如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo adduser jenkins
</span><span class='line'>...
</span></code></pre></td></tr></table></div></figure>


<p>安装提示，进一步设置 jenkins 用户的密码，设置完成后，应该可以通过 <code>su jenkins</code> 切换到 jenkins 用户验证用户是否创建成功。</p>

<h3>安装 Java</h3>

<p>直接在主用户下面使用 <code>apt-get</code>安装 Java7，命令如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo apt-get update
</span><span class='line'>sudo apt-get install openjdk-7-jdk</span></code></pre></td></tr></table></div></figure>


<p>如果想了解更多，请查看文章：<a href="http://stackoverflow.com/questions/16263556/installing-java-7-on-ubuntu">Install Java7 on Ubuntu</a></p>

<h3>安装 Tomcat</h3>

<p>apt 可以直接安装 Tomcat，我们这里从源码安装 tomcat7。</p>

<p>首先需要从 <a href="https://tomcat.apache.org/download-70.cgi">Tomcat</a> 官网获得源码包下载地址：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>http://mirror.bit.edu.cn/apache/tomcat/tomcat-7/v7.0.64/bin/apache-tomcat-7.0.64.tar.gz</span></code></pre></td></tr></table></div></figure>


<p>下载后，我们需要解压 tomcat，然后将 tomcat7 放到 <code>/opt/</code>目录中。如果在 tomcat 用户下操作，发现对 opt 文件夹没有写权限。所以我们需要在 <code>/opt</code> 中添加 tomcat7 文件夹，该文件夹所有者为 <code>tomcat</code>。</p>

<h4>新建 /opt/tomcat7 目录</h4>

<p>登录具有 sudo 权限的用户 <code>ming</code>，<code>sudo mkdir tomcat7</code>，然后通过 <code>sudo chown tomcat tomcat7/</code> 将 tomcat 用户设置为 <code>/opt/tomcat7</code>目录的所有者。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>tomcat@ubuntu:/opt$ su ming
</span><span class='line'>Password:
</span><span class='line'>ming@ubuntu:/opt$ sudo mkdir tomcat7
</span><span class='line'>ming@ubuntu:/opt$ ls -l
</span><span class='line'>total 4
</span><span class='line'>drwxr-xr-x 2 root root 4096 Sep 16 15:51 tomcat7
</span><span class='line'>ming@ubuntu:/opt$ sudo chown tomcat tomcat7/
</span><span class='line'>ming@ubuntu:/opt$ ls -l
</span><span class='line'>total 4
</span><span class='line'>drwxr-xr-x 2 tomcat root 4096 Sep 16 15:51 tomcat7
</span><span class='line'>ming@ubuntu:/opt$
</span></code></pre></td></tr></table></div></figure>


<p>文件新建完成后，切换回 tomcat 用户，开始解压 tomcat7，然后移动 tomcat7 至 <code>/opt</code> 目录下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>tar xvzf apache-tomcat-7.0.64.tar.gz
</span><span class='line'>mv apache-tomcat-7.0.64/* /opt/tomcat7</span></code></pre></td></tr></table></div></figure>


<p>然后，启动 tomcat7</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/opt/tomcat7/bin/startup.sh
</span></code></pre></td></tr></table></div></figure>


<p>访问 <code>http://192.168.56.101:8080/</code> 如果成功访问到 Tomcat 主页面，则表示 Tomcat 安装成功。</p>

<h3>Jenkins 在 Tomcat 中运行</h3>

<p>如果 Tomcat 已经运行成功，并且我们成功下载 jenkins.war。</p>

<p><img src="http://7xj9js.com1.z0.glb.clouddn.com/jenkins.png" width="500" alt="Jenkins" /></p>

<h2>用户权限与控制</h2>

<p>Linux 有着完善的用户管理，不同的用户大致分为如下几组：</p>

<ul>
<li>文件拥有者</li>
<li>群组</li>
<li>其他人</li>
</ul>


<h4>passwd</h4>

<p>用来记录文件的基本属性</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cat /etc/passwd</span></code></pre></td></tr></table></div></figure>


<h3>将 jenkins 和 tomcat 用户添加到 DevOps 群组中</h3>

<p>首先新建群组，然后将用户添加到群组中。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ming@ubuntu:/$ sudo groupadd DevOps
</span><span class='line'>ming@ubuntu:/$ sudo usermod -G DevOps jenkins</span></code></pre></td></tr></table></div></figure>


<h3>查看群组下所有用户</h3>

<p>为了验证我们上述的用户添加组操作已经成功，需要查看群组下所有用户：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cat /etc/group</span></code></pre></td></tr></table></div></figure>


<h3>给 DevOps 设置管理员 ming</h3>

<p>使用 gpasswd 命令来设置：<code>sudo gpasswd －A ming DevOps</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ming@ubuntu:/$ sudo gpasswd --help
</span><span class='line'>Usage: gpasswd [option] GROUP
</span><span class='line'>
</span><span class='line'>Options:
</span><span class='line'>  -a, --add USER                add USER to GROUP
</span><span class='line'>  -d, --delete USER             remove USER from GROUP
</span><span class='line'>  -h, --help                    display this help message and exit
</span><span class='line'>  -Q, --root CHROOT_DIR         directory to chroot into
</span><span class='line'>  -r, --remove-password         remove the GROUP's password
</span><span class='line'>  -R, --restrict                restrict access to GROUP to its members
</span><span class='line'>  -M, --members USER,...        set the list of members of GROUP
</span><span class='line'>  -A, --administrators ADMIN,...
</span><span class='line'>                                set the list of administrators for GROUP
</span><span class='line'>Except for the -A and -M options, the options cannot be combined.</span></code></pre></td></tr></table></div></figure>


<h2>文件权限</h2>

<p>以下列目录为例，查看该目录下面所有文件/文件夹的权限：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ming@ubuntu:/$ ls -l
</span><span class='line'>total 80
</span><span class='line'>drwxr-xr-x   2 root root  4096 Sep 14 15:51 app
</span><span class='line'>drwxr-xr-x   2 root root  4096 Sep 16 15:31 bin
</span><span class='line'>drwxr-xr-x   3 root root  4096 Sep  7 17:30 boot
</span><span class='line'>drwxr-xr-x  18 root root  4160 Sep 16 13:46 dev
</span><span class='line'>drwxr-xr-x 107 root root  4096 Sep 16 19:43 etc
</span><span class='line'>drwxr-xr-x   6 root root  4096 Sep 16 19:29 home
</span><span class='line'>lrwxrwxrwx   1 root root    33 Sep  7 17:16 initrd.img -&gt; boot/initrd.img-3.19.0-15-generic
</span><span class='line'>drwxr-xr-x  21 root root  4096 Sep  7 17:26 lib
</span><span class='line'>drwxr-xr-x   2 root root  4096 Sep  7 17:16 lib64
</span><span class='line'>drwx------   2 root root 16384 Sep  7 17:16 lost+found
</span><span class='line'>drwxr-xr-x   3 root root  4096 Sep  7 17:16 media
</span><span class='line'>drwxr-xr-x   2 root root  4096 Apr 18 05:34 mnt
</span><span class='line'>drwxr-xr-x   3 root root  4096 Sep 16 15:51 opt
</span><span class='line'>dr-xr-xr-x 103 root root     0 Sep 16 13:46 proc
</span><span class='line'>drwx------   2 root root  4096 Sep  7 17:16 root</span></code></pre></td></tr></table></div></figure>


<p>r(可读, 2<sup>2</sup>) w (可写, 2<sup>1</sup>) x (可执行, 2<sup>0</sup>)</p>

<p>第一个参数表述文件类型：文件夹、文件、链接等。</p>

<p>rwx(Owner) rwx(Group) rwx(Others)</p>

<h3>改变文件属性</h3>

<p>使用 usermod 将用户 jenkins 主目录设置为 <code>/devops/jenkins</code>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo usermod -m -d /devops/jenkins jenkins</span></code></pre></td></tr></table></div></figure>


<p>更改 <code>devops/jenkins</code> 和 <code>/devops/tomcat</code> 文件可以被 jenkins 和 tomcat 用户互相读：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ming@ubuntu:/devops$ sudo chmod 740 jenkins
</span><span class='line'>ming@ubuntu:/devops$ ls -l
</span><span class='line'>total 8
</span><span class='line'>drwxr----- 2 jenkins jenkins 4096 Sep 16 20:11 jenkins
</span><span class='line'>drwxr-xr-x 5 tomcat  tomcat  4096 Sep 16 20:11 tomcat</span></code></pre></td></tr></table></div></figure>


<h2>参考</h2>

<p>如果你的 VirtualBox 虚拟机不能通过 SSH 登录，请参考 <a href="http://louisrli.github.io/blog/2012/08/30/virtualbox-ipv6-ssh/#.VflDXZ2qqkp">Enabling VirtualBox SSH on IPv6</a>.</p>

<p>Linux 命令大全之 passwd 命令：<a href="http://man.linuxde.net/passwd">http://man.linuxde.net/passwd</a></p>

<p>鸟哥的 Linux 账号管理与 ACL 权限设定：<a href="http://linux.vbird.org/linux_basic/0410accountmanager.php">http://linux.vbird.org/linux_basic/0410accountmanager.php</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DevOps Session 1]]></title>
    <link href="http://www.gongmingqm10.net/blog/2015/09/10/devops-session-1/"/>
    <updated>2015-09-10T22:09:55+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2015/09/10/devops-session-1</id>
    <content type="html"><![CDATA[<p>最近公司在组织DevOps培训，于是就有个这个系列的文章，作为培训笔记，作为以后参考。如果你还不知道DevOps概念，请参考<a href="https://zh.wikipedia.org/wiki/DevOps">Wikipedia</a>。</p>

<blockquote><p>DevOps（英文Development和Operations的组合）是一组过程、方法与系统的统称，用于促进开发（应用程序/软件工程）、技术运营和质量保障（QA）部门之间的沟通、协作与整合。</p></blockquote>

<h2>课前准备</h2>

<p>因为需要使用一台Linux机器来作为测试主机，我们使用VirtualBox安装<a href="http://releases.ubuntu.com/15.04/ubuntu-15.04-server-amd64.iso">Ubuntu Server</a>。安装完成之后，我们能够登录这台“服务器”。</p>

<!-- more -->


<h2>课堂内容</h2>

<h3>磁盘管理</h3>

<p>主要学习磁盘相关的基础命令，能够查看磁盘使用情况，挂载新的磁盘等操作。参考文章：<a href="http://os.51cto.com/art/201012/240726_all.htm">Linux磁盘管理三板斧的使用心得</a>。</p>

<h4>df 命令</h4>

<p><code>df -h</code> 显示磁盘使用情况</p>

<h4>fdisk 命令</h4>

<p><code>sudo fdisk -l</code> 列出已知的分区类型</p>

<p><code>sudo fdisk /dev/sda1</code> 对/dev/sda1进行磁盘分区</p>

<h4>mkfs 命令</h4>

<p>mkfs 命令用于在设备上（通常为磁盘）创建 Linux文件系统。mkfs 本身并不执行建立文件系统的工作，而是去调用相关的程序来执行。</p>

<p><code>sudo mkfs -t ext4 /dev/sda1</code> 将 /dev/sda1 分区格式化为 ext4 格式</p>

<h4>partprobe 命令</h4>

<p>使用 partprobe 可以不用重启系统配合 fdisk 工具创建新的分区。</p>

<h4>mount 命令</h4>

<p>mount 命令用于挂载文件系统</p>

<h3>常用目录操作</h3>

<h4>特殊目录</h4>

<ul>
<li><code>.</code> 当前目录</li>
<li><code>..</code>父级目录</li>
<li><code>~</code> 当前用户的home目录</li>
<li><code>-</code> 前一个工作目录</li>
<li><code>~account</code> account 用户的 home 目录</li>
<li><code>.filename</code> 隐藏文件</li>
</ul>


<h4>操作目录</h4>

<ul>
<li><code>cd</code> 进入某个目录</li>
<li><code>ls</code> 列出某个目录的文件信息</li>
<li><code>ls -l</code> 列表展现目录下所有文件信息，显示目录权限、创建者、时间、文件大小等</li>
<li><code>ls －al</code> 列表展现目录下所有文件（包含隐藏文件）信息，显示目录权限、创建者、时间、文件大小等</li>
<li><code>pwd</code> 显示当前目录</li>
<li><code>mkdir</code> 创建目录</li>
<li><code>rmdir</code> 删除空目录（如果需要删除非空目录，请使用 <code>rm -r</code>）</li>
</ul>


<h3>常用文件操作</h3>

<ul>
<li><code>cat</code> 显示文件所有内容</li>
<li><code>tac</code> 从最后一行开始显示</li>
<li><code>echo "hello world" &gt; log.txt</code> 向 log.txt 中写入内容 &ldquo;hello world&#8221;， 将覆盖原来的文件内容</li>
<li><code>echo "hello world 1" &gt;&gt; log.txt</code> 向 log.txt 中附加内容 &ldquo;hello world1&#8221;，添加的内容会在文件最后一行。如果文件不存在，则会被创建。</li>
<li><code>nl log.txt</code> 输入带行号的文件内容</li>
<li><code>head log.txt</code> 只看文件前几行内容</li>
<li><code>tail log.txt</code> 只看最后几行</li>
<li><code>od</code> 以二进制方式显示档案内容</li>
<li><code>cp</code> 复制</li>
<li><code>mv</code> 移动</li>
<li><code>rm</code> 删除</li>
</ul>


<h3>查找命令</h3>

<h4>find 命令</h4>

<p>find 命令主要用来查找文件。更多使用方法请 Google 之。</p>

<p><code>find . -name "mysql*" -type f</code> 查找以“mysql”开头的所有文件(不是文件夹)</p>

<h4>which 命令</h4>

<p>在 PATH 变量指定的目录中，搜索某个系统命令的位置。同时也可以验证某个命令是否存在。</p>

<p><code>which grep</code></p>

<h2>总结</h2>

<p>第一节课主要了解了 Linux 下面一些基础的命令使用方法。这些命令都是比较常用的，当然还是需要多实战，才能够更好的理解并运用TA。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android 应用的持续交付]]></title>
    <link href="http://www.gongmingqm10.net/blog/2015/06/29/android-testing-practice/"/>
    <updated>2015-06-29T11:40:16+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2015/06/29/android-testing-practice</id>
    <content type="html"><![CDATA[<p>当我们谈软件质量时，我们一般会谈到测试。测试作为保障软件质量的重要手段正在被开发者逐渐认知。谈到测试时，大部分人都知道Web测试，对于前端JS或者后台，大部分“靠谱”的创业公司也都会用测试来保证软件质量。可是对于起步相对较晚的移动端测试，用的人并不多。</p>

<p>在测试方面，Android早期即存在UIAtomator和Monkey之类的测试，但是用起来实在不方便。2013年，Google开源了针对An ndroid平台的移动测试框架 &ndash; Espresso。Espresso可以针对每个页面(Activity)进行测试。开发者可以根据ID获取到页面元素，然后进行点击、长按等操作。结合Junit和Mock等工具，使得移动端测试成为可能。移动端拥有了测试框架的辅助，借助CI平台，持续交付也成为可能。</p>

<!-- more -->


<h2>Android测试的类别</h2>

<p>从开发者角度来看，通常的Web平台测试可以分为单元测试、集成测试以及功能测试。移动应用主要用来显示数据，显示框输入数据，相应用户的点击、滑动等操作。所以Android应用的开发工作大部分集中在UI上。因此，App测试大致可分为UI单元测试和功能测试。</p>

<p>UI单元测试覆盖界面显示以及用户与界面的交互。功能测试则是确保功能的正确性。</p>

<p>为了更好的说明App中UI测试和功能测试如何进行的，以一个Story举例如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Story-101
</span><span class='line'>Summary: 登录模块，用户能够使用用户名和密码登录App。
</span><span class='line'>Acceptance criterions:
</span><span class='line'>
</span><span class='line'>Given 作为用户，我打开App进入首页；
</span><span class='line'>When 我点击“登录”按钮；
</span><span class='line'>Then 我跳转到登录页面；
</span><span class='line'>
</span><span class='line'>Given 作为用户，我在登录页面
</span><span class='line'>When 我只输入用户名
</span><span class='line'>Then 登录按钮处于Disable状态
</span><span class='line'>When 我输入密码
</span><span class='line'>Then 登录按钮可以点击，点击之后，调用API
</span><span class='line'>
</span><span class='line'>Given 作为用户，我在登录页面
</span><span class='line'>When 我输入正确的用户名和密码，并登录
</span><span class='line'>Then 页面跳转到首页
</span><span class='line'>
</span><span class='line'>Given 作为用户，我在登录页面
</span><span class='line'>When 我输入错误的用户名和密码，并登录
</span><span class='line'>Then 页面上方显示“用户名或密码错误”提示
</span><span class='line'>And 密码被清空，登录按钮重新Disable
</span></code></pre></td></tr></table></div></figure>


<h3>UI单元测试</h3>

<p>UI(User interaction)测试又指界面测试。界面是软件与用户交互的最直接的部分，通过UI测试核实用户和软件拥有正常的交互。</p>

<p>UI测试的功能点比较简单：比如点击按钮的行为，按钮是否应该被禁用，页面文字、颜色等信息，是否弹框，点击弹框按钮应该跳转到什么页面等。</p>

<p>在登录页面中，假设登录页面的名字为LoginActivity，这是需要写的UI测试如下：</p>

<p>1.Test login button is not available until username and password are filled</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>usernameEditText.setText("gongmingqm10")
</span><span class='line'>assertThat(loginButton.isDisabled()).isTrue()
</span><span class='line'>
</span><span class='line'>passwordEditText.setText("password")
</span><span class='line'>assertThat(loginButton.isDisabled()).isFalse()</span></code></pre></td></tr></table></div></figure>


<p>2.Test should invoke Api when login button is clicked</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>usernameEditText.setText("gongmingqm10")
</span><span class='line'>passwordEditText.setText("password")
</span><span class='line'>
</span><span class='line'>loginButton.performClick()
</span><span class='line'>
</span><span class='line'>verify(loginApi).login(eq("gongmingqm10"), eq("encryptedpassword")
</span></code></pre></td></tr></table></div></figure>


<p>3.Test should show error dialog when login failed</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>usernameEditText.setText("gongmingqm10")
</span><span class='line'>passwordEditText.setText("wrongpassword")
</span><span class='line'>activity.loginFailed()
</span><span class='line'>assertThat(passwordEditText.getText().toString()).isEqualTo("")
</span><span class='line'>assertThat(errorText).isVisibile()
</span><span class='line'>assertThat(errorText.getText().toString()).isEuqalTo("用户名或密码错误")
</span></code></pre></td></tr></table></div></figure>


<p>4.Test should navigate to home page when login succeed</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>usernameEditText.setText("gongmingqm10")
</span><span class='line'>passwordEditText.setText("correctpassword")
</span><span class='line'>activity.loginSuccess()
</span><span class='line'>String actualPageName = getNextStartedActivity().getComponentName()
</span><span class='line'>assertThat(actualPageName).isEqualTo(HomeActivity.class.getName())</span></code></pre></td></tr></table></div></figure>


<p>观察上述几个测试，我们可以看到对UI的测试粒度相对较小。主要测试用户输入，按钮点击，服务器返回结果之后，界面应该如何反应。UI测试通常也包括简单的单元测试，Android中需要进行单元测试的内容较少，所以对于一些工具类的单元测试通常和UI测试放在同一个模块中。(PS: 上述测试代码的写法和你选取的测试框架有关)</p>

<h3>功能测试</h3>

<p>功能测试主要把测试对象看作一个黑盒子，测试者并不关注具体的功能实现逻辑，只需要关注输入产生期望的输出即可。Android的功能测试和Web的功能测试类似。在真机或模拟器中运行App，模拟输入、点击等操作，识别界面上是否存在某些期望的文字或行为。</p>

<p>功能测试不需要关注细节，只需要关注功能，对登录Story的功能测试如下：</p>

<p>1.With valid username and password, user can successfully login and navigate to home screen</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>tap_when_element_exists "android.widget.EditText hint:'Username'"
</span><span class='line'>keyboard_enter_text 'gongmingqm10'
</span><span class='line'>tap_when_element_exists "android.widget.EditText hint:'Password'"
</span><span class='line'>keyboard_enter_text 'some_correct_password'
</span><span class='line'>@home_page.wait_for_page_to_load
</span><span class='line'>welcome_message = @home_page.get_welcome_message
</span><span class='line'>raise 'Navigate to home page failed' if welcome_message.empty?</span></code></pre></td></tr></table></div></figure>


<p>2.With wrong username and password, user will see an error text</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>tap_when_element_exists "android.widget.EditText hint:'Username'"
</span><span class='line'>keyboard_enter_text 'gongmingqm10'
</span><span class='line'>tap_when_element_exists "android.widget.EditText hint:'Password'"
</span><span class='line'>keyboard_enter_text 'wrong_password'
</span><span class='line'>query "android.widget.TextView id: 'error_box' text:'用户名或者密码错误'"</span></code></pre></td></tr></table></div></figure>


<h2>Android常用测试框架</h2>

<h3>针对UI测试</h3>

<p>一般项目上都会采用<a href="http://robolectric.org/">Robolectric</a>框架，Robolectric运行过程中不需要启动模拟器，因此执行过程很快。</p>

<p>除了Robolectric，Google官方推荐使用Espresso来做UI测试。Espresso既可以作UI测试，也可以做简单的功能测试。</p>

<h3>针对功能测试</h3>

<p>可以做功能测试的框架也很多，包括Robotium, uiautomator, Espresso, Appium 和 Calabash。对比其主要区别如下：</p>

<p>真实项目过程中功能测试框架使用较多的是Appium和Calabash。这两个框架的优点是能够同时支持Android和iOS，并且不需要注入到工程中(即只需要编译后生成的安装包)，配合响应的测试脚本即可完成测试。</p>

<h2>Android持续交付</h2>

<p>CD(Continuous Dilivery)强调能够随时给客户交付有价值的产品。在Web开发上，我们通常运用CI平台持续部署网站到各个环境中。从而实现整个产品的持续交付。在Android平台上也是类似，唯一不同点是Android每发布一个版本需要用户手动更新手机上的App。</p>

<p><strong>1. 集成你的测试框架</strong></p>

<p>假定我们已经选定其他的技术栈，这时只需要集成UI测试和功能测试即可。UI单元测试框架我们选择Robolectric，而功能测试框架选择Calabash。参考<a href="http://robolectric.org/">Robolectric</a>和<a href="https://github.com/calabash/calabash-android">Calabash for Android</a>官方文档，集成测试框架并编写第一个Dummy Test。</p>

<p><strong>2. 通过你的第一个Dummy Test</strong></p>

<p>CI(Continuous Integration)平台，选择Jenkins。因为Jenkins有各种丰富的插件支持。选择Jenkins平台之后，最后能够有一台带界面的Mac Mini(虽然Android可以配置无界面运行，但是配置相对麻烦并且运行太慢)。在Mac Mini上搭建CI环境，配置Android运行环境。此步的目的是你的Dummy Test能够在Jenkins上运行</p>

<p><strong>3. 自动上传你的应用</strong></p>

<p>我们希望每次Push之后生成的包能够被QA测试，Showcase时候能够被客户测试。所以我们需要持续的发布新生成的包。我接触到的通常有两种做法：</p>

<ul>
<li>使用Dropbox自动同步上传：这种方法是最省成本的。每次打包新版本的时候只需要给文件带上不同的版本号，方便辨识。包生成之后，只需要存放到本地的Dropbox共享文件夹中。Dropbox会为我们自动上传。手机端则可以直接访问Dropbox下载，安装。</li>
<li>使用<a href="http://hockeyapp.net/features/">HockeyApp</a>管理版本：HockeyApp需要收费，但是可以很方便的通过部署脚本自动上传新生成的包。手机端只需要安装HockeyApp客户端，即可选择更新。</li>
</ul>


<p>类似的工具还有很多，选择适合自己的才是最好的。</p>

<h2>结语</h2>

<p>移动端测试虽然发展时间不长，但是却不断在完善中。我们以前习惯用邮件或U盘发布新版供他人测试。我们以前习惯开发App时不写测试。那些时代应该过去了。运用Robolectric，我们可以很轻松的测试驱动开发Android App；运用Calabash或Appium，我们可以更好的控制App质量，保证App功能；运用Jenkins等CI平台，我们的App可以持续交付啦!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Material Design Your Android App]]></title>
    <link href="http://www.gongmingqm10.net/blog/2015/06/25/material-design-your-android-app/"/>
    <updated>2015-06-25T15:22:27+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2015/06/25/material-design-your-android-app</id>
    <content type="html"><![CDATA[<p>14年6月26日的Google I/O大会上，Google推出了一门全新的设计语言Material Design。Material Design在随后的一年里被逐渐应用到Android, Web等平台中。Material Design的推出意味着Google对移动端和网页端设计的整合。固然没有引起轩然大波，但是Material Design却让Android开发者看到了一点福音。</p>

<p>虽然Android系统广受诟病，越来越多的用户投奔苹果的iOS系统。然而这阻挡不了Android的不断改进。14年Google I/O, Google推出了Android的5.0版本，代号Lollipop。5.0版本在设计上采用全新的Material Design，虽然这次升级对ROM生产商来说是道“过不去的坎儿”，但是对开发者群体而言却是一次很不错的升级。因为开发者可以凭借有些的设计资源打造出更好看的App。</p>

<!-- more -->


<h2>关于Material Design</h2>

<blockquote><p>Material design is a comprehensive guide for visual, motion, and interaction design across platforms and devices.</p></blockquote>

<p>这是Google官方给的解释， Material Design 中文直译为 “物质的设计”。可以简单理解为画面中的所有元素都可以看作是真实的物质，物质存在于空间中，并且存在光、影、运动等特征。所以Material Design的众多原则都是基于Material这个概念而提出的。</p>

<h3>Material Design基本原则</h3>

<p>Material Design作为设计与交互的一部分，由设计师来阐述更为专业。以下只是抛砖引玉的介绍，也许身边的设计师朋友会更专业的见解。</p>

<h4>Material is the metaphor</h4>

<blockquote><p>A material metaphor is the unifying theory of a rationalized space and a system of motion</p></blockquote>

<p>举例来说，在Android Lollipop系统中，当用户点击操作时，界面会反馈出水纹般的涟漪向周边散去，作为对用户点击操作的直接反馈。Material的设计都是基于现实，并在现实世界的基础上予以创新的。创新之处表现在元素之间整理运动的和谐。即使是在现实世界进行创新，最重要的是要Material Design不会破坏物理世界的规则。</p>

<h4>Bold, graphic, intentional</h4>

<blockquote><p>The foundational elements of print-based design—typography, grids, space, scale, color, and use of imagery—guide visual treatments.</p></blockquote>

<p>设计中的基本元素网格，空间，比例，字体，颜色等的结合能够给用户带来更好的体验，从而产生更大的价值。Material Design给我们指定了一些常见的搭配组合，比如颜色的组合、App中不同部分字体大小，组件之间的边距等。</p>

<h4>Motion provides meaning</h4>

<blockquote><p>Motion respects and reinforces the user as the prime mover. Primary user actions are inflection points that initiate motion, transforming the whole design.</p></blockquote>

<p>动画通常是App中最常见的交互，在Material Design出来之前，大部分App是很少有动画的。因为动画从设计到最后被用户使用，需要动画的设计以及开发，有时还会受限于平台。Material Design在动画方面有所加强，官方推出了许多默认的动作，页面各个元素之间的相互运动等。期望通过元素的运动向用户传达更为核心的价值和功能。</p>

<h3>为什么我们需要Material Design</h3>

<p>设计主要是为了提升用户体验，辅助产品功能，起到锦上添花的效果。Google推出Material Design也许希望对所有的Google产品进行设计上的统一化。</p>

<p>从Android平台来看，以前的Google Apps很难说有什么风格，其他厂商开发的App也是风格各异。Google希望通过Lollipop对App统一风格，所以在5.0＋平台上的Gmail, Youtube, Calender等都进行了风格的统一化，借此引导更多的设计师和开发者开发出更“接地气”的App。</p>

<p>Material Design强调跨平台设计，如果你遵从Material Design，你会发现将无论是宽屏平板设备、还是手机，你会发现你的应用可以很智能的进行展示。这将极大减轻适配平板带来的工作量。是不是有点类似于Web上的响应式设计呢？</p>

<p>当然选择是自由的，如果你觉得你的App不需要Material Design，那么TA真的不需要。</p>

<h2>如何Material Design App</h2>

<p>据个人观察，目前国内市场上大部分的App没有Material Design的概念。原因不得而知。但是遵循Material Design的应用在国外却比较常见。比如我个人常用的雅虎天气。</p>

<p>那么如何空手开发Material Design 应用呢？假定读到这里的你是个开发人员：</p>

<h3>1.合适的SDK版本和相关兼容包</h3>

<p>build.gradle</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>apply plugin: 'com.android.application'
</span><span class='line'>
</span><span class='line'>android {
</span><span class='line'>    compileSdkVersion 22
</span><span class='line'>    buildToolsVersion "22.0.1"
</span><span class='line'>
</span><span class='line'>    defaultConfig {
</span><span class='line'>        applicationId "net.gongmingqm10.training"
</span><span class='line'>        minSdkVersion 16
</span><span class='line'>        targetSdkVersion 22
</span><span class='line'>        versionCode 1
</span><span class='line'>        versionName "1.0"
</span><span class='line'>    }
</span><span class='line'>      ...
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>dependencies {
</span><span class='line'>    compile fileTree(dir: 'libs', include: ['*.jar'])
</span><span class='line'>  //required
</span><span class='line'>    compile 'com.android.support:appcompat-v7:22.2.0'
</span><span class='line'>    //optional for RecyclerView
</span><span class='line'>    compile 'com.android.support:recyclerview-v7:22.2.0'
</span><span class='line'>    //optional for GridLayout
</span><span class='line'>    compile 'com.android.support:gridlayout-v7:22.2.0'
</span><span class='line'>    //optional for CardView
</span><span class='line'>    compile 'com.android.support:cardview-v7:22.2.0'
</span><span class='line'>    //optional for some useful libraries
</span><span class='line'>    compile 'com.android.support:design:22.2.0'
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<h3>2.使用 Material theme</h3>

<p>values-v21/styles.xml</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;?xml version="1.0" encoding="utf-8"?&gt;
</span><span class='line'>&lt;resources&gt;
</span><span class='line'>    &lt;style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar"&gt;
</span><span class='line'>        &lt;!-- Main theme colors --&gt;
</span><span class='line'>        &lt;!--   your app branding color for the app bar --&gt;
</span><span class='line'>        &lt;item name="colorPrimary"&gt;@color/color_primary&lt;/item&gt;
</span><span class='line'>        &lt;!--   darker variant for the status bar and contextual app bars --&gt;
</span><span class='line'>        &lt;item name="colorPrimaryDark"&gt;@color/color_primary_dark&lt;/item&gt;
</span><span class='line'>        &lt;!--   theme UI controls like checkboxes and text fields --&gt;
</span><span class='line'>        &lt;item name="colorAccent"&gt;@color/color_accent&lt;/item&gt;
</span><span class='line'>
</span><span class='line'>    &lt;/style&gt;
</span><span class='line'>&lt;/resources&gt;
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>values/styles.xml</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;resources&gt;
</span><span class='line'>
</span><span class='line'>    &lt;!-- Base application theme. --&gt;
</span><span class='line'>    &lt;style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar"&gt;
</span><span class='line'>        &lt;!-- Customize your theme here. --&gt;
</span><span class='line'>        &lt;item name="android:actionBarStyle"&gt;@style/MyActionBar&lt;/item&gt;
</span><span class='line'>        &lt;!-- Support library compatibility --&gt;
</span><span class='line'>
</span><span class='line'>        &lt;item name="actionBarStyle"&gt;@style/MyActionBar&lt;/item&gt;
</span><span class='line'>    &lt;/style&gt;
</span><span class='line'>
</span><span class='line'>    &lt;style name="AppTheme.NoActionBar"&gt;
</span><span class='line'>        &lt;item name="windowActionBar"&gt;false&lt;/item&gt;
</span><span class='line'>        &lt;item name="windowNoTitle"&gt;true&lt;/item&gt;
</span><span class='line'>    &lt;/style&gt;
</span><span class='line'>
</span><span class='line'>    &lt;!-- ActionBar styles --&gt;
</span><span class='line'>    &lt;style name="MyActionBar"
</span><span class='line'>        parent="@style/Widget.AppCompat.Light.ActionBar.Solid.Inverse"&gt;
</span><span class='line'>        &lt;item name="android:background"&gt;@color/color_primary&lt;/item&gt;
</span><span class='line'>        &lt;item name="android:titleTextStyle"&gt;@style/MyActionBarTitleText&lt;/item&gt;
</span><span class='line'>
</span><span class='line'>        &lt;!-- Support library compatibility --&gt;
</span><span class='line'>        &lt;item name="background"&gt;@color/color_primary&lt;/item&gt;
</span><span class='line'>        &lt;item name="titleTextStyle"&gt;@style/MyActionBarTitleText&lt;/item&gt;
</span><span class='line'>    &lt;/style&gt;
</span><span class='line'>
</span><span class='line'>    &lt;style name="MyActionBarTitleText" parent="TextAppearance.AppCompat.Widget.ActionBar.Title"&gt;
</span><span class='line'>        &lt;item name="android:textColor"&gt;@color/white&lt;/item&gt;
</span><span class='line'>    &lt;/style&gt;
</span><span class='line'>
</span><span class='line'>&lt;/resources&gt;
</span></code></pre></td></tr></table></div></figure>


<p>使用你定义的AppTheme</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;application
</span><span class='line'>    android:name=".TrainingApp"
</span><span class='line'>    android:allowBackup="true"
</span><span class='line'>    android:icon="@mipmap/ic_launcher"
</span><span class='line'>    android:label="@string/app_name"
</span><span class='line'>    android:theme="@style/AppTheme" &gt;
</span><span class='line'>  ...
</span><span class='line'>&lt;/application&gt;</span></code></pre></td></tr></table></div></figure>


<h3>3.使用专为Material Design打造的Android控件</h3>

<p>你可以参考<a href="http://developer.android.com/training/material/index.html">Google Training Material Design</a>获取更多的Material Design组件的使用方法。</p>

<h4>Lists and Cards</h4>

<h5>RecyclerView</h5>

<p>引入RecyclerView到工程中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>compile 'com.android.support:recyclerview-v7:22.2.0'</span></code></pre></td></tr></table></div></figure>


<p>RecyclerView控件是ListView的更高效更灵活的版本。可以看作是对ListView更好的封装：</p>

<ul>
<li>解决ListView多列显示的难题；</li>
<li>不用担心开发人员没有复用View，因为它会强迫你这样做；</li>
<li>更方便的动画支持，移除中间某一项时，可以设置后面几项动画移动;</li>
</ul>


<h5>CardView</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>compile 'com.android.support:cardview-v7:22.2.0'</span></code></pre></td></tr></table></div></figure>


<p>卡片式布局，你的界面就是有导航和卡片组成的。卡片能够设置圆角和阴影。</p>

<h4>Design support library</h4>

<p>使用Design support包含的空间，需要引入Design support库：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>compile 'com.android.support:design:22.2.0'</span></code></pre></td></tr></table></div></figure>


<p>Design support提供了一些很常见很实用的控件。</p>

<h5>Navigation View</h5>

<p>Material Design推荐使用DrawerLayout抽屉式布局显示导航，所以Android一直没有为底部导航推出相应的控件。按照Google最新的设计，所有的导航都会被设置为抽屉显示，点击左上角菜单可以抽屉式弹出菜单项。</p>

<p>NavigationView就是和DrawerLayout搭配使用的神器。使用NavigationView只需要提供icon和title就可以生成专业的侧边导航。</p>

<h5>Floating Action Button</h5>

<p>Material Design引入了z轴，这个控件可以轻松制作出有阴影的悬浮圆形按钮。</p>

<h5>Snackbar</h5>

<p>底部栏消息提示控件，显示显示不再只有Toast和AlertDialog，还有Snackbar。</p>

<h5>Tabs</h5>

<p>在TabLayout出来之前，开发者通常手写Tab控件，并且需要手动控制UI。并且设计出来的Tab效果很一般。Google在2014年的iosched工程中推出了<a href="https://github.com/google/iosched/blob/master/android/src/main/java/com/google/samples/apps/iosched/ui/widget/SlidingTabLayout.java">SlidingTabLayout</a>，这个组件后来也在众多项目中被开发者用到。但是开发者还是得添加额外的代码来控制UI。</p>

<p>TabLayout帮助开发者创建符合界面风格的Tab，并且简单易用。</p>

<h5>CoordinatorLayout &amp; Collapse Toolbar</h5>

<p>更加优美的导航，导航可以相应页面滚动，也产生相应的滚动效果。可以参考Android 5.0版本默认的联系人应用。</p>

<h2>结语</h2>

<p>目前 Material Design 在国内潜伏了一年，也没引起太大的市场反馈。互联网泡沫下，决策者的心思都花在了如何推广如何吸引第一批用户上了，难以负担App重新设计带来的时间成本，更不行因为重设计造成现有用户的流失。</p>

<p>当然，如果某一天所有的国内手机都可以升级为5.0系统，是不是会有许多软件开发者考虑对App做Material Design呢？Android系统深度定制化依然成为5.0难以在国产手机中推广的重要阻碍。</p>

<p>Material Design作为Android App设计风格的趋势，尝试在你的App中使用新的风格，也许可以给你的产品带来不一样的体验。</p>

<h2>Open Party PPT 下载地址</h2>

<p><a href="http://7xj9js.com1.z0.glb.clouddn.com/Android%20Material%20Design.pptx">Android Material Design PPT 下载</a></p>

<p><strong>参考</strong></p>

<p><a href="https://www.google.com/design/spec/material-design/introduction.html">Google Materil Design</a></p>

<p><a href="http://developer.android.com/training/material/index.html">Material Design for Developers</a></p>

<p><a href="http://android-developers.blogspot.sg/2015/05/android-design-support-library.html">Android Design Support Library</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Design - Difference Between Px Sp and Dp]]></title>
    <link href="http://www.gongmingqm10.net/blog/2015/05/09/android-design-difference-between-px/"/>
    <updated>2015-05-09T11:32:59+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2015/05/09/android-design-difference-between-px</id>
    <content type="html"><![CDATA[<p>Android自兴起以来，开发者不断增加，与此同时市场上参差不齐的设备也不断增加，随之而来的则是开发者需要适配众多机型而带来的困扰与抱怨。并且随着不同厂家定制化不同的ROM，Android设备的碎片化现象日益严重。这篇文章主要讲述如何设计中严格遵从设计图标准的Android页面。</p>

<h2>1. px, dp, sp区别</h2>

<h3>什么是px</h3>

<p>px就是我们通常所说的像素的单位，在css里面，我们用px比较多。px主要指用户在屏幕上看到的事物的实际大小单位。</p>

<h3>什么是dp</h3>

<p>在看手机或者电脑参数时，我们经常说到一个关键词，屏幕分辨率(resolution)，分辨率被表示成每一个方向上的像素数量，比如800x480分辨率</p>

<!-- more -->


<p><img src="http://www.gongmingqm10.net/images/retina_one_screen.jpg" title="Mac retina resolution" ></p>

<p>上图中，我们可以看到15寸的retina pro分辨率是2880x1800，而60寸的HDTV分辨率却只有1920x1080。可见如果60寸的HDTV也要达到Retina的显示效果，其分辨率大概至少为11520x7200。</p>

<p>既然已经有了分辨率的概念，那么我们就可以了解 dpi(dot per inch)的概念了。dpi本意是每英寸点的数量，但是也经常和ppi(pixel per inch)混用。指每英寸的像素数量，也被我们称为屏幕密度，dpi越大，图像从视觉上看起来越清晰。</p>

<p>Google官方对dp的解释如下：</p>

<blockquote><p>A virtual pixel unit that you should use when defining UI layout, to express layout dimensions or position in a density-independent way.
The density-independent pixel is equivalent to one physical pixel on a 160 dpi screen, which is the baseline density assumed by the system for a &ldquo;medium&rdquo; density screen. At runtime, the system transparently handles any scaling of the dp units, as necessary, based on the actual density of the screen in use. The conversion of dp units to screen pixels is simple: px = dp * (dpi / 160). For example, on a 240 dpi screen, 1 dp equals 1.5 physical pixels. You should always use dp units when defining your application&rsquo;s UI, to ensure proper display of your UI on screens with different densities.</p></blockquote>

<p>有了密度的概念，我们可以更好的理解dp(density independent pixel)了。dp是Android中用来定义UI布局中表达元素尺寸或位置的一个虚拟的像素单位，dp的存在是为了页面元素位置不受屏幕密度所影响。以设计师设计一个APP页面为例，设计师希望用户视觉上看起来如此，也就是设计师设计时通常以px作为基础单位。而在其他不同屏幕密度的设备中，也希望能够进行一定的伸缩，类似于维持一个相对一致的百分比。所以开发者通常需要以dp为单位，以适应不同密度的屏幕。</p>

<p>所以dp和px之间有一套换算标准：<code>px = dp * (dpi / 160)</code>。假设在dpi为320的屏幕上，1dp = 2px。</p>

<h3>什么是sp</h3>

<p>sp是Android中专业为字体而设置的单位。使用sp作为字体单位不仅能够使字体大小受屏幕密度影响，并且能够使字体受用户系统设置的影响。Android提供字体大小的设置选项。一旦使用sp作为字体，根据用户设置字体的不同，App中的字体大小也会显示不同。但是在正常字体设置下，1dp ＝ 1sp。</p>

<h2>2. 设计师视角</h2>

<p>Android的多屏适配存在这么多的尺寸，自然需要设计师和工程师之间找到沟通的桥梁，设计师如何规范设计才能够更加符合Android的设计标准呢。设计师与工程师对于页面的尺寸需要有一个共识性的标准，测试人员才可能进行更有效的测试，才不致于因为不同机型显示不同效果而引起不必要的工作量。</p>

<p>首先我们需要选择一个相对通用的屏幕尺寸，可以参考现有的一些主流机型的尺寸。为了便于计算，我们选择Nexus 4作为设计图的原版标准。那么所有的页面都是基于Nexus4而产生的。Nexus4尺寸如下:</p>

<p><code>主屏尺寸4.7，主屏分辨率：1280x768像素，屏幕像素密度320ppi。</code></p>

<p>一般来说，我们选择市场上最常见的机型来设计，这里我们为了计算方便，选择320ppi的机型，设计图中尺寸将是标准图中的2倍。假设在设计图中，页面内边距为32px, 按钮的高度为96px, icon大小为48x48。</p>

<p>通过<code>px＝dp*(dpi/160)</code>的标准，设计师给开发者标注图时可标注页边距为16dp，按钮高度为48dp，icon则分别出四套mdpi, hdpi, xhdpi, xxhdpi标准。</p>

<h2>3. 开发者视角</h2>

<h3>margin, padding, height, width</h3>

<p>从开发者角度来看，对于控件的尺寸，高度等，只需要按照转化后的dp设置即可。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>android:layout_padding="16dp"
</span><span class='line'>
</span><span class='line'>android:layout_height="48dp"
</span></code></pre></td></tr></table></div></figure>


<p>以dp为单位能够保证不同分辨率屏幕上显示不同大小的字体。并且能够保持相对大小，这样也更符合设计的初衷。</p>

<h3>图片资源</h3>

<p>对于png制作出来的图片，一般大小固定，没办法像尺寸一样自动的伸缩。所以Android会存在至少4个资源文件夹。当App运行过程中，系统能够根据当前设备的屏幕密度，自动选择使用哪种尺寸的图片资源。</p>

<table>
<thead>
<tr>
<th>ldpi </th>
<th> mdpi </th>
<th> hdpi </th>
<th> xhdpi </th>
<th> xxhdpi </th>
<th> xxxhdpi</th>
</tr>
</thead>
<tbody>
<tr>
<td>0.75 </td>
<td> 1  </td>
<td> 1.5 </td>
<td> 2 </td>
<td> 3 </td>
<td> 4</td>
</tr>
<tr>
<td>120 </td>
<td> 160 </td>
<td> 240 </td>
<td> 320 </td>
<td> 480 </td>
<td> 640</td>
</tr>
<tr>
<td>18x18 </td>
<td> 24x24 </td>
<td> 36x36 </td>
<td> 48x48 </td>
<td> 72x72 </td>
<td> 96x96</td>
</tr>
</tbody>
</table>


<h2>4. 更多</h2>

<p>附上Android主流机型：</p>

<p>Android：主流机型主要为 480x800, 480x854, 540x960, 720x1280, 800x1280 这五种。
（非主流机型还包括：240x320, 320x480, 640x960 这三种，其中两种都与 iPhone 一致。）
iOS: 主流机型主要为 320x480, 640x960, 640x1136, 1024x768, 2048x1536, 这五种。
WP：主流机型主要为 480x800，720x1280, 768x1280 这三种</p>

<p>Photoshop制图时，字体大小通常是pt这个单位。pt是长度单位， 1pt = 1/72英寸， px = pt * dpi/72。</p>

<p>另附上豆瓣关于这些单位更<a href="http://www.douban.com/note/155032221/">具体的阐释</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setup Jenkins for Android Integration Using Docker]]></title>
    <link href="http://www.gongmingqm10.net/blog/2015/03/12/setup-jenkins-for-android-integration-using-docker/"/>
    <updated>2015-03-12T10:46:59+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2015/03/12/setup-jenkins-for-android-integration-using-docker</id>
    <content type="html"><![CDATA[<h2>About Docker</h2>

<p>什么Docker，为什么我们要折腾Docker，而不是直接在服务器上安装运行appilication所需的各种环境呢？</p>

<p>这个问题的产生和为什么需要虚拟机的理由差不多，我需要让我的代码运行在一个干净的无干扰的机器上，这样能够保证代码测试运行环境的一致性，降低其他不可知因素对代码的影响。而Docker和VM虚拟机相比又有其特点，比如启动速度快，可以单独将Docker保存为镜像，上传后能够让别人使用。甚至可以直接将自己的code放在Docker中，直接将环境和代码一起交付给客户。客户只需要安装这个Docker，运行后就可以直接使用这个application了。</p>

<blockquote><p>Develop, Ship and Run Any Application, Anywhere</p></blockquote>

<!-- more -->


<p>Docker is a platform for developers and sysadmins to develop, ship, and run applications. Docker lets you quickly assemble applications from components and eliminates the friction that can come when shipping code. Docker lets you get your code tested and deployed into production as fast as possible.</p>

<h3>Provision</h3>

<p>我的目标在于构建一个可以运行Android的CI服务器。出于省钱的目的，我使用本地的Vagrant启动Ubuntu虚拟机来代替真正的服务器。大致思路是：</p>

<ol>
<li>启动Ubuntu虚拟机，在Ubuntu上安装Docker；</li>
<li>通过Docker安装Jenkins Docker官方镜像；</li>
<li>在这个实例Docker中配置Jenkins并安装Android运行环境；</li>
<li>在Jenkins上搭建Android CI，使得Android单元测试和集成测试能够顺利通过；</li>
<li>上传这个具有Android CI功能的Jenkins镜像；</li>
<li>本地启动B虚拟机，下载镜像，访问B虚拟机的地址，查看Android Jenkins；</li>
</ol>


<h3>1. 启动Ubuntu虚拟机并安装Docker Jenkins</h3>

<p>在安装Docker之前，首先得有一个Linux的机器能够进入，如果你已经有一台干净的Linux服务器，直接进入安装Docker步骤。</p>

<p>Vagrant安装之前，你应该在电脑上安装VirtualBox虚拟机。VirtualBox安装完成之后请参考 <a href="http://docs.vagrantup.com/v2/installation/index.html">Vagrant Installation Guide</a>。</p>

<p>Vagrant成功安装后，<code>vagrant init ubuntu/trusty64</code> 能够帮你快速安装一台Ubuntu14.04的虚拟机，第一次安装的时候会稍微慢点，因为Vagrant会帮你生成Vagrantfile文件，并下载镜像。</p>

<p>Vagrantfile生成之后不要立即启动，因为我们想通过localhost访问Vagrant，然后通过Vagrant访问其中的Docker。由于Jenkins默认会使用8080端口，所以如果Vagrant的8080端口可以转发到Docker Container中的Jenkins。localhost:8080能够转发到Vagrant Ubuntu的8080端口，然后Vagrant的8080端口继续转发到Docker的8080端口，于是可以通过<code>localhost:8080</code>访问Jenkins了。所以Vagrantfile部分配置如下，添加端口转发。因为我本机的8080端口被其他程序占用，所以我将本地的8088端口转发到虚拟机的8080端口：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  # Create a forwarded port mapping which allows access to a specific port
</span><span class='line'>  # within the machine from a port on the host machine. In the example below,
</span><span class='line'>  # accessing "localhost:8080" will access port 80 on the guest machine.
</span><span class='line'>  #config.vm.network :forwarded_port, guest: 80, host: 8080
</span><span class='line'>  config.vm.network :forwarded_port, guest: 8080, host: 8088</span></code></pre></td></tr></table></div></figure>


<p>如果你之前已经启动了vagrant up, 然后更改了Vagrantfile想让forward_port生效，需要先<code>vagrant suspend</code>暂停vagrant，然后使用<code>vagrant reload</code>重新加载Vagrantfile使配置生效。</p>

<p>Vagrant Ubuntu 初始化完成之后，还是在这个有Vagrantfile的文件夹下，<code>vagrant up</code>能够直接启动这台Ubuntu服务器。</p>

<p>顺利的话我们可以进入通过<code>vagrant ssh</code>进入Ubuntu，随后需要在这台干净的Ubuntu机器上<a href="http://docs.docker.com/installation/ubuntulinux/">安装Docker</a>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo apt-get update
</span><span class='line'>$ sudo apt-get install docker.io
</span><span class='line'>$ source /etc/bash_completion.d/docker.io
</span><span class='line'>
</span><span class='line'>// 上述方法安装的Docker版本为1.0.1，如果你想使用较高版本Docker1.3.3
</span><span class='line'>
</span><span class='line'>$ echo deb http://get.docker.com/ubuntu docker main &gt; /etc/apt/sources.list.d/docker.list
</span><span class='line'>$ apt-key adv --keyserver pgp.mit.edu --recv-keys 36A1D7869245C8950F966E92D8576A8BA88D21E9
</span><span class='line'>$ apt-get update
</span><span class='line'>$ apt-get install -y lxc-docker-1.3.3
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>Note: <code>vagrant destroy</code>会关闭并重新格式化ubuntu机器，如果你只是想简单的停止机器，请使用<code>vagrant suspend</code></p>

<p>Docker成功安装后，直接启动Jenkins官方镜像：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker run --name androidJenkins -p 8080:8080 -v /var/jenkins_home jenkins</span></code></pre></td></tr></table></div></figure>


<p>安装完成后，访问 <code>http://localhost:8088/</code>，如果可以看到Jenkins界面，说明Jenkins已经安装成功。</p>

<p>进入后发现没有登录或者注册入口，然后就看到了stackoverflow上的<a href="http://stackoverflow.com/questions/10825614/how-can-i-add-a-username-and-password-to-jenkins">解决方案</a>: 系统管理 &ndash; Configure Global Security &ndash; 启用安全 — Jenkins专有用户数据库，允许用户注册 &ndash; 任何用户可以做任何事情。注册常用用户名和邮箱，然后就可以直接登录Jenkins。</p>

<h3>2. Jenkins Docker中安装Android 运行环境</h3>

<p>既然我们的Jenkins已经搭建完成，这一步我们则需要基于Jenkins安装Android的运行环境，如何在Ubuntu系统中通过命令行安装Android运行环境呢，主要参考<a href="https://www.digitalocean.com/community/tutorials/how-to-build-android-apps-with-jenkins">这篇文章</a>。</p>

<p>安装Android运行环境主要的流程为：</p>

<ol>
<li>下载Android SDK安装包 并设置环境变量.</li>
<li>下载platform-tools, Android SDK API, Android Build Tools.</li>
</ol>


<p>我这里安装Android SDK API版本为21，Build Tools版本号为21.1.2。</p>

<p>为了使Jenkins Android 环境能够在下次使用，我们通过新建 Dockerfile 的方式基于Jenkins来创建一个新的镜像，具体步骤如下：</p>

<ol>
<li><a href="https://registry.hub.docker.com/">Docker Hub</a>注册账号，用于存放自己的Repository。</li>
<li>新建Dockerfile文件，并添加配置信息。</li>
<li>运行Dockerfile，此时会执行Dockerfile中所配置的一系列命令。</li>
<li>提交Dockerfile生成的jenkins-android镜像。</li>
</ol>


<h4>配置Dockerfile</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>FROM jenkins
</span><span class='line'>MAINTAINER Ming Gong, gongmingqm10@gmail.com
</span><span class='line'>USER root
</span><span class='line'>RUN apt-get update && apt-get -y install libstdc++6 lib32z1 lib32stdc++6 expect
</span><span class='line'>
</span><span class='line'>RUN wget --progress=dot:giga http://dl.google.com/android/android-sdk_r24.1.2-linux.tgz
</span><span class='line'>RUN mv android-sdk_r24.1.2-linux.tgz /opt/
</span><span class='line'>RUN cd /opt && tar xzvf ./android-sdk_r24.1.2-linux.tgz
</span><span class='line'>ENV ANDROID_HOME /opt/android-sdk-linux/
</span><span class='line'>ENV PATH $ANDROID_HOME/tools:$ANDROID_HOME/platform-tools:$PATH
</span><span class='line'>RUN echo $PATH
</span><span class='line'>RUN echo "y" | android update sdk -u --filter platform-tools,android-21
</span><span class='line'>RUN echo "y" | android update sdk -u --all --filter 5
</span><span class='line'>RUN chmod -R 755 $ANDROID_HOME
</span><span class='line'>
</span><span class='line'>RUN apt-get install -y git-core
</span><span class='line'>RUN android update sdk --no-ui
</span></code></pre></td></tr></table></div></figure>


<p>其中 <code>android update sdk -u --all --filter 5</code> 主要用来更新build-tools。在有android环境的机器上运行&#8217;android list sdk &mdash;all&#8217;可以查看所有的SDK信息，找到最新版本的build-tools，然后通过提供的最新版本号即可。</p>

<p>Dockerfile配置成功后，我们首先在Vagrant虚拟机里面，<code>mkdir /var/jenkins_home</code>，并给予所有权限 <code>chmod 777 /var/jenkins_home</code>。/var/jenkins_home 能够映射到Docker中的jenkins_home目录，方便我们直接备份jenkins数据。</p>

<h4>Build Dockerfile</h4>

<p>准备工作完成之后，build Dockerfile，首先切换到Dockerfile所在的当前目录下，</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>vagrant@ubuntu-14: sudo docker build -t gongmingqm10/jenkins-android:latest .
</span><span class='line'>
</span><span class='line'>...
</span><span class='line'>
</span><span class='line'>Successfully built 184c7dad595a
</span></code></pre></td></tr></table></div></figure>


<h4>Push Image</h4>

<p>最后输出的信息就是我们通过Dockerfile生成的新的镜像ID。构建完成之后我们需要commit并push这个镜像到docker hub的repository上。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>vagrant@ubuntu-14:~/test$ sudo docker images
</span><span class='line'>REPOSITORY                     TAG                   IMAGE ID            CREATED             VIRTUAL SIZE
</span><span class='line'>gongmingqm10/jenkins-android       latest                184c7dad595a        11 minutes ago      188.3 MB
</span></code></pre></td></tr></table></div></figure>


<p>通过 docker images能够看到最新的镜像已经生成，这一步我们需要首先启动这个镜像，然后得到container ID，然后再PUSH 这个container。</p>

<p>首先启动镜像：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>vagrant@ubuntu-14:~/test$ sudo docker run -t -i -d gongmingqm10/jenkins-android:latest
</span><span class='line'>...
</span><span class='line'>
</span><span class='line'>vagrant@ubuntu-14:~/test$ sudo docker ps
</span><span class='line'>CONTAINER ID        IMAGE                              COMMAND                CREATED             STATUS              PORTS                               NAMES
</span><span class='line'>43fcce2388fc        gongmingqm10/jenkins-adnroid:latest    /bin/bash              17 seconds ago      Up 16 seconds                                           determined_lumiere
</span><span class='line'>vagrant@ubuntu-14:~/test$ sudo docker commit -m "Add Android Config" -a "Ming Gong" 43fcce2388fc gongmingqm10/jenkins-android:latest
</span><span class='line'>75f1b93aedc4b57426b75c96ce69170016b3c0b0b6283cda5562f8464bbfd2f4
</span><span class='line'>vagrant@ubuntu-14:~/test$ sudo docker push gongmingqm10/jenkins-android
</span></code></pre></td></tr></table></div></figure>


<p>首次push，可能会提示你输入自己的Docker Hub的用户名和密码。</p>

<h4>运行 jenkins-android</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo docker run --name jenkinsAndroid -p 8080:8080 -v /var/jenkins_home:/var/jenkins_home gongmingqm10/jenkins-android
</span></code></pre></td></tr></table></div></figure>


<p>我们使用jenkinsAndroid作为container的名字，注意这个名字也不能与已用的container 名字重复。运行一次之后，如果被自己停了，发现没有启动的话，可以使用 <code>sudo docker ps -a</code> 查看所有的container，然后找到 jenkinsAndroid这个名字的container对应的ID。启动之：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo docker start f6b88bdad68f
</span></code></pre></td></tr></table></div></figure>


<h4>访问 Jenkins</h4>

<p>在第一部分，我们直接使用Jenkins官方的Repository启动了Jenkins进行访问，经过这部分我们自己构建Dockerfile，添加了一些Android的运行环境，目的是给Android Test提供必要的运行环境。访问 <code>localhost:8088</code>可以访问这个具有Android环境的Jenkins。注册用户并登录，这一部分就完成了。</p>

<h3>4. Jenkins中配置Android Build</h3>

<p>通过访问<code>localhost:8088</code>，我们可以进入Jenkins控制台。为了使得Jenkins可以运行Android的单元测试和功能测试，主要安装如下插件：</p>

<p><code>git plugin</code>： 从 git repo 中 clone 代码</p>

<p><code>android emulator plugin</code>：Android运行功能测试时，能够帮助我们生成或者启动Android虚拟机</p>

<p><code>build monitor view</code>：全屏显示当前Build情况，适合投影到大屏幕上，方便所有人实时了解build情况</p>

<p>构建Functional test过程中，我希望通过android emulator pligin直接启动在container中已经新建的AVD。运行过程中却始终出错:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ /opt/android-sdk-linux/tools/emulator -no-boot-anim -ports 9731,9732 -avd Nexus_5_API_21 -no-snapshot-load -no-snapshot-save -no-window
</span><span class='line'>emulator: ERROR: Could not load OpenGLES emulation library: libX11.so.6: cannot open shared object file: No such file or directory
</span><span class='line'>emulator: WARNING: Could not initialize OpenglES emulation, using software renderer.
</span><span class='line'>emulator: warning: opening audio output failed
</span><span class='line'>
</span><span class='line'>$ /opt/android-sdk-linux/platform-tools/adb connect localhost:9732
</span><span class='line'>connected to localhost:9732
</span><span class='line'>[android] Waiting for emulator to finish booting...
</span><span class='line'>$ /opt/android-sdk-linux/platform-tools/adb -s localhost:9732 shell getprop init.svc.bootanim
</span><span class='line'>error: device offline
</span><span class='line'>$ /opt/android-sdk-linux/platform-tools/adb connect localhost:9732
</span><span class='line'>$ /opt/android-sdk-linux/platform-tools/adb -s localhost:9732 shell getprop init.svc.bootanim
</span><span class='line'>error: device offline
</span><span class='line'>$ /opt/android-sdk-linux/platform-tools/adb connect localhost:9732
</span><span class='line'>$ /opt/android-sdk-linux/platform-tools/adb -s localhost:9732 shell getprop init.svc.bootanim
</span><span class='line'>error: device offline
</span><span class='line'>$ /opt/android-sdk-linux/platform-tools/adb disconnect localhost:9732
</span><span class='line'>$ /opt/android-sdk-linux/platform-tools/adb connect localhost:9732
</span><span class='line'>$ /opt/android-sdk-linux/platform-tools/adb -s localhost:9732 shell getprop init.svc.bootanim
</span><span class='line'>error: device offline
</span><span class='line'>$ /opt/android-sdk-linux/platform-tools/adb connect localhost:9732
</span><span class='line'>$ /opt/android-sdk-linux/platform-tools/adb -s localhost:9732 shell getprop init.svc.bootanim
</span><span class='line'>error: device offline
</span><span class='line'>$ /opt/android-sdk-linux/platform-tools/adb connect localhost:9732
</span><span class='line'>$ /opt/android-sdk-linux/platform-tools/adb -s localhost:9732 shell getprop init.svc.bootanim
</span><span class='line'>error: device offline
</span><span class='line'>$ /opt/android-sdk-linux/platform-tools/adb disconnect localhost:9732
</span><span class='line'>$ /opt/android-sdk-linux/platform-tools/adb connect localhost:9732
</span><span class='line'>[android] Emulator was shut down before it finished booting
</span><span class='line'>$ /opt/android-sdk-linux/platform-tools/adb disconnect localhost:9732
</span><span class='line'>[android] Stopping Android emulator
</span><span class='line'>$ /opt/android-sdk-linux/platform-tools/adb kill-server
</span><span class='line'>Finished: NOT_BUILT
</span></code></pre></td></tr></table></div></figure>


<p>网上查了一下，主要是64位机器下运行32位emulator导致的一些问题。如果可以在一台都图形界面的机器上手动启动虚拟机，运行functional test的时候就应该不存在这个问题。此处先略过这个问题，后面会有专门的文章来研究这个问题。</p>

<p>在Jenkins中，建立的Build主要为 Android Unit Test &ndash; Android Functional Test &ndash; Android Deploy Hocky App.</p>

<p>通过Android的单元测试和功能测试基本可以保证App的功能处于正常状态；而Deploy到Hockey App则是为了持续集成的需要，我们要确保我们的App能够被实时生成，这样我们的产品就可以随时被测试并展示给客户，或者直接发布Hockey App 上某一个稳定的版本。</p>

<p>要想Jenkins能够直接将应用上传到HockeyApp上，我们只需要在Jenkins中安装<code>Hockey App Plugin</code>，然后通过注册Hockey App提供相应的API Token并进行简单配置，即可以直接通过Jenkins来上传发布我们的App。</p>

<h3>5. Android Flavor</h3>

<p>Android Flavor是为了Android在构建时使用不同的资源，类似于Ruby运行时可以设置不同的环境。</p>

<p>在app/build.gradle做如下配置：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>android {
</span><span class='line'>
</span><span class='line'>  defaultConfig{...}
</span><span class='line'>
</span><span class='line'>    productFlavors {
</span><span class='line'>        dev {
</span><span class='line'>            applicationId "com.tarcle.moment.dev"
</span><span class='line'>        }
</span><span class='line'>        qa {
</span><span class='line'>            applicationId "com.tarcle.moment.qa"
</span><span class='line'>        }
</span><span class='line'>        production {
</span><span class='line'>            applicationId "com.tarcle.moment"
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    signingConfigs {
</span><span class='line'>      release {...}
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    buildTypes {
</span><span class='line'>      release {...}
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    packageOptions {...}
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>通过上面的配置，我们给APP添加了三种环境变量，于是可以直接在app目录下面新建<code>dev, qa, production</code>等文件夹。通过IDE中选择不同的Build variables，便可以在当前工程中使用什么环境的配置。</p>

<p>通过<code>./gradlew clean build 任务</code>， 能够在 <code>app/build/outputs/apk</code>等目录下生成不同环境下的Debug和Release包。而这里面的Release包则可以用来Jenkins中上传到Hockey App中。</p>

<p>配置Jenkins Build和Hockey App可能用到如下插件。对于不同的Flavor，我们可以在Deploy HockeyApp 的配置中添加Build Parameters，构建时我们可以自己选择不同类型的包。从而发布不同环境下的版本。</p>

<p><code>Copy Artifact Plugin</code> 从其他的Build中直接拷贝已经生成的APK文件包。</p>

<p><code>Android Lint Plugin</code> 构建后发布Lint Report。</p>

<h3>Other</h3>

<p>关于如何直接在虚拟机中，不使用Docker构建Android Build, 将会在另一篇博文中阐述。</p>

<p>如下是我们可能用到的关于Docker 和 Android的常用命令：</p>

<p><code>android list avd</code> 查看所有当前设备。</p>

<p><code>android create avd -f -a -s 1080x1920 -n Nexus_5_API_21 -t android-21</code> 创建API-21名为Nexus_5_API_21的emulator。</p>

<p><code>emulator -avd Nexus_5_API_21</code> 运行已创建的名为 Nexus_5_API_21的emulator，注意运行时命令行会一直处于阻塞中，所以可以在末尾加上 <code>&amp;</code> 让其进入后台运行。</p>

<p><code>adb devices</code> List of devices attached。</p>

<p><code>sudo docker exec -i -t a45953b9f2fe bash</code> 进入运行中的container的控制台</p>

<p><code>echo 'y' | apt-get install libgl1-mesa-dev</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Continuous Integration]]></title>
    <link href="http://www.gongmingqm10.net/blog/2015/03/09/android-continuous-integration/"/>
    <updated>2015-03-09T12:39:35+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2015/03/09/android-continuous-integration</id>
    <content type="html"><![CDATA[<p>随着Android平台的逐渐成熟，伴随着一系列针对Android测试框架的推出，开发人员终于可以如愿以偿的在移动端的开发上进行单元测试，集成测试以及功能测试。在敏捷流程中从开发，到测试，到验收最终成为面向用户的Release版本，经历的是Story一个完整的生命周期。CI(Continuous Integration, 持续交付)在敏捷实践中也因此扮演了非常重要的角色。</p>

<p>如果说Web的持续集成，以及各类测试框架有一定的历史积淀了。那么Android的持续集成可以说是新鲜事物，大部分IT公司知道如何对服务器端或者Web端进行一系列自动化测试，保证其功能的正确性。而对于移动端的产品比较多的则是由测试人员组成的人肉测试。移动端的这种人工测试，无论是对测试人员，还是要经常打包并且来修复各种Bug的开发人员来说，其代价是巨大的。</p>

<!-- more -->


<p>从Android 2.3.3 版本就开始，我就成为了Android的开发者。从开发者的角度见证了Android的步步升级，也从普通用户的角度见证了Android在中低端市场上的统治权。虽然我对Apple的产品也很满意，但是我对Android的感情却也是无法割舍的。我庆幸自己终于能够在Android上也见证测试驱动开发的实践，也庆幸自己有机会去亲身实践，从零开始学习并了解Android的持续集成。</p>

<h3>前言</h3>

<p>本文主要是从零开始，以学习者的角色来探索如何构建可用的Android CI环境。最后的目标是，在Jenkins上从build单元测试，到功能测试的运行，最后通过一键部署编译出可供QA测试的QA版本，可供Release的Release版本，并借助HockeyApp，生成可下载的链接。</p>

<ol>
<li>构建出一个含有单元测试和集成测试简单的App原型。</li>
<li>通过vagrant在本地运行Ubuntu虚拟机，并安装Jenkins服务器，在Ubuntu上安装配置Android运行环境。</li>
<li>在Jenkins中创建Android Pipeline, Android Build &ndash;> Android Functional Test &ndash;> Android Deploy Hockey App。</li>
<li>在Android工程中创建不同的环境变量，使得构建时能够选择不同的构建变量，编译生成QA和Release等不同环境下的App。</li>
</ol>


<h3>1. 构建Android基础工程，本地运行测试</h3>

<p>这里的基础工程主要指的是能够运行测试的基础功能，我选择使用Robolectric做单元测试，使用espresso做继承测试（后面的文章也会探讨使用）。基础工程主要参考了<a href="https://github.com/robolectric/deckard-gradle">robolectric/decard-gradle</a>, 通过一些gradlew的配置，使我们的工程能够直接运行单元测试和集成测试。</p>

<p>运行单元测试:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>./gradlew test
</span></code></pre></td></tr></table></div></figure>


<p>运行espresso测试：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>./gradlew connectedAndroidTest</span></code></pre></td></tr></table></div></figure>


<p>一旦你这个实例运行成功，说明这一步其实已经完成。后面我们只需要通过jenkins来跑这几条命令，然后展示结果即可。</p>

<h3>2. 在虚拟机中安装Jenkins和Android环境</h3>

<p>为了从零开始，我选择了一台干净的Ubuntu/trusty机器，为了使构建从零开始，可以更好的模拟我们在EC2机器真实的情
形。从测试的角度来说，我选择使用<a href="https://www.vagrantup.com/">Vagrant</a>来启动虚拟机。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>XiaoMing:ci minggong$ vagrant init ubuntu/trusty64
</span><span class='line'>A `Vagrantfile` has been placed in this directory. You are now
</span><span class='line'>ready to `vagrant up` your first virtual environment! Please read
</span><span class='line'>the comments in the Vagrantfile as well as documentation on
</span><span class='line'>`vagrantup.com` for more information on using Vagrant.
</span><span class='line'>XiaoMing:ci minggong$ vagrant up
</span><span class='line'>Bringing machine 'default' up with 'virtualbox' provider...
</span><span class='line'>[default] Importing base box 'ubuntu/trusty64'...
</span><span class='line'>[default] Matching MAC address for NAT networking...
</span><span class='line'>[default] Setting the name of the VM...
</span><span class='line'>[default] Clearing any previously set forwarded ports...
</span><span class='line'>[default] Fixed port collision for 22 =&gt; 2222. Now on port 2200.
</span><span class='line'>[default] Creating shared folders metadata...
</span><span class='line'>[default] Clearing any previously set network interfaces...
</span><span class='line'>[default] Preparing network interfaces based on configuration...
</span><span class='line'>[default] Forwarding ports...
</span><span class='line'>[default] -- 22 =&gt; 2200 (adapter 1)
</span><span class='line'>[default] Booting VM...
</span><span class='line'>[default] Waiting for machine to boot. This may take a few minutes...
</span><span class='line'>[default] Machine booted and ready!
</span><span class='line'>[default] Mounting shared folders...
</span><span class='line'>[default] -- /vagrant
</span><span class='line'>XiaoMing:ci minggong$ vagrant ssh
</span><span class='line'>Welcome to Ubuntu 14.04 LTS (GNU/Linux 3.13.0-24-generic x86_64)
</span><span class='line'>
</span><span class='line'> * Documentation:  https://help.ubuntu.com/
</span><span class='line'>Last login: Tue Apr 22 19:47:09 2014 from 10.0.2.2</span></code></pre></td></tr></table></div></figure>


<p>如果在Vagrantfile中已经设置了静态IP，则可以直接通过IP登陆。vagrant默认用户名为 <code>vagrant</code>, 密码为<code>vagrant</code>。</p>

<p>使用 <code>vagrant ssh</code> 登录虚拟机之后，则开始安装各种环境：</p>

<ul>
<li>Java</li>
<li>Jenkins</li>
<li>Android Environment</li>
</ul>


<h4>2.1 安装Java</h4>

<p>apt-get直接安装jdk1.7:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>vagrant@ubuntu-14:~$ sudo apt-get update
</span><span class='line'>vagrant@ubuntu-14:~$ sudo apt-get install openjdk-7-jdk -y
</span><span class='line'>vagrant@ubuntu-14:~$ java -version
</span><span class='line'>java version "1.7.0_75"
</span><span class='line'>OpenJDK Runtime Environment (IcedTea 2.5.4) (7u75-2.5.4-1~trusty1)
</span><span class='line'>OpenJDK 64-Bit Server VM (build 24.75-b04, mixed mode)
</span></code></pre></td></tr></table></div></figure>


<h4>2.2 安装Jenkins</h4>

<p>参考<a href="https://wiki.jenkins-ci.org/display/JENKINS/Installing+Jenkins+on+Ubuntu">Jenkins官方教程</a>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>wget -q -O - https://jenkins-ci.org/debian/jenkins-ci.org.key | sudo apt-key add -
</span><span class='line'>sudo sh -c 'echo deb http://pkg.jenkins-ci.org/debian binary/ &gt; /etc/apt/sources.list.d/jenkins.list'
</span><span class='line'>sudo apt-get update
</span><span class='line'>sudo apt-get install jenkins -y
</span></code></pre></td></tr></table></div></figure>


<p>安装完Jenkins后，首先验证下Jenkins是否安装完毕, <code>curl http://localhost:8080</code>, 如果发现能够输出一堆HTML标签，那么证明Jenkins已经安装成功并已经启动了。Jenkins常见的使用命令如下，默认启动在8080端口：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>vagrant@ubuntu-14:~$ sudo /etc/init.d/jenkins -help
</span><span class='line'>Usage: /etc/init.d/jenkins {start|stop|status|restart|force-reload}</span></code></pre></td></tr></table></div></figure>


<p>Jenkins默认de配置文件为<code>/etc/default/jenkins</code>, 可以看到Jenkins_home定义的路径：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> #jenkins home location
</span><span class='line'> JENKINS_HOME=/var/lib/jenkins</span></code></pre></td></tr></table></div></figure>


<p>如果需要更改默认的Jenkins home 路径，需要更改 <code>/etc/default/jenkins</code>地址，然后重新启动jenkins即可生效。</p>

<h4>2.3 安装Android运行环境</h4>

<p>最后一步我们需要安装Android运行环境，这样我们的Jenkins才能够运行Android的相关测试。主要参考文章 <a href="https://www.digitalocean.com/community/tutorials/how-to-build-android-apps-with-jenkins">How to Build Apps with Jenkins</a></p>

<ul>
<li><a href="http://developer.android.com/sdk/index.html">Android SDK官网</a>找到最新的SDK安装包地址：<a href="http://dl.google.com/android/android-sdk_r24.1.2-linux.tgz,">http://dl.google.com/android/android-sdk_r24.1.2-linux.tgz,</a> 下载并解压：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cd /opt
</span><span class='line'>$ sudo wget http://dl.google.com/android/android-sdk_r24.1.2-linux.tgz
</span><span class='line'>$ sudo tar zxvf android-sdk_r24.1.2-linux.tgz
</span><span class='line'>$ sudo rm android-sdk_r24.1.2-linux.tgz
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>设置Android环境变量：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ vi /etc/profile.d/android.sh
</span></code></pre></td></tr></table></div></figure>


<p>Add the following to android.sh file</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>export ANDROID_HOME="/opt/android-sdk-linux"
</span><span class='line'>export PATH="$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools:$PATH"
</span></code></pre></td></tr></table></div></figure>


<p>然后 <code>source /etc/profile</code>， 使文件生效。</p>

<ul>
<li>配置 Android SDK</li>
</ul>


<p>最简单粗暴的方法是下载所有的SDK及相关的一系列工具，当然也可以挨个下载，具体参考上面提到的这篇文章。我采用直接更新全部的方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>android update sdk --no-ui
</span></code></pre></td></tr></table></div></figure>


<p>经过漫长的等待，下载完毕之后这部分的工作也基本完成。(这一步一般留在半夜自行下载)</p>

<h4>2.4 安装Git</h4>

<p>为了使Jenkins能够直接从Git Repository上下载代码，需要在Ubuntu中安装Git:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo apt-get update
</span><span class='line'>sudo apt-get install git -y
</span></code></pre></td></tr></table></div></figure>


<h4>2.5 配置Jenkins</h4>

<p>Jenkins启动后，首先注册登录用户，然后创建新的Build Project。构建就基本完成了。当然你也可以在前一篇博客 <a href="http://www.gongmingqm10.net/blog/2015/03/11/setup-jenkins-for-android-integration-using-docker/">Set up Jenkins for Android integration using Docker</a>中找到一些插件，通过这些插件能够更好的实现Android的持续集成，包括通过Hockey App 持续的发布新的版本。</p>

<p>具体安装细节，可以参考<a href="http://www.gongmingqm10.net/blog/2015/03/11/setup-jenkins-for-android-integration-using-docker/">Setup Android CI using Docker</a></p>

<p>粗略说来，安装插件: <code>Git plugin, Android emulator plugin, Copy artifact plugin, Android lint plugin, Hockey app plugin, Build monitor plugin</code></p>

<p>运行时发现jenkins用户对jenkins-home目录没有操作权限，需要通过chmod增加权限。在当前vagrant用户下，<code>su jenkins</code> 能够切换到jenkins目录下，但是需要提供密码。所以可以自行修改密码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>vagrant@ubuntu-14:/var/lib/jenkins$ sudo passwd jenkins
</span><span class='line'>Enter new UNIX password:
</span><span class='line'>Retype new UNIX password:
</span><span class='line'>passwd: password updated successfully
</span><span class='line'>vagrant@ubuntu-14:/var/lib/jenkins$ su jenkins
</span><span class='line'>Password:
</span><span class='line'>jenkins@ubuntu-14:~$</span></code></pre></td></tr></table></div></figure>


<p>权限设置成功后，再次运行测试，提示Android Build Tools没有安装成功：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ ./gradlew clean build
</span><span class='line'>
</span><span class='line'>FAILURE: Build failed with an exception.
</span><span class='line'>
</span><span class='line'>* What went wrong:
</span><span class='line'>A problem occurred configuring project ':app'.
</span><span class='line'>&gt; failed to find Build Tools revision 21.1.2
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>Android Build Tools的版本号是我们在app/build.gradle中指定的21.1.2。通过 <code>android list sdk --all</code>能够查看所有可以下载的sdk列表。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Packages available for installation or update: 138
</span><span class='line'>   1- Android SDK Tools, revision 24.1.2
</span><span class='line'>   2- Android SDK Platform-tools, revision 22
</span><span class='line'>   3- Android SDK Build-tools, revision 22.0.1
</span><span class='line'>   4- Android SDK Build-tools, revision 22 (Obsolete)
</span><span class='line'>   5- Android SDK Build-tools, revision 21.1.2
</span><span class='line'>   6- Android SDK Build-tools, revision 21.1.1 (Obsolete)
</span><span class='line'>   7- Android SDK Build-tools, revision 21.1 (Obsolete)
</span><span class='line'>   8- Android SDK Build-tools, revision 21.0.2 (Obsolete)
</span><span class='line'>   9- Android SDK Build-tools, revision 21.0.1 (Obsolete)
</span></code></pre></td></tr></table></div></figure>


<p>可以看到21.1.2的索引值是5，所以可以使用 <code>android update sdk -u --all --filter &lt;number&gt;</code>更新，发现出现权限问题。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Installing Archives:
</span><span class='line'>  Preparing to install archives
</span><span class='line'>  Downloading Android SDK Build-tools, revision 21.1.2
</span><span class='line'>  URL not found: /opt/android-sdk-linux/temp/build-tools_r21.1.2-linux.zip (Permission denied)
</span><span class='line'>  Done. Nothing was installed.</span></code></pre></td></tr></table></div></figure>


<p>可以直接在当前用户下给/opt/android-sdk-linux以及其子文件夹增加777权限。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo chmod -R 777 /opt/android-sdk-linux</span></code></pre></td></tr></table></div></figure>


<p>然后安装Android build tools 21.1.2, <code>android update sdk -u --all --filter 5</code>。安装完成后还可能会出现错误:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>:app:mergeDevDebugResources FAILED
</span><span class='line'>
</span><span class='line'>FAILURE: Build failed with an exception.
</span><span class='line'>
</span><span class='line'>* What went wrong:
</span><span class='line'>Execution failed for task ':app:mergeDevDebugResources'.
</span><span class='line'>&gt; Error: org.gradle.process.internal.ExecException: A problem occurred starting process 'command '/opt/android-sdk-linux/build-tools/22.0.1/aapt''</span></code></pre></td></tr></table></div></figure>


<p>Google了一番，才发现是Android在64为Linux机器上运行而产生的问题，需要安装<code>ia32-libs</code>, 但是通过apt安装确被告知ia32-libs不存在，无法安装。<a href="http://stackoverflow.com/questions/23182765/how-to-install-ia32-libs-in-ubuntu-14-04-lts-trusty-tahr">stackoverflow</a>解决办法如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo -i
</span><span class='line'>cd /etc/apt/sources.list.d
</span><span class='line'>echo "deb http://old-releases.ubuntu.com/ubuntu/ raring main restricted universe multiverse" &gt;ia32-libs-raring.list
</span><span class='line'>apt-get update
</span><span class='line'>apt-get install ia32-libs</span></code></pre></td></tr></table></div></figure>


<p>安装成功后，Android 单元测试即可成功运行。</p>

<p>单元测试之后，我们往往需要运行功能测试，功能测试的时候则需要打开模拟器。也就是 headless android emulator。首先在虚拟机中创建 avd, 然后启动运行模拟器。</p>

<p>运行之前需要先安装 API-21对应的 armeabi-v7a， 才能够创建虚拟机。通过查看<code>android list sdk --all</code>得知其对应的序列号是68，所以可以通过android update安装：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>android update sdk -u --all --filter 68</span></code></pre></td></tr></table></div></figure>


<p>安装完成后创建API-21虚拟机：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>android create avd -f -a -s 1080x1920 -n Nexus-21 -t android-21 --abi</span></code></pre></td></tr></table></div></figure>


<p>虚拟机创建成功后需要打开虚拟机：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>emulator -avd Nexus-21 -no-skin -no-audio -no-window</span></code></pre></td></tr></table></div></figure>


<p>顺利的话，到这里功能测试应该也能够运行了。但是在我的虚拟机里面却没办法启动android emulator。看来想构建真正的android功能测试，还是用一台配有显示器的Mac mini来运行比较的靠谱。</p>

<h3>3.Other</h3>

<p>如何在Android中配置不同的Flavor，如何上传构建好的App到HockeyApp中。欢迎查看我的<a href="http://www.gongmingqm10.net/blog/2015/03/11/setup-jenkins-for-android-integration-using-docker/">博客</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Work in Dallas]]></title>
    <link href="http://www.gongmingqm10.net/blog/2015/03/02/work-in-dallas/"/>
    <updated>2015-03-02T02:39:53+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2015/03/02/work-in-dallas</id>
    <content type="html"><![CDATA[<p>时光匆匆，算上实习期来ThoughtWorks工作已近一年。如果技术方面来看，我提升的主要是广度。但是从敏捷实践角度来看，我正在也将继续朝深度上提升。</p>

<p>敏捷这个词，大学期间或多或少听过，大体的印象是软件工程学的一些术语，之后在项目中才开始慢慢实践。我前后经历过三四个项目，虽然每个项目待的时间不长，但是却又想能够和不同的团队，面对不同的客户，也有幸能够在不同的国家体会不同文化下的敏捷实践的标准。</p>

<!-- more -->


<p>由于敏捷包含的方面很多，作为Developer的我，也会主要从Developer的角度，结合自己的想法来谈自己在这一年对敏捷的认识。此文不是软文，只是自己闲时的一点纪录。不喜求轻喷。</p>

<h3>开发驱动测试(DDT)</h3>

<p>加入TW，很长一段时间我一直都抱有这个想法。当时虽然已经在项目上工作，在Code Review的压力下也会偶尔用开发驱动测试(DDT)。因为别人告诉我<code>不写测试的程序员不是好程序员</code>，这个句式怎么听起来和<code>不想当将军的士兵不是好士兵</code>一个道理。听起来是很多道理，但是真正实施的时候呢，我开始犯难了。</p>

<p>测试的痛点在哪里？我常这样问自己，其实我有时也不知道痛点再哪里，只是不太会写。为什么不会写？因为我连怎么实现都不知道，怎么会写？通过这样反推过来也就是只有知道怎么实现，才知道怎么写测试。这个观点对吗？</p>

<blockquote><p>只有知道怎么实现，才会知道怎么写测试。写测试有点作秀的嫌疑</p></blockquote>

<p>这是我曾经的观点，先别批评我逻辑性或者对测试的理解有多差，因为这是我过去的想法。如果我现在来看这句话的话，我会套用那句很通用的 <code>It depends</code>。肯定有人会反驳，那到底取决于什么呢。</p>

<p>以我现在的认知来看，我之所以不知道在实现之前怎么写测试，往往是由于要测试的对象本身很大，很杂，一个方法要管的事情太多了，所以我不知道怎么测试。其实回过头来想想，当一个东西连测试都很难写的时候，是不是意味着我所要测试的函数做了太多的事情了呢。</p>

<ul>
<li>重构里的术语来讲，自己对类或者方法的设计不太合理，导致要测试的内容过多而不知从何下手。</li>
<li>另外一种角度来看，如果一个测试很难描述出测试对象的时候，为什么不可以多增加几个测试，循序渐进的去添加测试。</li>
<li>如果以上两种情况你都不属于，很不幸有可能你在动手之前应该查一下，确保自己清楚这个被测对象的职责，代码上基本的实现思路。</li>
</ul>


<p>当然对于某些情况，我确实可以先写测试再写实现。例如一个简单的计算器的加法，测试中我知道给函数两个输入值，我期望能够输出某种结果。在这种情形下我知道怎么写测试因为要测试的对象足够简单，负责的事情足够清楚。这种有结果输出的测试也是相对简单的。这时候我甚至完全不用操心别人究竟怎么实现的，我只需要用强有力的测试来验证结果即可。</p>

<p>知已知彼，百战不怠。你之所以知道怎么用测试驱动开发，因为你在测试之前已经在心中将这个函数设计和实现了一遍。如果你和我一样达不到这种境界，那可能就是对这块知识了解确实太少，意味着你该自己补补了。</p>

<h3>测试的价值</h3>

<p>测试到底有没有价值，得看你是怎么理解价值的。从科学的角度来看，肯定会有人用实验来证明写测试能够减少Bug发生率，虽然前期写测试花费时间，但在后期却能够节约时间。这种最常见的来证明敏捷实践标准的理论数见不鲜，但是有时却很难是刚入门的人信服。</p>

<p>从我经历过的项目来看，有测试或者没测试的项目都有接触过。对测试的价值也有自己的认识。先不管别人的研究结果如果，单从开发人员开发时间来考虑，测试的确会花费更多时间，相当于你要写两份代码，一份实现，一份保证已实现的功能不被后期修改破坏掉。当然测试的确可以提高产品质量。</p>

<p>什么时候我不会写测试，虽然我信奉测试是产品质量的保障，但是有时我不一定会写测试：</p>

<ol>
<li>交付周期过短的项目，并且是在没有引入测试的项目基础上开发。这种项目在国内客户中比较常见，多半是对原来的项目增加一个模块，并且之前的代码没有测试。这类项目的特点是周期短，功能相对较少。敏捷实践是敏捷实践，但是没必要固执的和自己死磕。因为也许客户并不在乎你有没有测试，只在乎产品能不能按期上线。</li>
<li>功能变化过快的互联网产品。一些初创型公司在做产品时往往信奉<code>天下武功，唯快不破</code>，特别是公司人手不够，功能较多，并且在每两周一次的迭代中功能变化过大的时候，维护测试变显得有点复杂。当然并不意味着任何的测试都是多余的。这里有个测试力度的问题，具体得靠自己的把握。</li>
</ol>


<p>什么时候我会在项目中引入测试呢？</p>

<ol>
<li>项目周期相对较长，客户经济上有能力承担多几个开发者带来的成本；</li>
<li>如果是在客户原有系统上开发，之前的系统就有一套测试体系，无疑我们在增加代码的时候应该增加测试。而且尽量沿用之前已经构建好的一整套测试体系。</li>
<li>一个从零开始的项目，并且有可能建立长期合作的客户。这是TW的核心竞争力，卓越软件质量的前提。客户不提，我们自己也应该做到。</li>
</ol>


<p>写测试是一种好习惯，至少作为一个合格的程序员，应该写测试。如果你是一个Github上代码贡献的活跃者，在为自己写代码的时候，请尽量为自己的代码加上测试。<a href="https://travis-ci.org/repositories">Travis</a>就是这样一个免费的提供CI服务的平台，如果你想为自己的代码加上测试但是又不想自己去搭建CI，可以试试Travis。</p>

<p>回归正题，测试的价值在于你多看重软件质量。测试有时会消耗一定的时间，但是有测试保障的软件在质量上的确可以提高好几个层次。是否写测试则需要结合你自己的项目实际情况以及客户本身而定。</p>

<p>如果你经历过国内客户和国外客户，那么你应该能够体会到他们对于软件质量的不同态度。当然所有人肯定都希望软件交付质量最高，时间最短。但是当两者需要权衡的时候，国内客户比较在乎的会是进度，国外客户比较在乎的是质量。所以质量和进度之间需要找到一个平衡点。</p>

<p>从国内外客户的差异，其实也可以联想到国内外软件开发者的差异。到美国这边与美国这边的同事办公之后发现，这边的同事对于测试的重视程度要远远高于国内的同事(不是黑ThoughtWorks China的同事们)。<code>You can not do anything when you write test. Test first</code>，这是美国这边一位senior的同事和我pair的时候说的。自己曾经那些不好的编程习惯到了这边是应该好好改改了。</p>

<p>在美国这边工作曾经有几天我对项目上的测试有点质疑了，因为有些地方实在测的太细，几乎是想用测试覆盖掉每一行代码，并且有些代码还被多个测试覆盖。后来偶然的聊天中，同事告诉我 <code>I think I don't write so much meaningful tests in our code, some tests seems to be useless. And Jered is more expereienced, he pointed out.</code>，虽然这是一种谦虚的说法。但是这却告诉我，写好测试才能真正体现测试的价值。</p>

<p>我姑且称那些永远不会fail，或者基本没有测任何有意义的东西的测试为<code>僵尸测试</code>，这种测试太多了直接影响整个测试的可阅读性。好的测试应该可以通过函数命名，测试输出结果的判断来提供文档的功能。所以不要用数量来堆砌测试，努力写好测试是关键。</p>

<h3>敏捷团队角色</h3>

<p>敏捷开发中很重要的一部分是团队角色。一个敏捷团队主要有应用开发工程师(Dev)，业务分析师(BA)，质量保障工程师(QA)等。在项目的Story估点之时，除了有BA和QA的参与，Dev的参与也是很重要的部分。BA和QA主要从业务上评估，Dev主要从技术上评估，这种多人参与过的估点才是有意义的。</p>

<p>同样一个Story制定的时候产品设计效果图和可验证的Scenario是很重要的。Scenario的制定其实考察的是BA/QA对业务以及实际使用场景的考验。这一点我在Mobile端体会尤其明显。因为Mobile端更重交互，对于用户可能有的行为，制定验收标准是就应该考虑清楚。所以这时候BA不仅仅承担一个业务分析的角色，还承担着用户的角色。</p>

<p>Dev和BA沟通Story的时候最简单的情形是以用户为媒介。无论业务分析还是开发实现，最终都是为了给终端用户一个具有某种功能的产品。</p>

<p>有时我会想如果让Dev转型当BA，那这个BA一定很能了解功能的实现者。后来发现这种想法本身存在一定的问题，因为不管这个BA懂不懂具体的实现，BA/QA应该懂的是用户，应该懂得是平台特性以及用户特性。无论是Mobile和Web，抑或是Android和IOS，无论是敏捷团队的何种角色，你都得尝试去了解这个平台的特性，了解终端用户，才能够做出更好的决策。</p>

<h3>结语</h3>

<p>作为ThoughtWorks咨询师，我们应该知道公司的核心竞争力是什么，我们也更应该尝试去影响客户，给客户带来价值。也希望新的一年里自己能够在敏捷实践上做得更好，能够帮助客户，影响客户。</p>

<blockquote><p>We think disruptively to deliver technology to address our clients&#8217; toughest challenges, all while seeking to revolutionize the IT industry and create positive social change.</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Travel to Dallas - Life]]></title>
    <link href="http://www.gongmingqm10.net/blog/2015/03/01/travel-to-dallas-life/"/>
    <updated>2015-03-01T11:44:57+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2015/03/01/travel-to-dallas-life</id>
    <content type="html"><![CDATA[<p>来达拉斯已过半月，从去年的十二月份开始规划，到二月中旬过来，再到过完这边最难熬的两个星期。生活工作渐入正轨，是时候来总结下这个特别的二月。</p>

<h3>出差</h3>

<!-- more -->


<p>“去美国出差”，第一次知道这条消息还是YueYue发我微信上的。看完这条消息的时候内心很激动，因为终于可以去大美利坚了。记得毕业的时候就特羡慕能够来美国念书的同学，心里想着以后有机会也去美国看一看，看一看外面的世界，见识下外面的风土人情。如今这个选择摆在我的面前，我不想像周星驰那句台词里说的那样，“曾经有一段很好的&hellip;摆在我面前，但是&hellip;”。</p>

<p>我要去美国，就是这种想法瞬间在自己的脑海中扎根。冷静之余，我开始想到生活，想过没办法回家过年，和女友又得继续分别数月，在武汉的生活好不容易走上正轨，又得开始去陌生的地方，与陌生的人共事。这种惶恐让人感觉到迷茫。坚定决心，开始和女朋友沟通，于是沟通了几个小时，两人差点闹得分手了。最终我还是说服了在电话那头涕不成声的女友，和父母的沟通稍微顺畅一点，父母支持我自己的决定，但是后来听姐姐说妈妈挂完电话后眼泪也流下来了&hellip;</p>

<p>这有点让我想起一些黑帮片里面的情形，走江湖的都基本无情无爱，了无牵挂，才能走得更远。当然现实生活中，事情远不是0和1的选择，很多事情可以协调的，终于把去美国出差的意向确定了。内心还是十分开心的。</p>

<blockquote><p>对某个城市有个情感的牵绊之后，无论出差到哪里，都只是在漂泊</p></blockquote>

<h3>签证顺利</h3>

<p>由于一直有公司出面，赴美签证，办得相当顺利。前提公司督促我提交各种材料，到2月初终于开始去美国使馆进行面前。除了之前转机在机场停留后，这其实是我第一次到北京，去的那边北京的天空还是挺蓝的。首都给我的印象挺好的，首都国际机场有直达市区的轻轨，这一点比其他二线城市方便多了。到北京后下午立即赶到北京，在Kun的指导下温习了一下次日使馆面试官可能会问我的问题。这种状态颇有大考来临之前老师教我们临阵磨枪的味道。晚上在宾馆停留一晚，第二天赶早去大使馆。</p>

<p>第二天一大早及其兴奋的到了大使馆，结果八点半的美国使馆门口已经是站满了人，几经周折，寄存了手机，抛弃了耳机之后终于来到了大厅。一位和善的面试官接待了我，不知道是太久没听英文了还是什么原因，我竟然基本听不懂面试官在说什么，面试官也估计很奇怪，英文这么差还去出差。但是面试官看我满脸疑惑的时候竟然给我充当了翻译。还好最后面试官对我说了&#8221;Have a good trip&#8221;，我赶紧的各种Thank you奉上。面试完之后，继续上楼缴费了500美元，看来我数月前办的全币信用卡瞬间奏效，出差或者旅游频繁还是要办一张可以刷外币的卡比较安全。</p>

<p>面签顺利通过，签证三日左右就可以拿到。于是我赶紧收拾收拾，返回武汉。</p>

<blockquote><p>面签顺利结束，北京之行太过匆匆</p></blockquote>

<h3>踏上旅途</h3>

<p>出发之前，必然少不了超市淘一批货带到美国。考虑到刚到的时候说不一定能够摸清周围超市状况，我自备牙膏牙刷等洗漱用品。饮食方面，带了我最爱的老干妈以及盐、鸡精等厨房调味品。中国菜不是哪里都有的。当然出发之前还特地买了几件稍微正式点的衣服，唯恐穿着方面给国人丢脸(事实证明想多了)。</p>

<p>临别晚上彻夜未眠，突然要匆匆离别时才觉得平平淡淡的生活竟是如此的宝贵。周围熟悉的一切竟是如此的让人留恋。早上五点半便踏上了去机场的旅程，天还是黑黑的，没有惊动室友。因为大家都是不舍离别的人。</p>

<p>紧接着便是武汉转香港，香港飞达拉斯的旅途。总共二十多个小时的旅途坐得跟以前的硬座火车感觉差不多。几乎昏睡的状态到达了达拉斯。第一感觉就是空旷，没有高耸如云的建筑物，天很蓝，空气真好。</p>

<p>匆忙的安排中没有找到接机的人，于是自己在机场拿起笔记本，找到了自己的地址。还好出口处便直接找到了Yellow cab（出租车），给师傅看了看地址，师傅娴熟的用Google地图来导航，四十余分钟，终于来到了自己的公寓。各种波折，最后终于跨进了自己的房间，放下行李。终于可以说一声：</p>

<blockquote><p>美国，我来了</p></blockquote>

<h3>如何生存</h3>

<p>陌生的环境中最重要的就是吃饭问题，正好趁上周末开始网上搜索附近的超市。最终找到了一家最近的超市，可以买到蔬菜水果和各种吃的。后来还探访到附近的Target专门卖生活用品的，以及Walmart会有更有的其他选择。赶紧的凑齐各种食材，终于在自己的努力下吃了自己在美帝国的第一顿饭，炒的菜有点水土不服，但是电饭煲蒸出来的饭全世界的味道都差不多。再加上周围的各种餐厅，吃饭的问题总算不用愁了。</p>

<p>出行，最初的设想是周末几天出去探访下这边的公共交通，后来发现这边的交通实在是少的可怜，并且在手机没网没发进行户外GPS导航的情况下，公共交通出行着实过于复杂，很容易弄丢。为了不耽误别人，我还是选择近距离在附近转悠。于是自己的活动半径基本就限制在公寓和超市之间。达拉斯在美国应该只能算是二线城市，所以没有这么多的公共交通，这边的人基本上都有自己的车，他们也确实用不上公交车。还好公司考虑到我这种情况，在热心同事的帮助下，总算是能够搭便车了。</p>

<p>刚来的这几天天气真是超好，整个一达拉斯的春天的感觉。再后来发现开始降雪。还好室友有保暖措施，所以室内温度总是很宜人。不过如果长时间待在外面，还是带件稍微厚点的衣服会比较靠谱一点。</p>

<p>医院，来这边没多久，眼睛麦粒肿就把我折腾到了要去看医生的境地。那么问题来了，医院在哪，怎么看医生？几番打探之后，发现附近走路一刻钟就可以找到一家CityDoc Urgent Care, 就诊时带上自己的护照就可以了。然后就是各种资料，填完后就开始等着医生喊我的名字，诊断之后就是去药房Pharmacy拿药。稍微看下医生就花了100多刀，美国的看病还真是不便宜。还好自己终于知道如何看病了。至少不会像以前那么的不安与紧张。</p>

<blockquote><p>衣食住行，生活的根本</p></blockquote>

<h3>SSN申请</h3>

<p>入境美国后，并且如果要长期待的话，SSN社会安全卡的申请自然少不了。公司负责人员会给我发一堆表格，填完之后我得自己去当地的社会安全组织办公室申请，在deadline去申请真不是一件明智的事情。首先，我没考虑到工到Social Security Administration的工作时间，导致差点错过这一天的申请。</p>

<p>申请的这边这天竟然也下着雪，出租车似乎都不怎么停。后来才知道我应该通过App或者电话预约才能够叫到出租车。还好我通过传统的招手的方式找到了出租车。详细描述了地址之后，出租车师傅终于把我带到了社会安全办公室。另外这边的出租车也应该给小费，但凡服务行业都应该给小费10%-20%。</p>

<p>申请通过之后，工作人员会给我一个单子，告诉我社会安全卡会在十个工作日之内寄过来。于是这次申请就完成了。</p>

<h3>结语</h3>

<p>来到TW后，生活发生了翻天覆地的变化，从前一个人在学校里面想去外面走走，现在发现在外面走走之后竟然想回去了。上次参加TWU的时候还有小伙伴陪着一起，这次竟然也就一个人踏上了这段旅途。一个人的旅途充满了各种挑战，一个人扛着一大包东西从超市往回提，一个人在国外度过春节，一个人冒着大雪在这个陌生的地方拦出租，却也一个人周末待在家里连续三天不出门。</p>

<p>我深信这是种经历，经历了异国的生活才能够更好的认识之前的生活。看到这边超市里各种人性化的设计，看到这边红绿灯路口的设计，遇见这边随时都会向你问好并且“Excuse me”的友善。这些都让我对我所生活的这个世界有了更清晰的认识。</p>

<p>美国的生活才过去半月，剩下的两个半月我希望能够认识更多，见识更多，增长更多。无论从工作还是生活，希望一切顺顺利利。</p>

<blockquote><p>Life is a journey, not a destination</p></blockquote>

<p><img src="http://www.gongmingqm10.net/images/dallas-redlight.jpg" title="红绿灯路口" ></p>

<p>行人通过红绿灯路口需要按下按钮，估计这边车多行人少的缘故</p>

<p><img src="http://www.gongmingqm10.net/images/dallas-target.jpg" title="Target百货店" ></p>

<p>这是Target百货店，我在这里找到了自己要买的电饭煲</p>

<p><img src="http://www.gongmingqm10.net/images/dallas-dfl.jpg" title="耸动的云" ></p>

<p>纯净的天空下那股耸动的云，如末日来临一样宏大的场面</p>

<p><img src="http://www.gongmingqm10.net/images/dallas-travis-street.jpg" title="Travis Street" ></p>

<p>自己生活的Travis Street, 天气晴好时外面还是很值得去的。视野一下子清新了不少</p>

<p><img src="http://www.gongmingqm10.net/images/dallas-snow.jpg" title="Dallas雪景" ></p>

<p>Dallas也是会下雪的，或者说是冻雨。路面全部结冰，上班出行困难。温度变化太快</p>

<p><img src="http://www.gongmingqm10.net/images/dallas-social-security-office.jpg" title="Dallas Social Security Office" ></p>

<p>办社会安全卡的地方，这里很少见高高的大楼</p>

<p><img src="http://www.gongmingqm10.net/images/dallas-laoganma.jpg" title="神器老干妈" ></p>

<p>老干妈，出行必备神器。美国亚马逊上直接购买</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[常用的Linux Cmd]]></title>
    <link href="http://www.gongmingqm10.net/blog/2014/10/30/chang-yong-de-linux-cmd/"/>
    <updated>2014-10-30T15:47:40+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2014/10/30/chang-yong-de-linux-cmd</id>
    <content type="html"><![CDATA[<p>ls：查看目录下所有可见文件<br/>
ls -a ： 查看目录下所有文件，包括隐藏文件  <br/>
ls -l : 查看目录下可见文件的详细信息<br/>
ls -al 查看目录下所有文件的详细信息</p>

<!-- more -->


<p>cat file: 查看文件内容<br/>
cat -n file: 查看文件内容，并显示出行号<br/>
cat file1 file2 >> file3：将file1, file2的文件内容以此加到file3中，如果file3存在，则会在file3后面继续追加，不会覆盖file3原来的内容，如果file3不存在，则会自动创建。若需要强行覆盖，使用一个  > 即可</p>

<p>touch file: 新建文件，当文件存在时则会更新文件的时间戳</p>

<p>pwd: 查看当前目录<br/>
cd {path} : 进入目录</p>

<p>mkdir {directory}: 新建目录，若某子目录不存在则可能新建失败<br/>
mkdir -p {directory}: 新建目录，对于不存在的子目录可以一并创建</p>

<p>tree: 查看当前目录的文件树结构</p>

<p>cp file1 file1-copy: 复制file1到file1-copy<br/>
cp -r dir1 dir2: 复制文件夹dir1到dir2</p>

<p>mv: 移动文件，也可用来重命名文件，具体用法和cp一样</p>

<p>rmdir directory1: 移除一个空的文件夹<br/>
rm file: 移除文件<br/>
rm -r directory1: 移除文件夹</p>

<p>chmod：修改文件的权限
u : user, g : Group, o : others    增加权限“＋”，删除权限“－”   r (Read), w (Write), x (Execute).<br/>
chmod u+x file1, 给当前用户增加对file1的执行权限</p>

<p>wc -l file1: 计算file1的行数<br/>
wc -w file1: 计算file1单词的个数<br/>
wc -c file1: 计算file1中字符的个数</p>

<p>history: 查看历史命令纪录<br/>
!-1 : 执行倒数第一条命令<br/>
!345: 执行第345条命令</p>

<p>cat file1 | grep A : 从file1中找到带有‘A’的行<br/>
find . -name *.png 在当前文件夹下查找后缀名为.png的文件，子文件夹中的文件也可以被找出。</p>

<p>更多命令，欢迎大家一起总结与补充</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android电话监听]]></title>
    <link href="http://www.gongmingqm10.net/blog/2014/10/29/androiddian-hua-jian-ting/"/>
    <updated>2014-10-29T11:11:48+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2014/10/29/androiddian-hua-jian-ting</id>
    <content type="html"><![CDATA[<p>看题名，本篇博文似乎是关于怎么监听别人的电话。其实不然，这里我主要做的是监听自己的电话。监听自己电话的场景来源如下：<br/>
我最近在换手机，当然也在换号。于是面对两个号码两部手机，特别是一些捆绑了银行卡活着以前的快递等情况下，我必须得带两部手机出门，防止旧手机上重要的电话漏接。最开始是想直接进行通过转接，但是面对电信和移动间的通话转移，我放弃了这个想法。于是开始想着用软件提醒。<br/>
在老手机上安装APP，这个APP的作用是监听来电，来电挂断之后会自动给你设定的新手机上发送短信，告诉你谁给你打来了一个未接电话，这样你在新手机上看到短信来电提醒，于是可以直接在新手机上进行回复了。虽然不能直接解决通话的问题，但是确解决了我的问题。考虑到老手机上每个月的短信套餐，发现其实成本也几乎为零。</p>

<!-- more -->


<p>实现部分主要注册一个CallReceiver，并给我们的Receiver监听电话，发送短信，开机重启等权限。编译通过后便可以安装在手机上使用了。贴出主要代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>package net.gongmingqm10.callwatcher;
</span><span class='line'>
</span><span class='line'>import android.app.Service;
</span><span class='line'>import android.content.BroadcastReceiver;
</span><span class='line'>import android.content.Context;
</span><span class='line'>import android.content.Intent;
</span><span class='line'>import android.telephony.SmsManager;
</span><span class='line'>import android.telephony.TelephonyManager;
</span><span class='line'>import android.util.Log;
</span><span class='line'>
</span><span class='line'>public class CallReceiver extends BroadcastReceiver {
</span><span class='line'>
</span><span class='line'>    private final static String NUMBER = "Your Phone number"; //我的新手机号
</span><span class='line'>    @Override
</span><span class='line'>    public void onReceive(Context context, Intent intent) {
</span><span class='line'>        if (intent.getAction().equals(Intent.ACTION_NEW_OUTGOING_CALL)) return;
</span><span class='line'>        TelephonyManager tm = (TelephonyManager) context.getSystemService(Service.TELEPHONY_SERVICE);
</span><span class='line'>        SmsManager sms = SmsManager.getDefault();
</span><span class='line'>        Log.i("state", "state = " + tm.getCallState());
</span><span class='line'>        if (tm.getCallState() == TelephonyManager.CALL_STATE_IDLE) {
</span><span class='line'>            String incomingNumber = intent.getStringExtra("incoming_number");
</span><span class='line'>            try {
</span><span class='line'>                Thread.sleep(5000);
</span><span class='line'>            } catch (InterruptedException e) {
</span><span class='line'>                e.printStackTrace();
</span><span class='line'>            }
</span><span class='line'>            sms.sendTextMessage(NUMBER, "", "主人，有人给你附属机打电话了：" + incomingNumber, null, null);
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;?xml version="1.0" encoding="utf-8"?&gt;
</span><span class='line'>&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"
</span><span class='line'>    package="net.gongmingqm10.callwatcher" &gt;
</span><span class='line'>
</span><span class='line'>    &lt;uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"/&gt;
</span><span class='line'>    &lt;uses-permission android:name="android.permission.READ_PHONE_STATE"/&gt;
</span><span class='line'>    &lt;uses-permission android:name="android.permission.PROCESS_OUTGOING_CALLS"/&gt;
</span><span class='line'>    &lt;uses-permission android:name="android.permission.SEND_SMS"/&gt;
</span><span class='line'>
</span><span class='line'>    &lt;application
</span><span class='line'>        android:allowBackup="true"
</span><span class='line'>        android:icon="@drawable/ic_launcher"
</span><span class='line'>        android:label="@string/app_name"
</span><span class='line'>        android:theme="@style/AppTheme" &gt;
</span><span class='line'>        &lt;activity
</span><span class='line'>            android:name=".MainActivity"
</span><span class='line'>            android:label="@string/app_name" &gt;
</span><span class='line'>            &lt;intent-filter&gt;
</span><span class='line'>                &lt;action android:name="android.intent.action.MAIN" /&gt;
</span><span class='line'>
</span><span class='line'>                &lt;category android:name="android.intent.category.LAUNCHER" /&gt;
</span><span class='line'>            &lt;/intent-filter&gt;
</span><span class='line'>        &lt;/activity&gt;
</span><span class='line'>        &lt;receiver android:name=".CallReceiver"&gt;
</span><span class='line'>            &lt;intent-filter&gt;
</span><span class='line'>                &lt;action android:name="android.intent.action.BOOT_COMPLETED"/&gt;
</span><span class='line'>                &lt;action android:name="android.intent.action.PHONE_STATE"/&gt;
</span><span class='line'>                &lt;action android:name="android.intent.action.NEW_OUTGOING_CALL"/&gt;
</span><span class='line'>            &lt;/intent-filter&gt;
</span><span class='line'>        &lt;/receiver&gt;
</span><span class='line'>    &lt;/application&gt;
</span><span class='line'>
</span><span class='line'>&lt;/manifest&gt;
</span></code></pre></td></tr></table></div></figure>


<p>主界面几乎没任何交互。主要实现功能，想更多交互的话可以继续～</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Data Cache]]></title>
    <link href="http://www.gongmingqm10.net/blog/2014/10/28/android-data-cache/"/>
    <updated>2014-10-28T17:11:26+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2014/10/28/android-data-cache</id>
    <content type="html"><![CDATA[<p>Android APP开发过程中，我们通常会加入缓存模块。缓存即在本地保存APP的一些数据，大部分是将网络请求的数据进行本地保存，这样在缓存数据有效期内就可以直接使用缓存数据，降低了APP和服务器的压力，也极大提升了用户体验。Android数据缓存既可以以数据表的形式进行保存，也可以以文件的形式进行缓存。这里我主要通过缓存文件存储数据，并在APP下一次启动时读取。</p>

<!-- more -->


<h3>Usage</h3>

<p>整个Cache模块的设计思想很简单，每个缓存数据都对应一个key，每个缓存数据又会被存到以此key命名的文件中，需要时直接读取。关键类分别为<code>CacheData</code>, <code>CacheManager</code>, <code>CacheUtils</code>。</p>

<ul>
<li>CacheData：数据封装类，所有欲缓存的数据都通过CacheData封装，CacheData中能够定义缓存有效期，并可以通过getData()直接获取真实的缓存数据。</li>
<li>CacheManager: 缓存管理类，单例模式设计，负责缓存的存储和读取。</li>
<li>CacheUtils: 缓存常用类，所有的缓存Key都应该在这个类中定义，此类还定义了一些时间常量，缓存有效期中可以使用。</li>
</ul>


<p>使用方法如下：</p>

<ul>
<li>step1: <code>CacheManager.init(Context context)</code>, 在APP加载时就应该对CacheManager初始化。</li>
<li>step2: 自定义的Model需要实现序列化，使用CacheData进行包装，然后使用CacheManager进行存储和读取。</li>
</ul>


<h3>Code Download</h3>

<p>项目代码托管在<a href="https://github.com/gongmingqm10/AndroidUikit/tree/master/library/src/main/java/org/gongming/common/cache">Github Repo</a>中，欢迎star和fork。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hack 京东 Lebook]]></title>
    <link href="http://www.gongmingqm10.net/blog/2014/10/26/hack-jing-dong-lebook/"/>
    <updated>2014-10-26T22:46:18+08:00</updated>
    <id>http://www.gongmingqm10.net/blog/2014/10/26/hack-jing-dong-lebook</id>
    <content type="html"><![CDATA[<p>adb devices : 列出所有的设备</p>

<p>adb -s XXXX shell: 进入指定的shell</p>

<p>adb shell: 进入唯一的shell</p>

<p>在terminal中直接： adb pull /data/data/com.jingdong.app.reader/files/epub/3690098/534543.jeb <br/>
~/Desktop/test.epub。可以直接拿到epub文件</p>
]]></content>
  </entry>
  
</feed>
